; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgrePixelFormat.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?ID@?$PixelConverter@II$0MAN@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3085>::ID
PUBLIC	?ID@?$PixelConverter@II$0MAO@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3086>::ID
PUBLIC	?ID@?$PixelConverter@II$0MBM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3100>::ID
PUBLIC	?ID@?$PixelConverter@II$0NAM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3340>::ID
PUBLIC	?ID@?$PixelConverter@II$0NAO@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3342>::ID
PUBLIC	?ID@?$PixelConverter@II$0NBM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3356>::ID
PUBLIC	?ID@?$PixelConverter@II$0OAM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3596>::ID
PUBLIC	?ID@?$PixelConverter@II$0OAN@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3597>::ID
PUBLIC	?ID@?$PixelConverter@II$0OBM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3612>::ID
PUBLIC	?ID@?$PixelConverter@II$0BMAM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7180>::ID
PUBLIC	?ID@?$PixelConverter@II$0BMAN@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7181>::ID
PUBLIC	?ID@?$PixelConverter@II$0BMAO@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7182>::ID
PUBLIC	?ID@?$PixelConverter@IE$0NAB@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3329>::ID
PUBLIC	?ID@?$PixelConverter@EI$0BAN@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,269>::ID
PUBLIC	?ID@?$PixelConverter@IE$0MAB@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3073>::ID
PUBLIC	?ID@?$PixelConverter@EI$0BAM@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,268>::ID
PUBLIC	?ID@?$PixelConverter@IE$0OAB@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3585>::ID
PUBLIC	?ID@?$PixelConverter@EI$0BAO@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,270>::ID
PUBLIC	?ID@?$PixelConverter@EG$0BAC@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned char,unsigned short,258>::ID
PUBLIC	?ID@?$PixelConverter@GE$0CAB@@?A0xbce8a349@@2HB	; `anonymous namespace'::PixelConverter<unsigned short,unsigned char,513>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0KAL@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,A0xbce8a349::Col3b,2571>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0LAK@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,A0xbce8a349::Col3b,2826>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2572>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2828>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAN@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2573>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAN@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2829>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAO@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2574>::ID
PUBLIC	?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAO@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2830>::ID
PUBLIC	?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAL@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,`anonymous namespace'::Col3b,3083>::ID
PUBLIC	?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAK@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,`anonymous namespace'::Col3b,3082>::ID
PUBLIC	?ID@?$PixelConverter@II$0BKAM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6668>::ID
PUBLIC	?ID@?$PixelConverter@II$0BKAN@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6669>::ID
PUBLIC	?ID@?$PixelConverter@II$0BKAO@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6670>::ID
PUBLIC	?ID@?$PixelConverter@II$0BKBM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6684>::ID
PUBLIC	?ID@?$PixelConverter@II$0BLAM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6924>::ID
PUBLIC	?ID@?$PixelConverter@II$0BLAN@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6925>::ID
PUBLIC	?ID@?$PixelConverter@II$0BLAO@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6926>::ID
PUBLIC	?ID@?$PixelConverter@II$0BLBM@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6940>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::ID
PUBLIC	?ID@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::ID
PUBLIC	?ID@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::ID
PUBLIC	?_pixelFormats@Ogre@@3PAUPixelFormatDescription@1@A ; Ogre::_pixelFormats
;	COMDAT ?ID@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01b1cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01b0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01b0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01b0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01a1cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01a0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01a0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01a0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c0aH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c0bH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0b0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0a0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0b0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0a0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0b0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0a0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0a0bH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0b0aH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0201H ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0102H ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 010eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0e01H ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 010cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c01H ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 010dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0d01H ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01c0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01c0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 01c0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0e1cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0e0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0e0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0d1cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0d0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0d0cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c1cH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c0eH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@2HB DD 0c0dH ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BLBM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BLBM@@?A0xbce8a349@@2HB DD 01b1cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6940>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BLAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BLAO@@?A0xbce8a349@@2HB DD 01b0eH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6926>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BLAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BLAN@@?A0xbce8a349@@2HB DD 01b0dH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6925>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BLAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BLAM@@?A0xbce8a349@@2HB DD 01b0cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6924>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BKBM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BKBM@@?A0xbce8a349@@2HB DD 01a1cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6684>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BKAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BKAO@@?A0xbce8a349@@2HB DD 01a0eH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6670>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BKAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BKAN@@?A0xbce8a349@@2HB DD 01a0dH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6669>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BKAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BKAM@@?A0xbce8a349@@2HB DD 01a0cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,6668>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAK@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAK@@?A0xbce8a349@@2HB DD 0c0aH ; `anonymous namespace'::PixelConverter<unsigned int,`anonymous namespace'::Col3b,3082>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAL@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@IUCol3b@?A0xbce8a349@@$0MAL@@?A0xbce8a349@@2HB DD 0c0bH ; `anonymous namespace'::PixelConverter<unsigned int,`anonymous namespace'::Col3b,3083>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAO@@?A0xbce8a349@@2HB DD 0b0eH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2830>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAO@@?A0xbce8a349@@2HB DD 0a0eH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2574>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAN@@?A0xbce8a349@@2HB DD 0b0dH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2829>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAN@@?A0xbce8a349@@2HB DD 0a0dH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2573>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0LAM@@?A0xbce8a349@@2HB DD 0b0cH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2828>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@I$0KAM@@?A0xbce8a349@@2HB DD 0a0cH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,unsigned int,2572>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0LAK@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0LAK@@?A0xbce8a349@@2HB DD 0b0aH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,A0xbce8a349::Col3b,2826>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0KAL@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@UCol3b@?A0xbce8a349@@U12@$0KAL@@?A0xbce8a349@@2HB DD 0a0bH ; `anonymous namespace'::PixelConverter<`anonymous namespace'::Col3b,A0xbce8a349::Col3b,2571>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@GE$0CAB@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@GE$0CAB@@?A0xbce8a349@@2HB DD 0201H ; `anonymous namespace'::PixelConverter<unsigned short,unsigned char,513>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@EG$0BAC@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@EG$0BAC@@?A0xbce8a349@@2HB DD 0102H ; `anonymous namespace'::PixelConverter<unsigned char,unsigned short,258>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@EI$0BAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@EI$0BAO@@?A0xbce8a349@@2HB DD 010eH ; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,270>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@IE$0OAB@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@IE$0OAB@@?A0xbce8a349@@2HB DD 0e01H ; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3585>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@EI$0BAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@EI$0BAM@@?A0xbce8a349@@2HB DD 010cH ; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,268>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@IE$0MAB@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@IE$0MAB@@?A0xbce8a349@@2HB DD 0c01H ; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3073>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@EI$0BAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@EI$0BAN@@?A0xbce8a349@@2HB DD 010dH ; `anonymous namespace'::PixelConverter<unsigned char,unsigned int,269>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@IE$0NAB@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@IE$0NAB@@?A0xbce8a349@@2HB DD 0d01H ; `anonymous namespace'::PixelConverter<unsigned int,unsigned char,3329>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BMAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BMAO@@?A0xbce8a349@@2HB DD 01c0eH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7182>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BMAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BMAN@@?A0xbce8a349@@2HB DD 01c0dH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7181>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0BMAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0BMAM@@?A0xbce8a349@@2HB DD 01c0cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,7180>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0OBM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0OBM@@?A0xbce8a349@@2HB DD 0e1cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3612>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0OAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0OAN@@?A0xbce8a349@@2HB DD 0e0dH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3597>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0OAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0OAM@@?A0xbce8a349@@2HB DD 0e0cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3596>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0NBM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0NBM@@?A0xbce8a349@@2HB DD 0d1cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3356>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0NAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0NAO@@?A0xbce8a349@@2HB DD 0d0eH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3342>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0NAM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0NAM@@?A0xbce8a349@@2HB DD 0d0cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3340>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0MBM@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0MBM@@?A0xbce8a349@@2HB DD 0c1cH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3100>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0MAO@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0MAO@@?A0xbce8a349@@2HB DD 0c0eH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3086>::ID
CONST	ENDS
;	COMDAT ?ID@?$PixelConverter@II$0MAN@@?A0xbce8a349@@2HB
CONST	SEGMENT
?ID@?$PixelConverter@II$0MAN@@?A0xbce8a349@@2HB DD 0c0dH ; `anonymous namespace'::PixelConverter<unsigned int,unsigned int,3085>::ID
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
	ORG $+4
?_pixelFormats@Ogre@@3PAUPixelFormatDescription@1@A DD FLAT:$SG61351 ; Ogre::_pixelFormats
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61352
	DB	01H
	ORG $+3
	DD	030H
	DD	00H
	DB	01H
	DB	08H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	0ffH
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61353
	DB	02H
	ORG $+3
	DD	030H
	DD	01H
	DB	01H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	0ffffH
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61354
	DB	01H
	ORG $+3
	DD	011H
	DD	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	08H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61355
	DB	01H
	ORG $+3
	DD	031H
	DD	00H
	DB	02H
	DB	04H
	DB	00H
	DB	00H
	DB	04H
	ORG $+3
	DD	0fH
	DD	00H
	DD	00H
	DD	0f0H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	DD	FLAT:$SG61356
	DB	02H
	ORG $+3
	DD	021H
	DD	00H
	DB	02H
	DB	08H
	DB	00H
	DB	00H
	DB	08H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61357
	DB	02H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	05H
	DB	06H
	DB	05H
	DB	00H
	ORG $+3
	DD	0f800H
	DD	07e0H
	DD	01fH
	DD	00H
	DB	0bH
	DB	05H
	DB	00H
	DB	00H
	DD	FLAT:$SG61358
	DB	02H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	05H
	DB	06H
	DB	05H
	DB	00H
	ORG $+3
	DD	01fH
	DD	07e0H
	DD	0f800H
	DD	00H
	DB	00H
	DB	05H
	DB	0bH
	DB	00H
	DD	FLAT:$SG61359
	DB	02H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	ORG $+3
	DD	0f00H
	DD	0f0H
	DD	0fH
	DD	0f000H
	DB	08H
	DB	04H
	DB	00H
	DB	0cH
	DD	FLAT:$SG61360
	DB	02H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	01H
	ORG $+3
	DD	07c00H
	DD	03e0H
	DD	01fH
	DD	08000H
	DB	0aH
	DB	05H
	DB	00H
	DB	0fH
	DD	FLAT:$SG61361
	DB	03H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	08H
	DB	08H
	DB	08H
	DB	00H
	ORG $+3
	DD	0ff0000H
	DD	0ff00H
	DD	0ffH
	DD	00H
	DB	010H
	DB	08H
	DB	00H
	DB	00H
	DD	FLAT:$SG61362
	DB	03H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	08H
	DB	08H
	DB	08H
	DB	00H
	ORG $+3
	DD	0ffH
	DD	0ff00H
	DD	0ff0000H
	DD	00H
	DB	00H
	DB	08H
	DB	010H
	DB	00H
	DD	FLAT:$SG61363
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	ORG $+3
	DD	0ff0000H
	DD	0ff00H
	DD	0ffH
	DD	0ff000000H
	DB	010H
	DB	08H
	DB	00H
	DB	018H
	DD	FLAT:$SG61364
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	ORG $+3
	DD	0ffH
	DD	0ff00H
	DD	0ff0000H
	DD	0ff000000H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DD	FLAT:$SG61365
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	ORG $+3
	DD	0ff00H
	DD	0ff0000H
	DD	0ff000000H
	DD	0ffH
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DD	FLAT:$SG61366
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	02H
	ORG $+3
	DD	03ff00000H
	DD	0ffc00H
	DD	03ffH
	DD	0c0000000H
	DB	014H
	DB	0aH
	DB	00H
	DB	01eH
	DD	FLAT:$SG61367
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	02H
	ORG $+3
	DD	03ffH
	DD	0ffc00H
	DD	03ff00000H
	DD	0c0000000H
	DB	00H
	DB	0aH
	DB	014H
	DB	01eH
	DD	FLAT:$SG61368
	DB	00H
	ORG $+3
	DD	03H
	DD	00H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61369
	DB	00H
	ORG $+3
	DD	03H
	DD	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61370
	DB	00H
	ORG $+3
	DD	03H
	DD	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61371
	DB	00H
	ORG $+3
	DD	03H
	DD	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61372
	DB	00H
	ORG $+3
	DD	03H
	DD	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61373
	DB	06H
	ORG $+3
	DD	04H
	DD	02H
	DB	03H
	DB	010H
	DB	010H
	DB	010H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61374
	DB	08H
	ORG $+3
	DD	04H
	DD	02H
	DB	04H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61375
	DB	0cH
	ORG $+3
	DD	04H
	DD	03H
	DB	03H
	DB	020H
	DB	020H
	DB	020H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61376
	DB	010H
	ORG $+3
	DD	04H
	DD	03H
	DB	04H
	DB	020H
	DB	020H
	DB	020H
	DB	020H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61377
	DB	04H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	08H
	DB	08H
	DB	08H
	DB	00H
	ORG $+3
	DD	0ff0000H
	DD	0ff00H
	DD	0ffH
	DD	0ff000000H
	DB	010H
	DB	08H
	DB	00H
	DB	018H
	DD	FLAT:$SG61378
	DB	04H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	08H
	DB	08H
	DB	08H
	DB	00H
	ORG $+3
	DD	0ffH
	DD	0ff00H
	DD	0ff0000H
	DD	0ff000000H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DD	FLAT:$SG61379
	DB	04H
	ORG $+3
	DD	011H
	DD	00H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	ORG $+3
	DD	0ff000000H
	DD	0ff0000H
	DD	0ff00H
	DD	0ffH
	DB	018H
	DB	010H
	DB	08H
	DB	00H
	DD	FLAT:$SG61380
	DB	04H
	ORG $+3
	DD	08H
	DD	03H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61381
	DB	08H
	ORG $+3
	DD	01H
	DD	01H
	DB	04H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61382
	DB	01H
	ORG $+3
	DD	010H
	DD	00H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	00H
	ORG $+3
	DD	0e0H
	DD	01cH
	DD	03H
	DD	00H
	DB	05H
	DB	02H
	DB	00H
	DB	00H
	DD	FLAT:$SG61383
	DB	02H
	ORG $+3
	DD	04H
	DD	02H
	DB	01H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61384
	DB	04H
	ORG $+3
	DD	04H
	DD	03H
	DB	01H
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61385
	DB	04H
	ORG $+3
	DD	010H
	DD	01H
	DB	02H
	DB	010H
	DB	010H
	DB	00H
	DB	00H
	ORG $+3
	DD	0ffffH
	DD	0ffff0000H
	DD	00H
	DD	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DD	FLAT:$SG61386
	DB	04H
	ORG $+3
	DD	04H
	DD	02H
	DB	02H
	DB	010H
	DB	010H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61387
	DB	08H
	ORG $+3
	DD	04H
	DD	03H
	DB	02H
	DB	020H
	DB	020H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61388
	DB	06H
	ORG $+3
	DD	00H
	DD	01H
	DB	03H
	DB	010H
	DB	010H
	DB	010H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61389
	DB	04H
	ORG $+3
	DD	08H
	DD	03H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	FLAT:$SG61390
	DB	02H
	ORG $+3
	DD	08H
	DD	02H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
$SG61351 DB	'PF_UNKNOWN', 00H
	ORG $+1
$SG61352 DB	'PF_L8', 00H
	ORG $+2
$SG61353 DB	'PF_L16', 00H
	ORG $+1
$SG61354 DB	'PF_A8', 00H
	ORG $+2
$SG61355 DB	'PF_A4L4', 00H
$SG61356 DB	'PF_BYTE_LA', 00H
	ORG $+1
$SG61357 DB	'PF_R5G6B5', 00H
	ORG $+2
$SG61358 DB	'PF_B5G6R5', 00H
	ORG $+2
$SG61359 DB	'PF_A4R4G4B4', 00H
$SG61360 DB	'PF_A1R5G5B5', 00H
$SG61361 DB	'PF_R8G8B8', 00H
	ORG $+2
$SG61362 DB	'PF_B8G8R8', 00H
	ORG $+2
$SG61363 DB	'PF_A8R8G8B8', 00H
$SG61364 DB	'PF_A8B8G8R8', 00H
$SG61365 DB	'PF_B8G8R8A8', 00H
$SG61366 DB	'PF_A2R10G10B10', 00H
	ORG $+1
$SG61367 DB	'PF_A2B10G10R10', 00H
	ORG $+1
$SG61368 DB	'PF_DXT1', 00H
$SG61369 DB	'PF_DXT2', 00H
$SG61370 DB	'PF_DXT3', 00H
$SG61371 DB	'PF_DXT4', 00H
$SG61372 DB	'PF_DXT5', 00H
$SG61373 DB	'PF_FLOAT16_RGB', 00H
	ORG $+1
$SG61374 DB	'PF_FLOAT16_RGBA', 00H
$SG61375 DB	'PF_FLOAT32_RGB', 00H
	ORG $+1
$SG61376 DB	'PF_FLOAT32_RGBA', 00H
$SG61377 DB	'PF_X8R8G8B8', 00H
$SG61378 DB	'PF_X8B8G8R8', 00H
$SG61379 DB	'PF_R8G8B8A8', 00H
$SG61380 DB	'PF_D24X8', 00H
	ORG $+3
$SG61381 DB	'PF_SHORT_RGBA', 00H
	ORG $+2
$SG61382 DB	'PF_R3G3B2', 00H
	ORG $+2
$SG61383 DB	'PF_FLOAT16_R', 00H
	ORG $+3
$SG61384 DB	'PF_FLOAT32_R', 00H
	ORG $+3
$SG61385 DB	'PF_SHORT_GR', 00H
$SG61386 DB	'PF_FLOAT16_GR', 00H
	ORG $+2
$SG61387 DB	'PF_FLOAT32_GR', 00H
	ORG $+2
$SG61388 DB	'PF_SHORT_RGB', 00H
	ORG $+3
$SG61389 DB	'PF_D24S8', 00H
	ORG $+3
$SG61390 DB	'PF_D16', 00H
	ORG $+1
$SG61412 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG61413 DB	'PixelBox::getSubVolume', 00H
	ORG $+1
$SG61414 DB	'Cannot return subvolume of compressed PixelBuffer', 00H
	ORG $+2
$SG61421 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG61422 DB	'PixelBox::getSubVolume', 00H
	ORG $+1
$SG61423 DB	'Bounds out of range', 00H
$SG61457 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG61458 DB	'PixelUtil::getMemorySize', 00H
	ORG $+3
$SG61459 DB	'Invalid compressed pixel format', 00H
$SG62764 DB	' | ', 00H
$SG62767 DB	'''', 00H
	ORG $+2
$SG62768 DB	'''', 00H
	ORG $+2
$SG62917 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG62918 DB	'PixelUtil::packColour', 00H
	ORG $+2
$SG62919 DB	' not implemented', 00H
	ORG $+3
$SG62920 DB	'pack to ', 00H
	ORG $+3
$SG63014 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG63015 DB	'PixelUtil::unpackColour', 00H
$SG63016 DB	' not implemented', 00H
	ORG $+3
$SG63017 DB	'unpack from ', 00H
	ORG $+3
$SG63041 DB	'.\OgrePixelFormat.cpp', 00H
	ORG $+2
$SG63042 DB	'PixelUtil::bulkPixelConversion', 00H
	ORG $+1
$SG63043 DB	'This method can not be used to compress or decompress im'
	DB	'ages', 00H
CONST	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@XZ			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@XZ			; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.h
;	COMDAT ??0PixelBox@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PixelBox@Ogre@@QAE@XZ PROC				; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 183  : 		PixelBox() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@XZ		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PixelBox@Ogre@@QAE@XZ ENDP				; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?setConsecutive@PixelBox@Ogre@@QAEXXZ		; Ogre::PixelBox::setConsecutive
PUBLIC	??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_extents$ = 8						; size = 4
_pixelFormat$ = 12					; size = 4
_pixelData$ = 16					; size = 4
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z PROC ; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 193  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _extents$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 194  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 195  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ENDP ; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z	; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_pixelFormat$ = 20					; size = 4
_pixelData$ = 24					; size = 4
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z PROC	; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 208  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [edx+28], eax

; 209  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 210  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ENDP	; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?getHeight@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getHeight
PUBLIC	?getWidth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
;	COMDAT ?setConsecutive@PixelBox@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setConsecutive@PixelBox@Ogre@@QAEXXZ PROC		; Ogre::PixelBox::setConsecutive, COMDAT
; _this$ = ecx

; 232  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 			rowPitch = getWidth();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 234  : 			slicePitch = getWidth()*getHeight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], esi

; 235  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?setConsecutive@PixelBox@Ogre@@QAEXXZ ENDP		; Ogre::PixelBox::setConsecutive
_TEXT	ENDS
PUBLIC	?getRowSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getRowSkip
; Function compile flags: /Odtp
;	COMDAT ?getRowSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRowSkip@PixelBox@Ogre@@QBEIXZ PROC			; Ogre::PixelBox::getRowSkip, COMDAT
; _this$ = ecx

; 240  : 		size_t getRowSkip() const { return rowPitch - getWidth(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, eax
	mov	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRowSkip@PixelBox@Ogre@@QBEIXZ ENDP			; Ogre::PixelBox::getRowSkip
_TEXT	ENDS
PUBLIC	?getSliceSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getSliceSkip
; Function compile flags: /Odtp
;	COMDAT ?getSliceSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSliceSkip@PixelBox@Ogre@@QBEIXZ PROC		; Ogre::PixelBox::getSliceSkip, COMDAT
; _this$ = ecx

; 245  : 		size_t getSliceSkip() const { return slicePitch - (getHeight() * rowPitch); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?getSliceSkip@PixelBox@Ogre@@QBEIXZ ENDP		; Ogre::PixelBox::getSliceSkip
_TEXT	ENDS
PUBLIC	?isConsecutive@PixelBox@Ogre@@QBE_NXZ		; Ogre::PixelBox::isConsecutive
; Function compile flags: /Odtp
;	COMDAT ?isConsecutive@PixelBox@Ogre@@QBE_NXZ
_TEXT	SEGMENT
tv87 = -8						; size = 4
_this$ = -4						; size = 4
?isConsecutive@PixelBox@Ogre@@QBE_NXZ PROC		; Ogre::PixelBox::isConsecutive, COMDAT
; _this$ = ecx

; 251  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 			return rowPitch == getWidth() && slicePitch == getWidth()*getHeight(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], eax
	jne	SHORT $LN3@isConsecut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], esi
	jne	SHORT $LN3@isConsecut
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN4@isConsecut
$LN3@isConsecut:
	mov	DWORD PTR tv87[ebp], 0
$LN4@isConsecut:
	mov	al, BYTE PTR tv87[ebp]

; 253  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isConsecutive@PixelBox@Ogre@@QBE_NXZ ENDP		; Ogre::PixelBox::isConsecutive
_TEXT	ENDS
PUBLIC	??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TBox<int>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TBox<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TBox<int>::operator=
_TEXT	ENDS
PUBLIC	??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelBox::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelBox::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelBox::operator=
_TEXT	ENDS
PUBLIC	??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelUtil::operator=
_TEXT	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T70045 = -8						; size = 4
$T70044 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T70045[ebp], eax
	mov	ecx, DWORD PTR $T70045[ebp]
	mov	DWORD PTR $T70044[ebp], ecx
	cmp	DWORD PTR $T70044[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T70044[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T70044[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7Archive@Ogre@@6B@				; Ogre::Archive::`vftable'
PUBLIC	??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z	; Ogre::Archive::Archive
PUBLIC	??_R4Archive@Ogre@@6B@				; Ogre::Archive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArchive@Ogre@@@8			; Ogre::Archive `RTTI Type Descriptor'
PUBLIC	??_R3Archive@Ogre@@8				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Archive@Ogre@@8				; Ogre::Archive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Archive@Ogre@@8			; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Archive@Ogre@@8
; File i:\svnroot\client\ogremain\ogrearchive.h
rdata$r	SEGMENT
??_R1A@?0A@EA@Archive@Ogre@@8 DD FLAT:??_R0?AVArchive@Ogre@@@8 ; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Archive@Ogre@@8
rdata$r	SEGMENT
??_R2Archive@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Archive@Ogre@@8 ; Ogre::Archive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Archive@Ogre@@8
rdata$r	SEGMENT
??_R3Archive@Ogre@@8 DD 00H				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArchive@Ogre@@@8
_DATA	SEGMENT
??_R0?AVArchive@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Archive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArchive@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Archive@Ogre@@6B@
rdata$r	SEGMENT
??_R4Archive@Ogre@@6B@ DD 00H				; Ogre::Archive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArchive@Ogre@@@8
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Archive@Ogre@@6B@
CONST	SEGMENT
??_7Archive@Ogre@@6B@ DD FLAT:??_R4Archive@Ogre@@6B@	; Ogre::Archive::`vftable'
	DD	FLAT:??_EArchive@Ogre@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstream$ = 8						; size = 4
_mode$ = 12						; size = 4
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z PROC		; Ogre::Archive::Archive, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pstream$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z ENDP		; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??1Archive@Ogre@@UAE@XZ				; Ogre::Archive::~Archive
; Function compile flags: /Odtp
;	COMDAT ??1Archive@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Archive@Ogre@@UAE@XZ PROC				; Ogre::Archive::~Archive, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Archive@Ogre@@UAE@XZ ENDP				; Ogre::Archive::~Archive
_TEXT	ENDS
PUBLIC	?isLoading@Archive@Ogre@@QAE_NXZ		; Ogre::Archive::isLoading
; Function compile flags: /Odtp
;	COMDAT ?isLoading@Archive@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLoading@Archive@Ogre@@QAE_NXZ PROC			; Ogre::Archive::isLoading, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Mode==MODE_LOAD;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 1
	sete	cl
	mov	al, cl

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isLoading@Archive@Ogre@@QAE_NXZ ENDP			; Ogre::Archive::isLoading
_TEXT	ENDS
PUBLIC	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z	; Ogre::Archive::serialize
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAD@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAD@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 108  : 		SERIALIZE_PRIMITIVE_FUNC(char)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAD@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAF@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAF@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 109  : 		SERIALIZE_PRIMITIVE_FUNC(short)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAF@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAH@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAH@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 110  : 		SERIALIZE_PRIMITIVE_FUNC(int)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAH@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_J@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_J@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 111  : 		SERIALIZE_PRIMITIVE_FUNC(int64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_J@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAE@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAE@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 112  : 		SERIALIZE_PRIMITIVE_FUNC(uchar)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAE@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAG@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAG@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 113  : 		SERIALIZE_PRIMITIVE_FUNC(ushort)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAG@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAI@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAI@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 114  : 		SERIALIZE_PRIMITIVE_FUNC(uint)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAI@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_K@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_K@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 115  : 		SERIALIZE_PRIMITIVE_FUNC(uint64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_K@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_N@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_N@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 116  : 		SERIALIZE_PRIMITIVE_FUNC(bool)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_N@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAM@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAM@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 117  : 		SERIALIZE_PRIMITIVE_FUNC(float)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAM@Z ENDP			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z PROC		; Ogre::Archive::serialize, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			if(isLoading()) m_pStream->read(pbuf, len);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@serialize
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN1@serialize
$LN2@serialize:

; 157  : 			else m_pStream->write(pbuf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@serialize:

; 158  : 
; 159  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ENDP		; Ogre::Archive::serialize
_TEXT	ENDS
PUBLIC	?read@Archive@Ogre@@QAEXPAXI@Z			; Ogre::Archive::read
; Function compile flags: /Odtp
;	COMDAT ?read@Archive@Ogre@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@Archive@Ogre@@QAEXPAXI@Z PROC			; Ogre::Archive::read, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			m_pStream->read(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@Archive@Ogre@@QAEXPAXI@Z ENDP			; Ogre::Archive::read
_TEXT	ENDS
PUBLIC	?write@Archive@Ogre@@QAEXPBXI@Z			; Ogre::Archive::write
; Function compile flags: /Odtp
;	COMDAT ?write@Archive@Ogre@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?write@Archive@Ogre@@QAEXPBXI@Z PROC			; Ogre::Archive::write, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 			m_pStream->write(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@Archive@Ogre@@QAEXPBXI@Z ENDP			; Ogre::Archive::write
_TEXT	ENDS
PUBLIC	??0Archive@Ogre@@QAE@ABV01@@Z			; Ogre::Archive::Archive
; Function compile flags: /Odtp
;	COMDAT ??0Archive@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Archive@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Archive::Archive, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Archive@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??4Archive@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Archive::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Archive@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Archive::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Archive::operator=
_TEXT	ENDS
PUBLIC	??_GArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1Archive@Ogre@@UAE@XZ		; Ogre::Archive::~Archive
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0ColourValue@Ogre@@QAE@MMMM@Z			; Ogre::ColourValue::ColourValue
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
;	COMDAT ??0ColourValue@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
??0ColourValue@Ogre@@QAE@MMMM@Z PROC			; Ogre::ColourValue::ColourValue, COMDAT
; _this$ = ecx

; 68   : 		{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0ColourValue@Ogre@@QAE@MMMM@Z ENDP			; Ogre::ColourValue::ColourValue
_TEXT	ENDS
PUBLIC	?set@ColourValue@Ogre@@QAEXMMMM@Z		; Ogre::ColourValue::set
; Function compile flags: /Odtp
;	COMDAT ?set@ColourValue@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
?set@ColourValue@Ogre@@QAEXMMMM@Z PROC			; Ogre::ColourValue::set, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			r	= red;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]

; 78   : 			g	= green;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]

; 79   : 			b	= blue;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]

; 80   : 			a	= alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@ColourValue@Ogre@@QAEXMMMM@Z ENDP			; Ogre::ColourValue::set
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	?saturate@ColourValue@Ogre@@QAEXXZ		; Ogre::ColourValue::saturate
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?saturate@ColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?saturate@ColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::saturate, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			if (r < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@saturate

; 119  : 				r = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx]
	jmp	SHORT $LN10@saturate
$LN12@saturate:

; 120  : 			else if (r > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@saturate

; 121  : 				r = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
$LN10@saturate:

; 122  : 
; 123  : 			if (g < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@saturate

; 124  : 				g = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $LN7@saturate
$LN9@saturate:

; 125  : 			else if (g > 1)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@saturate

; 126  : 				g = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+4]
$LN7@saturate:

; 127  : 
; 128  : 			if (b < 0)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@saturate

; 129  : 				b = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	jmp	SHORT $LN4@saturate
$LN6@saturate:

; 130  : 			else if (b > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@saturate

; 131  : 				b = 1;

	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+8]
$LN4@saturate:

; 132  : 
; 133  : 			if (a < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@saturate

; 134  : 				a = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+12]
	jmp	SHORT $LN1@saturate
$LN3@saturate:

; 135  : 			else if (a > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+12]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@saturate

; 136  : 				a = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
$LN1@saturate:

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?saturate@ColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::saturate
_TEXT	ENDS
PUBLIC	?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ	; Ogre::ColourValue::saturateCopy
; Function compile flags: /Odtp
;	COMDAT ?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_ret$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ PROC	; Ogre::ColourValue::saturateCopy, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			ColourValue ret = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ret$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ret$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _ret$[ebp+12], edx

; 144  : 			ret.saturate();

	lea	ecx, DWORD PTR _ret$[ebp]
	call	?saturate@ColourValue@Ogre@@QAEXXZ	; Ogre::ColourValue::saturate

; 145  : 			return ret;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _ret$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _ret$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _ret$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ ENDP	; Ogre::ColourValue::saturateCopy
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QBEMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QBEMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			assert( i < 4 );
; 152  : 
; 153  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+eax*4]

; 154  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QBEMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QAEAAMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QAEAAMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 158  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 			assert( i < 4 );
; 160  : 
; 161  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QAEAAMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QAEPAMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QAEPAMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 166  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QAEPAMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QBEPBMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QBEPBMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QBEPBMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator+
; Function compile flags: /Odtp
;	COMDAT ??HColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kSum$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+, COMDAT
; _this$ = ecx

; 178  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			ColourValue kSum;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kSum$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 180  : 
; 181  : 			kSum.r = r + rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _kSum$[ebp]

; 182  : 			kSum.g = g + rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _kSum$[ebp+4]

; 183  : 			kSum.b = b + rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _kSum$[ebp+8]

; 184  : 			kSum.a = a + rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kSum$[ebp+12]

; 185  : 
; 186  : 			return kSum;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kSum$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kSum$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kSum$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kSum$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+
_TEXT	ENDS
PUBLIC	??GColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator-
; Function compile flags: /Odtp
;	COMDAT ??GColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kDiff$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-, COMDAT
; _this$ = ecx

; 190  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 			ColourValue kDiff;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiff$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 192  : 
; 193  : 			kDiff.r = r - rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _kDiff$[ebp]

; 194  : 			kDiff.g = g - rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _kDiff$[ebp+4]

; 195  : 			kDiff.b = b - rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _kDiff$[ebp+8]

; 196  : 			kDiff.a = a - rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kDiff$[ebp+12]

; 197  : 
; 198  : 			return kDiff;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kDiff$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kDiff$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 202  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 204  : 
; 205  : 			kProd.r = fScalar*r;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _kProd$[ebp]

; 206  : 			kProd.g = fScalar*g;

	fld	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 207  : 			kProd.b = fScalar*b;

	fld	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 208  : 			kProd.a = fScalar*a;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 209  : 
; 210  : 			return kProd;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 214  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 216  : 
; 217  : 			kProd.r = rhs.r * r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 218  : 			kProd.g = rhs.g * g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 219  : 			kProd.b = rhs.b * b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 220  : 			kProd.a = rhs.a * a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 221  : 
; 222  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 226  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 228  : 
; 229  : 			kProd.r = rhs.r / r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 230  : 			kProd.g = rhs.g / g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 231  : 			kProd.b = rhs.b / b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 232  : 			kProd.a = rhs.a / a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 233  : 
; 234  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_kDiv$ = -20						; size = 16
_fInv$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 238  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 			assert( fScalar != 0.0f );
; 240  : 
; 241  : 			ColourValue kDiv;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiv$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 242  : 
; 243  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 244  : 			kDiv.r = r * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp]

; 245  : 			kDiv.g = g * fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+4]

; 246  : 			kDiv.b = b * fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+8]

; 247  : 			kDiv.a = a * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+12]

; 248  : 
; 249  : 			return kDiv;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kDiv$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kDiv$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kDiv$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kDiv$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??YColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+=, COMDAT
; _this$ = ecx

; 266  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 			r += rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 268  : 			g += rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 269  : 			b += rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 270  : 			a += rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 271  : 
; 272  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+=
_TEXT	ENDS
PUBLIC	??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-=, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			r -= rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 278  : 			g -= rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 279  : 			b -= rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 280  : 			a -= rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 281  : 
; 282  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 283  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-=
_TEXT	ENDS
PUBLIC	??XColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??XColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator*=, COMDAT
; _this$ = ecx

; 286  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			r *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 288  : 			g *= fScalar;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 289  : 			b *= fScalar;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 290  : 			a *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 291  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 292  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator*=
_TEXT	ENDS
PUBLIC	??_0ColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0ColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fInv$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??_0ColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator/=, COMDAT
; _this$ = ecx

; 295  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 			assert( fScalar != 0.0 );
; 297  : 
; 298  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 299  : 
; 300  : 			r *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 301  : 			g *= fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fInv$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 302  : 			b *= fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fInv$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 303  : 			a *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 304  : 
; 305  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0ColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator/=
_TEXT	ENDS
PUBLIC	??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator=
_TEXT	ENDS
PUBLIC	??_FColourValue@Ogre@@QAEXXZ			; Ogre::ColourValue::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	esp, ebp
	pop	ebp
	ret	0
??_FColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::`default constructor closure'
_TEXT	ENDS
PUBLIC	??_7Exception@Ogre@@6B@				; Ogre::Exception::`vftable'
PUBLIC	??1Exception@Ogre@@UAE@XZ			; Ogre::Exception::~Exception
PUBLIC	??_R4Exception@Ogre@@6B@			; Ogre::Exception::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVException@Ogre@@@8			; Ogre::Exception `RTTI Type Descriptor'
PUBLIC	??_R3Exception@Ogre@@8				; Ogre::Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Exception@Ogre@@8				; Ogre::Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Exception@Ogre@@8			; Ogre::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_EException@Ogre@@UAEPAXI@Z			; Ogre::Exception::`vector deleting destructor'
PUBLIC	?what@Exception@Ogre@@UBEPBDXZ			; Ogre::Exception::what
PUBLIC	?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::Exception::getSource
PUBLIC	?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::Exception::getFile
PUBLIC	?getLine@Exception@Ogre@@UBEJXZ			; Ogre::Exception::getLine
PUBLIC	?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::Exception::getDescription
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::Exception::getFullDescription
EXTRN	?getNumber@Exception@Ogre@@UBEHXZ:PROC		; Ogre::Exception::getNumber
;	COMDAT ??_R2exception@std@@8
; File i:\svnroot\client\ogremain\ogreexception.h
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Exception@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Exception@Ogre@@8 DD FLAT:??_R0?AVException@Ogre@@@8 ; Ogre::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Exception@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Exception@Ogre@@8
rdata$r	SEGMENT
??_R2Exception@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Exception@Ogre@@8 ; Ogre::Exception::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3Exception@Ogre@@8
rdata$r	SEGMENT
??_R3Exception@Ogre@@8 DD 00H				; Ogre::Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Exception@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVException@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Exception@Ogre@@6B@
rdata$r	SEGMENT
??_R4Exception@Ogre@@6B@ DD 00H				; Ogre::Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVException@Ogre@@@8
	DD	FLAT:??_R3Exception@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Exception@Ogre@@6B@
CONST	SEGMENT
??_7Exception@Ogre@@6B@ DD FLAT:??_R4Exception@Ogre@@6B@ ; Ogre::Exception::`vftable'
	DD	FLAT:??_EException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1Exception@Ogre@@UAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1Exception@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1Exception@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1Exception@Ogre@@UAE@XZ$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Exception@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Exception@Ogre@@UAE@XZ PROC				; Ogre::Exception::~Exception, COMDAT
; _this$ = ecx

; 127  : 		~Exception() throw() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Exception@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Exception@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1Exception@Ogre@@UAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1Exception@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Exception@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Exception@Ogre@@UAE@XZ ENDP				; Ogre::Exception::~Exception
; Function compile flags: /Odtp
;	COMDAT ?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::Exception::getSource, COMDAT
; _this$ = ecx

; 151  : 		virtual const String &getSource() const { return source; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	mov	esp, ebp
	pop	ebp
	ret	0
?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::Exception::getSource
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::Exception::getFile, COMDAT
; _this$ = ecx

; 155  : 		virtual const String &getFile() const { return file; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	mov	esp, ebp
	pop	ebp
	ret	0
?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::Exception::getFile
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getLine@Exception@Ogre@@UBEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLine@Exception@Ogre@@UBEJXZ PROC			; Ogre::Exception::getLine, COMDAT
; _this$ = ecx

; 159  : 		virtual long getLine() const { return line; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getLine@Exception@Ogre@@UBEJXZ ENDP			; Ogre::Exception::getLine
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::Exception::getDescription, COMDAT
; _this$ = ecx

; 165  : 		virtual const String &getDescription(void) const { return description; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H
	mov	esp, ebp
	pop	ebp
	ret	0
?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::Exception::getDescription
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@Exception@Ogre@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@Exception@Ogre@@UBEPBDXZ PROC			; Ogre::Exception::what, COMDAT
; _this$ = ecx

; 168  : 		const char* what() const throw() { return getFullDescription().c_str(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	esp, ebp
	pop	ebp
	ret	0
?what@Exception@Ogre@@UBEPBDXZ ENDP			; Ogre::Exception::what
_TEXT	ENDS
PUBLIC	??_GException@Ogre@@UAEPAXI@Z			; Ogre::Exception::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GException@Ogre@@UAEPAXI@Z PROC			; Ogre::Exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GException@Ogre@@UAEPAXI@Z ENDP			; Ogre::Exception::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EException@Ogre@@UAEPAXI@Z PROC			; Ogre::Exception::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1Exception@Ogre@@UAE@XZ	; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EException@Ogre@@UAEPAXI@Z ENDP			; Ogre::Exception::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7UnimplementedException@Ogre@@6B@		; Ogre::UnimplementedException::`vftable'
PUBLIC	??_C@_0BH@LOKECLHE@UnimplementedException?$AA@	; `string'
PUBLIC	??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::UnimplementedException::UnimplementedException
PUBLIC	??_R4UnimplementedException@Ogre@@6B@		; Ogre::UnimplementedException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVUnimplementedException@Ogre@@@8		; Ogre::UnimplementedException `RTTI Type Descriptor'
PUBLIC	??_R3UnimplementedException@Ogre@@8		; Ogre::UnimplementedException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2UnimplementedException@Ogre@@8		; Ogre::UnimplementedException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@UnimplementedException@Ogre@@8	; Ogre::UnimplementedException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EUnimplementedException@Ogre@@UAEPAXI@Z	; Ogre::UnimplementedException::`vector deleting destructor'
EXTRN	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z:PROC ; Ogre::Exception::Exception
;	COMDAT ??_R1A@?0A@EA@UnimplementedException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@UnimplementedException@Ogre@@8 DD FLAT:??_R0?AVUnimplementedException@Ogre@@@8 ; Ogre::UnimplementedException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3UnimplementedException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2UnimplementedException@Ogre@@8
rdata$r	SEGMENT
??_R2UnimplementedException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@UnimplementedException@Ogre@@8 ; Ogre::UnimplementedException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3UnimplementedException@Ogre@@8
rdata$r	SEGMENT
??_R3UnimplementedException@Ogre@@8 DD 00H		; Ogre::UnimplementedException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2UnimplementedException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVUnimplementedException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVUnimplementedException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::UnimplementedException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVUnimplementedException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4UnimplementedException@Ogre@@6B@
rdata$r	SEGMENT
??_R4UnimplementedException@Ogre@@6B@ DD 00H		; Ogre::UnimplementedException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVUnimplementedException@Ogre@@@8
	DD	FLAT:??_R3UnimplementedException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7UnimplementedException@Ogre@@6B@
CONST	SEGMENT
??_7UnimplementedException@Ogre@@6B@ DD FLAT:??_R4UnimplementedException@Ogre@@6B@ ; Ogre::UnimplementedException::`vftable'
	DD	FLAT:??_EUnimplementedException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BH@LOKECLHE@UnimplementedException?$AA@
CONST	SEGMENT
??_C@_0BH@LOKECLHE@UnimplementedException?$AA@ DB 'UnimplementedException'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::UnimplementedException::UnimplementedException, COMDAT
; _this$ = ecx

; 191  : 		UnimplementedException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@LOKECLHE@UnimplementedException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7UnimplementedException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::UnimplementedException::UnimplementedException
PUBLIC	??1UnimplementedException@Ogre@@UAE@XZ		; Ogre::UnimplementedException::~UnimplementedException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1UnimplementedException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1UnimplementedException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1UnimplementedException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1UnimplementedException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1UnimplementedException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1UnimplementedException@Ogre@@UAE@XZ PROC		; Ogre::UnimplementedException::~UnimplementedException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1UnimplementedException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1UnimplementedException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1UnimplementedException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1UnimplementedException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1UnimplementedException@Ogre@@UAE@XZ ENDP		; Ogre::UnimplementedException::~UnimplementedException
PUBLIC	??0UnimplementedException@Ogre@@QAE@ABV01@@Z	; Ogre::UnimplementedException::UnimplementedException
EXTRN	??0Exception@Ogre@@QAE@ABV01@@Z:PROC		; Ogre::Exception::Exception
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0UnimplementedException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0UnimplementedException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0UnimplementedException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0UnimplementedException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0UnimplementedException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0UnimplementedException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::UnimplementedException::UnimplementedException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0UnimplementedException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7UnimplementedException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0UnimplementedException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0UnimplementedException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0UnimplementedException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0UnimplementedException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::UnimplementedException::UnimplementedException
PUBLIC	??4UnimplementedException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::UnimplementedException::operator=
EXTRN	??4Exception@Ogre@@QAEXABV01@@Z:PROC		; Ogre::Exception::operator=
; Function compile flags: /Odtp
;	COMDAT ??4UnimplementedException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4UnimplementedException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::UnimplementedException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4UnimplementedException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::UnimplementedException::operator=
_TEXT	ENDS
PUBLIC	??_GUnimplementedException@Ogre@@UAEPAXI@Z	; Ogre::UnimplementedException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GUnimplementedException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GUnimplementedException@Ogre@@UAEPAXI@Z PROC		; Ogre::UnimplementedException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UnimplementedException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GUnimplementedException@Ogre@@UAEPAXI@Z ENDP		; Ogre::UnimplementedException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EUnimplementedException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EUnimplementedException@Ogre@@UAEPAXI@Z PROC		; Ogre::UnimplementedException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1UnimplementedException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1UnimplementedException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EUnimplementedException@Ogre@@UAEPAXI@Z ENDP		; Ogre::UnimplementedException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileNotFoundException@Ogre@@6B@		; Ogre::FileNotFoundException::`vftable'
PUBLIC	??_C@_0BG@HLJIKHGO@FileNotFoundException?$AA@	; `string'
PUBLIC	??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::FileNotFoundException::FileNotFoundException
PUBLIC	??_R4FileNotFoundException@Ogre@@6B@		; Ogre::FileNotFoundException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileNotFoundException@Ogre@@@8		; Ogre::FileNotFoundException `RTTI Type Descriptor'
PUBLIC	??_R3FileNotFoundException@Ogre@@8		; Ogre::FileNotFoundException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileNotFoundException@Ogre@@8		; Ogre::FileNotFoundException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileNotFoundException@Ogre@@8	; Ogre::FileNotFoundException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileNotFoundException@Ogre@@UAEPAXI@Z	; Ogre::FileNotFoundException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@FileNotFoundException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileNotFoundException@Ogre@@8 DD FLAT:??_R0?AVFileNotFoundException@Ogre@@@8 ; Ogre::FileNotFoundException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileNotFoundException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileNotFoundException@Ogre@@8
rdata$r	SEGMENT
??_R2FileNotFoundException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileNotFoundException@Ogre@@8 ; Ogre::FileNotFoundException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3FileNotFoundException@Ogre@@8
rdata$r	SEGMENT
??_R3FileNotFoundException@Ogre@@8 DD 00H		; Ogre::FileNotFoundException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2FileNotFoundException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileNotFoundException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileNotFoundException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileNotFoundException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileNotFoundException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileNotFoundException@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileNotFoundException@Ogre@@6B@ DD 00H		; Ogre::FileNotFoundException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileNotFoundException@Ogre@@@8
	DD	FLAT:??_R3FileNotFoundException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileNotFoundException@Ogre@@6B@
CONST	SEGMENT
??_7FileNotFoundException@Ogre@@6B@ DD FLAT:??_R4FileNotFoundException@Ogre@@6B@ ; Ogre::FileNotFoundException::`vftable'
	DD	FLAT:??_EFileNotFoundException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BG@HLJIKHGO@FileNotFoundException?$AA@
CONST	SEGMENT
??_C@_0BG@HLJIKHGO@FileNotFoundException?$AA@ DB 'FileNotFoundException', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::FileNotFoundException::FileNotFoundException, COMDAT
; _this$ = ecx

; 197  : 		FileNotFoundException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@HLJIKHGO@FileNotFoundException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7FileNotFoundException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileNotFoundException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::FileNotFoundException::FileNotFoundException
PUBLIC	??1FileNotFoundException@Ogre@@UAE@XZ		; Ogre::FileNotFoundException::~FileNotFoundException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1FileNotFoundException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FileNotFoundException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1FileNotFoundException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1FileNotFoundException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1FileNotFoundException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FileNotFoundException@Ogre@@UAE@XZ PROC		; Ogre::FileNotFoundException::~FileNotFoundException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1FileNotFoundException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FileNotFoundException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1FileNotFoundException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1FileNotFoundException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1FileNotFoundException@Ogre@@UAE@XZ ENDP		; Ogre::FileNotFoundException::~FileNotFoundException
PUBLIC	??0FileNotFoundException@Ogre@@QAE@ABV01@@Z	; Ogre::FileNotFoundException::FileNotFoundException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileNotFoundException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileNotFoundException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::FileNotFoundException::FileNotFoundException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileNotFoundException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileNotFoundException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileNotFoundException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::FileNotFoundException::FileNotFoundException
PUBLIC	??4FileNotFoundException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::FileNotFoundException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileNotFoundException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileNotFoundException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileNotFoundException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileNotFoundException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileNotFoundException::operator=
_TEXT	ENDS
PUBLIC	??_GFileNotFoundException@Ogre@@UAEPAXI@Z	; Ogre::FileNotFoundException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GFileNotFoundException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileNotFoundException@Ogre@@UAEPAXI@Z PROC		; Ogre::FileNotFoundException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileNotFoundException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileNotFoundException@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileNotFoundException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileNotFoundException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileNotFoundException@Ogre@@UAEPAXI@Z PROC		; Ogre::FileNotFoundException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1FileNotFoundException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileNotFoundException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileNotFoundException@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileNotFoundException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7IOException@Ogre@@6B@			; Ogre::IOException::`vftable'
PUBLIC	??_C@_0M@CBPJAJJI@IOException?$AA@		; `string'
PUBLIC	??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::IOException::IOException
PUBLIC	??_R4IOException@Ogre@@6B@			; Ogre::IOException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIOException@Ogre@@@8			; Ogre::IOException `RTTI Type Descriptor'
PUBLIC	??_R3IOException@Ogre@@8			; Ogre::IOException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IOException@Ogre@@8			; Ogre::IOException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IOException@Ogre@@8		; Ogre::IOException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EIOException@Ogre@@UAEPAXI@Z			; Ogre::IOException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@IOException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IOException@Ogre@@8 DD FLAT:??_R0?AVIOException@Ogre@@@8 ; Ogre::IOException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IOException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2IOException@Ogre@@8
rdata$r	SEGMENT
??_R2IOException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@IOException@Ogre@@8 ; Ogre::IOException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3IOException@Ogre@@8
rdata$r	SEGMENT
??_R3IOException@Ogre@@8 DD 00H				; Ogre::IOException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2IOException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIOException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVIOException@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::IOException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIOException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4IOException@Ogre@@6B@
rdata$r	SEGMENT
??_R4IOException@Ogre@@6B@ DD 00H			; Ogre::IOException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIOException@Ogre@@@8
	DD	FLAT:??_R3IOException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7IOException@Ogre@@6B@
CONST	SEGMENT
??_7IOException@Ogre@@6B@ DD FLAT:??_R4IOException@Ogre@@6B@ ; Ogre::IOException::`vftable'
	DD	FLAT:??_EIOException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0M@CBPJAJJI@IOException?$AA@
CONST	SEGMENT
??_C@_0M@CBPJAJJI@IOException?$AA@ DB 'IOException', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::IOException::IOException, COMDAT
; _this$ = ecx

; 203  : 		IOException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0M@CBPJAJJI@IOException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7IOException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IOException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::IOException::IOException
PUBLIC	??1IOException@Ogre@@UAE@XZ			; Ogre::IOException::~IOException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1IOException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1IOException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1IOException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1IOException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1IOException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1IOException@Ogre@@UAE@XZ PROC			; Ogre::IOException::~IOException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1IOException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1IOException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1IOException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1IOException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1IOException@Ogre@@UAE@XZ ENDP			; Ogre::IOException::~IOException
PUBLIC	??0IOException@Ogre@@QAE@ABV01@@Z		; Ogre::IOException::IOException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IOException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IOException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0IOException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IOException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IOException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0IOException@Ogre@@QAE@ABV01@@Z PROC			; Ogre::IOException::IOException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IOException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7IOException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IOException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0IOException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IOException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IOException@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::IOException::IOException
PUBLIC	??4IOException@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IOException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IOException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IOException@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IOException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IOException@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IOException::operator=
_TEXT	ENDS
PUBLIC	??_GIOException@Ogre@@UAEPAXI@Z			; Ogre::IOException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GIOException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIOException@Ogre@@UAEPAXI@Z PROC			; Ogre::IOException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IOException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIOException@Ogre@@UAEPAXI@Z ENDP			; Ogre::IOException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EIOException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EIOException@Ogre@@UAEPAXI@Z PROC			; Ogre::IOException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1IOException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IOException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EIOException@Ogre@@UAEPAXI@Z ENDP			; Ogre::IOException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7InvalidStateException@Ogre@@6B@		; Ogre::InvalidStateException::`vftable'
PUBLIC	??_C@_0BG@IEKPFFPO@InvalidStateException?$AA@	; `string'
PUBLIC	??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::InvalidStateException::InvalidStateException
PUBLIC	??_R4InvalidStateException@Ogre@@6B@		; Ogre::InvalidStateException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInvalidStateException@Ogre@@@8		; Ogre::InvalidStateException `RTTI Type Descriptor'
PUBLIC	??_R3InvalidStateException@Ogre@@8		; Ogre::InvalidStateException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidStateException@Ogre@@8		; Ogre::InvalidStateException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidStateException@Ogre@@8	; Ogre::InvalidStateException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EInvalidStateException@Ogre@@UAEPAXI@Z	; Ogre::InvalidStateException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@InvalidStateException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidStateException@Ogre@@8 DD FLAT:??_R0?AVInvalidStateException@Ogre@@@8 ; Ogre::InvalidStateException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidStateException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidStateException@Ogre@@8
rdata$r	SEGMENT
??_R2InvalidStateException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@InvalidStateException@Ogre@@8 ; Ogre::InvalidStateException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidStateException@Ogre@@8
rdata$r	SEGMENT
??_R3InvalidStateException@Ogre@@8 DD 00H		; Ogre::InvalidStateException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2InvalidStateException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInvalidStateException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVInvalidStateException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::InvalidStateException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidStateException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4InvalidStateException@Ogre@@6B@
rdata$r	SEGMENT
??_R4InvalidStateException@Ogre@@6B@ DD 00H		; Ogre::InvalidStateException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidStateException@Ogre@@@8
	DD	FLAT:??_R3InvalidStateException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7InvalidStateException@Ogre@@6B@
CONST	SEGMENT
??_7InvalidStateException@Ogre@@6B@ DD FLAT:??_R4InvalidStateException@Ogre@@6B@ ; Ogre::InvalidStateException::`vftable'
	DD	FLAT:??_EInvalidStateException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BG@IEKPFFPO@InvalidStateException?$AA@
CONST	SEGMENT
??_C@_0BG@IEKPFFPO@InvalidStateException?$AA@ DB 'InvalidStateException', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::InvalidStateException::InvalidStateException, COMDAT
; _this$ = ecx

; 209  : 		InvalidStateException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@IEKPFFPO@InvalidStateException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7InvalidStateException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InvalidStateException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::InvalidStateException::InvalidStateException
PUBLIC	??1InvalidStateException@Ogre@@UAE@XZ		; Ogre::InvalidStateException::~InvalidStateException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1InvalidStateException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1InvalidStateException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1InvalidStateException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1InvalidStateException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1InvalidStateException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1InvalidStateException@Ogre@@UAE@XZ PROC		; Ogre::InvalidStateException::~InvalidStateException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1InvalidStateException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1InvalidStateException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1InvalidStateException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1InvalidStateException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1InvalidStateException@Ogre@@UAE@XZ ENDP		; Ogre::InvalidStateException::~InvalidStateException
PUBLIC	??0InvalidStateException@Ogre@@QAE@ABV01@@Z	; Ogre::InvalidStateException::InvalidStateException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InvalidStateException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InvalidStateException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0InvalidStateException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InvalidStateException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InvalidStateException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0InvalidStateException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::InvalidStateException::InvalidStateException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InvalidStateException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidStateException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InvalidStateException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InvalidStateException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InvalidStateException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InvalidStateException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::InvalidStateException::InvalidStateException
PUBLIC	??4InvalidStateException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::InvalidStateException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4InvalidStateException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InvalidStateException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::InvalidStateException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4InvalidStateException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::InvalidStateException::operator=
_TEXT	ENDS
PUBLIC	??_GInvalidStateException@Ogre@@UAEPAXI@Z	; Ogre::InvalidStateException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidStateException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidStateException@Ogre@@UAEPAXI@Z PROC		; Ogre::InvalidStateException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidStateException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidStateException@Ogre@@UAEPAXI@Z ENDP		; Ogre::InvalidStateException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EInvalidStateException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EInvalidStateException@Ogre@@UAEPAXI@Z PROC		; Ogre::InvalidStateException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@13
	push	OFFSET ??1InvalidStateException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@13
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@13
$LN3@vector@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidStateException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@13
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@13:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EInvalidStateException@Ogre@@UAEPAXI@Z ENDP		; Ogre::InvalidStateException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7InvalidParametersException@Ogre@@6B@	; Ogre::InvalidParametersException::`vftable'
PUBLIC	??_C@_0BL@CDIKBDOO@InvalidParametersException?$AA@ ; `string'
PUBLIC	??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::InvalidParametersException::InvalidParametersException
PUBLIC	??_R4InvalidParametersException@Ogre@@6B@	; Ogre::InvalidParametersException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInvalidParametersException@Ogre@@@8	; Ogre::InvalidParametersException `RTTI Type Descriptor'
PUBLIC	??_R3InvalidParametersException@Ogre@@8		; Ogre::InvalidParametersException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidParametersException@Ogre@@8		; Ogre::InvalidParametersException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidParametersException@Ogre@@8 ; Ogre::InvalidParametersException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EInvalidParametersException@Ogre@@UAEPAXI@Z	; Ogre::InvalidParametersException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@InvalidParametersException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidParametersException@Ogre@@8 DD FLAT:??_R0?AVInvalidParametersException@Ogre@@@8 ; Ogre::InvalidParametersException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidParametersException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidParametersException@Ogre@@8
rdata$r	SEGMENT
??_R2InvalidParametersException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@InvalidParametersException@Ogre@@8 ; Ogre::InvalidParametersException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidParametersException@Ogre@@8
rdata$r	SEGMENT
??_R3InvalidParametersException@Ogre@@8 DD 00H		; Ogre::InvalidParametersException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2InvalidParametersException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInvalidParametersException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVInvalidParametersException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::InvalidParametersException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidParametersException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4InvalidParametersException@Ogre@@6B@
rdata$r	SEGMENT
??_R4InvalidParametersException@Ogre@@6B@ DD 00H	; Ogre::InvalidParametersException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidParametersException@Ogre@@@8
	DD	FLAT:??_R3InvalidParametersException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7InvalidParametersException@Ogre@@6B@
CONST	SEGMENT
??_7InvalidParametersException@Ogre@@6B@ DD FLAT:??_R4InvalidParametersException@Ogre@@6B@ ; Ogre::InvalidParametersException::`vftable'
	DD	FLAT:??_EInvalidParametersException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BL@CDIKBDOO@InvalidParametersException?$AA@
CONST	SEGMENT
??_C@_0BL@CDIKBDOO@InvalidParametersException?$AA@ DB 'InvalidParametersE'
	DB	'xception', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::InvalidParametersException::InvalidParametersException, COMDAT
; _this$ = ecx

; 215  : 		InvalidParametersException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BL@CDIKBDOO@InvalidParametersException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7InvalidParametersException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::InvalidParametersException::InvalidParametersException
PUBLIC	??1InvalidParametersException@Ogre@@UAE@XZ	; Ogre::InvalidParametersException::~InvalidParametersException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1InvalidParametersException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1InvalidParametersException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1InvalidParametersException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1InvalidParametersException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1InvalidParametersException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1InvalidParametersException@Ogre@@UAE@XZ PROC		; Ogre::InvalidParametersException::~InvalidParametersException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1InvalidParametersException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1InvalidParametersException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1InvalidParametersException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1InvalidParametersException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1InvalidParametersException@Ogre@@UAE@XZ ENDP		; Ogre::InvalidParametersException::~InvalidParametersException
PUBLIC	??0InvalidParametersException@Ogre@@QAE@ABV01@@Z ; Ogre::InvalidParametersException::InvalidParametersException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InvalidParametersException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0InvalidParametersException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::InvalidParametersException::InvalidParametersException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InvalidParametersException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InvalidParametersException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InvalidParametersException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::InvalidParametersException::InvalidParametersException
PUBLIC	??4InvalidParametersException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::InvalidParametersException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4InvalidParametersException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InvalidParametersException@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::InvalidParametersException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4InvalidParametersException@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::InvalidParametersException::operator=
_TEXT	ENDS
PUBLIC	??_GInvalidParametersException@Ogre@@UAEPAXI@Z	; Ogre::InvalidParametersException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GInvalidParametersException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidParametersException@Ogre@@UAEPAXI@Z PROC	; Ogre::InvalidParametersException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidParametersException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInvalidParametersException@Ogre@@UAEPAXI@Z ENDP	; Ogre::InvalidParametersException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EInvalidParametersException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EInvalidParametersException@Ogre@@UAEPAXI@Z PROC	; Ogre::InvalidParametersException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@14
	push	OFFSET ??1InvalidParametersException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@14
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@14
$LN3@vector@14:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InvalidParametersException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@14
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EInvalidParametersException@Ogre@@UAEPAXI@Z ENDP	; Ogre::InvalidParametersException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ItemIdentityException@Ogre@@6B@		; Ogre::ItemIdentityException::`vftable'
PUBLIC	??_C@_0BG@GKPHAEHJ@ItemIdentityException?$AA@	; `string'
PUBLIC	??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::ItemIdentityException::ItemIdentityException
PUBLIC	??_R4ItemIdentityException@Ogre@@6B@		; Ogre::ItemIdentityException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVItemIdentityException@Ogre@@@8		; Ogre::ItemIdentityException `RTTI Type Descriptor'
PUBLIC	??_R3ItemIdentityException@Ogre@@8		; Ogre::ItemIdentityException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ItemIdentityException@Ogre@@8		; Ogre::ItemIdentityException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ItemIdentityException@Ogre@@8	; Ogre::ItemIdentityException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EItemIdentityException@Ogre@@UAEPAXI@Z	; Ogre::ItemIdentityException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ItemIdentityException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ItemIdentityException@Ogre@@8 DD FLAT:??_R0?AVItemIdentityException@Ogre@@@8 ; Ogre::ItemIdentityException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ItemIdentityException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ItemIdentityException@Ogre@@8
rdata$r	SEGMENT
??_R2ItemIdentityException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ItemIdentityException@Ogre@@8 ; Ogre::ItemIdentityException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ItemIdentityException@Ogre@@8
rdata$r	SEGMENT
??_R3ItemIdentityException@Ogre@@8 DD 00H		; Ogre::ItemIdentityException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ItemIdentityException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVItemIdentityException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVItemIdentityException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ItemIdentityException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVItemIdentityException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ItemIdentityException@Ogre@@6B@
rdata$r	SEGMENT
??_R4ItemIdentityException@Ogre@@6B@ DD 00H		; Ogre::ItemIdentityException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVItemIdentityException@Ogre@@@8
	DD	FLAT:??_R3ItemIdentityException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ItemIdentityException@Ogre@@6B@
CONST	SEGMENT
??_7ItemIdentityException@Ogre@@6B@ DD FLAT:??_R4ItemIdentityException@Ogre@@6B@ ; Ogre::ItemIdentityException::`vftable'
	DD	FLAT:??_EItemIdentityException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BG@GKPHAEHJ@ItemIdentityException?$AA@
CONST	SEGMENT
??_C@_0BG@GKPHAEHJ@ItemIdentityException?$AA@ DB 'ItemIdentityException', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::ItemIdentityException::ItemIdentityException, COMDAT
; _this$ = ecx

; 221  : 		ItemIdentityException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@GKPHAEHJ@ItemIdentityException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7ItemIdentityException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ItemIdentityException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::ItemIdentityException::ItemIdentityException
PUBLIC	??1ItemIdentityException@Ogre@@UAE@XZ		; Ogre::ItemIdentityException::~ItemIdentityException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ItemIdentityException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ItemIdentityException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1ItemIdentityException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ItemIdentityException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1ItemIdentityException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ItemIdentityException@Ogre@@UAE@XZ PROC		; Ogre::ItemIdentityException::~ItemIdentityException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ItemIdentityException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1ItemIdentityException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1ItemIdentityException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ItemIdentityException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ItemIdentityException@Ogre@@UAE@XZ ENDP		; Ogre::ItemIdentityException::~ItemIdentityException
PUBLIC	??0ItemIdentityException@Ogre@@QAE@ABV01@@Z	; Ogre::ItemIdentityException::ItemIdentityException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ItemIdentityException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ItemIdentityException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::ItemIdentityException::ItemIdentityException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ItemIdentityException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ItemIdentityException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ItemIdentityException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::ItemIdentityException::ItemIdentityException
PUBLIC	??4ItemIdentityException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::ItemIdentityException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ItemIdentityException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ItemIdentityException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ItemIdentityException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ItemIdentityException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ItemIdentityException::operator=
_TEXT	ENDS
PUBLIC	??_GItemIdentityException@Ogre@@UAEPAXI@Z	; Ogre::ItemIdentityException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GItemIdentityException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GItemIdentityException@Ogre@@UAEPAXI@Z PROC		; Ogre::ItemIdentityException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ItemIdentityException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GItemIdentityException@Ogre@@UAEPAXI@Z ENDP		; Ogre::ItemIdentityException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EItemIdentityException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EItemIdentityException@Ogre@@UAEPAXI@Z PROC		; Ogre::ItemIdentityException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@15
	push	OFFSET ??1ItemIdentityException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@15
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@15
$LN3@vector@15:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ItemIdentityException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EItemIdentityException@Ogre@@UAEPAXI@Z ENDP		; Ogre::ItemIdentityException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7InternalErrorException@Ogre@@6B@		; Ogre::InternalErrorException::`vftable'
PUBLIC	??_C@_0BH@KFMOHEEH@InternalErrorException?$AA@	; `string'
PUBLIC	??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::InternalErrorException::InternalErrorException
PUBLIC	??_R4InternalErrorException@Ogre@@6B@		; Ogre::InternalErrorException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVInternalErrorException@Ogre@@@8		; Ogre::InternalErrorException `RTTI Type Descriptor'
PUBLIC	??_R3InternalErrorException@Ogre@@8		; Ogre::InternalErrorException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InternalErrorException@Ogre@@8		; Ogre::InternalErrorException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InternalErrorException@Ogre@@8	; Ogre::InternalErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EInternalErrorException@Ogre@@UAEPAXI@Z	; Ogre::InternalErrorException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@InternalErrorException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InternalErrorException@Ogre@@8 DD FLAT:??_R0?AVInternalErrorException@Ogre@@@8 ; Ogre::InternalErrorException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InternalErrorException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2InternalErrorException@Ogre@@8
rdata$r	SEGMENT
??_R2InternalErrorException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@InternalErrorException@Ogre@@8 ; Ogre::InternalErrorException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InternalErrorException@Ogre@@8
rdata$r	SEGMENT
??_R3InternalErrorException@Ogre@@8 DD 00H		; Ogre::InternalErrorException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2InternalErrorException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVInternalErrorException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVInternalErrorException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::InternalErrorException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInternalErrorException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4InternalErrorException@Ogre@@6B@
rdata$r	SEGMENT
??_R4InternalErrorException@Ogre@@6B@ DD 00H		; Ogre::InternalErrorException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInternalErrorException@Ogre@@@8
	DD	FLAT:??_R3InternalErrorException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7InternalErrorException@Ogre@@6B@
CONST	SEGMENT
??_7InternalErrorException@Ogre@@6B@ DD FLAT:??_R4InternalErrorException@Ogre@@6B@ ; Ogre::InternalErrorException::`vftable'
	DD	FLAT:??_EInternalErrorException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BH@KFMOHEEH@InternalErrorException?$AA@
CONST	SEGMENT
??_C@_0BH@KFMOHEEH@InternalErrorException?$AA@ DB 'InternalErrorException'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::InternalErrorException::InternalErrorException, COMDAT
; _this$ = ecx

; 227  : 		InternalErrorException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@KFMOHEEH@InternalErrorException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7InternalErrorException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InternalErrorException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::InternalErrorException::InternalErrorException
PUBLIC	??1InternalErrorException@Ogre@@UAE@XZ		; Ogre::InternalErrorException::~InternalErrorException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1InternalErrorException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1InternalErrorException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1InternalErrorException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1InternalErrorException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1InternalErrorException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1InternalErrorException@Ogre@@UAE@XZ PROC		; Ogre::InternalErrorException::~InternalErrorException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1InternalErrorException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1InternalErrorException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1InternalErrorException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1InternalErrorException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1InternalErrorException@Ogre@@UAE@XZ ENDP		; Ogre::InternalErrorException::~InternalErrorException
PUBLIC	??0InternalErrorException@Ogre@@QAE@ABV01@@Z	; Ogre::InternalErrorException::InternalErrorException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InternalErrorException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InternalErrorException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0InternalErrorException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InternalErrorException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0InternalErrorException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0InternalErrorException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::InternalErrorException::InternalErrorException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0InternalErrorException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7InternalErrorException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InternalErrorException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0InternalErrorException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0InternalErrorException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0InternalErrorException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::InternalErrorException::InternalErrorException
PUBLIC	??4InternalErrorException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::InternalErrorException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4InternalErrorException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4InternalErrorException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::InternalErrorException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4InternalErrorException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::InternalErrorException::operator=
_TEXT	ENDS
PUBLIC	??_GInternalErrorException@Ogre@@UAEPAXI@Z	; Ogre::InternalErrorException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GInternalErrorException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInternalErrorException@Ogre@@UAEPAXI@Z PROC		; Ogre::InternalErrorException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InternalErrorException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GInternalErrorException@Ogre@@UAEPAXI@Z ENDP		; Ogre::InternalErrorException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EInternalErrorException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EInternalErrorException@Ogre@@UAEPAXI@Z PROC		; Ogre::InternalErrorException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@16
	push	OFFSET ??1InternalErrorException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@16
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@16
$LN3@vector@16:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1InternalErrorException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EInternalErrorException@Ogre@@UAEPAXI@Z ENDP		; Ogre::InternalErrorException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7RenderingAPIException@Ogre@@6B@		; Ogre::RenderingAPIException::`vftable'
PUBLIC	??_C@_0BG@ONDPEEJM@RenderingAPIException?$AA@	; `string'
PUBLIC	??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::RenderingAPIException::RenderingAPIException
PUBLIC	??_R4RenderingAPIException@Ogre@@6B@		; Ogre::RenderingAPIException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRenderingAPIException@Ogre@@@8		; Ogre::RenderingAPIException `RTTI Type Descriptor'
PUBLIC	??_R3RenderingAPIException@Ogre@@8		; Ogre::RenderingAPIException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RenderingAPIException@Ogre@@8		; Ogre::RenderingAPIException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RenderingAPIException@Ogre@@8	; Ogre::RenderingAPIException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERenderingAPIException@Ogre@@UAEPAXI@Z	; Ogre::RenderingAPIException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@RenderingAPIException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderingAPIException@Ogre@@8 DD FLAT:??_R0?AVRenderingAPIException@Ogre@@@8 ; Ogre::RenderingAPIException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderingAPIException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderingAPIException@Ogre@@8
rdata$r	SEGMENT
??_R2RenderingAPIException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RenderingAPIException@Ogre@@8 ; Ogre::RenderingAPIException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderingAPIException@Ogre@@8
rdata$r	SEGMENT
??_R3RenderingAPIException@Ogre@@8 DD 00H		; Ogre::RenderingAPIException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2RenderingAPIException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderingAPIException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRenderingAPIException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RenderingAPIException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderingAPIException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RenderingAPIException@Ogre@@6B@
rdata$r	SEGMENT
??_R4RenderingAPIException@Ogre@@6B@ DD 00H		; Ogre::RenderingAPIException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRenderingAPIException@Ogre@@@8
	DD	FLAT:??_R3RenderingAPIException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RenderingAPIException@Ogre@@6B@
CONST	SEGMENT
??_7RenderingAPIException@Ogre@@6B@ DD FLAT:??_R4RenderingAPIException@Ogre@@6B@ ; Ogre::RenderingAPIException::`vftable'
	DD	FLAT:??_ERenderingAPIException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BG@ONDPEEJM@RenderingAPIException?$AA@
CONST	SEGMENT
??_C@_0BG@ONDPEEJM@RenderingAPIException?$AA@ DB 'RenderingAPIException', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::RenderingAPIException::RenderingAPIException, COMDAT
; _this$ = ecx

; 233  : 		RenderingAPIException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@ONDPEEJM@RenderingAPIException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7RenderingAPIException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderingAPIException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::RenderingAPIException::RenderingAPIException
PUBLIC	??1RenderingAPIException@Ogre@@UAE@XZ		; Ogre::RenderingAPIException::~RenderingAPIException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RenderingAPIException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RenderingAPIException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1RenderingAPIException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RenderingAPIException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1RenderingAPIException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RenderingAPIException@Ogre@@UAE@XZ PROC		; Ogre::RenderingAPIException::~RenderingAPIException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RenderingAPIException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RenderingAPIException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1RenderingAPIException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RenderingAPIException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RenderingAPIException@Ogre@@UAE@XZ ENDP		; Ogre::RenderingAPIException::~RenderingAPIException
PUBLIC	??0RenderingAPIException@Ogre@@QAE@ABV01@@Z	; Ogre::RenderingAPIException::RenderingAPIException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderingAPIException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RenderingAPIException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::RenderingAPIException::RenderingAPIException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RenderingAPIException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderingAPIException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderingAPIException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::RenderingAPIException::RenderingAPIException
PUBLIC	??4RenderingAPIException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::RenderingAPIException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RenderingAPIException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RenderingAPIException@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::RenderingAPIException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RenderingAPIException@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::RenderingAPIException::operator=
_TEXT	ENDS
PUBLIC	??_GRenderingAPIException@Ogre@@UAEPAXI@Z	; Ogre::RenderingAPIException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GRenderingAPIException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRenderingAPIException@Ogre@@UAEPAXI@Z PROC		; Ogre::RenderingAPIException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderingAPIException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRenderingAPIException@Ogre@@UAEPAXI@Z ENDP		; Ogre::RenderingAPIException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERenderingAPIException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERenderingAPIException@Ogre@@UAEPAXI@Z PROC		; Ogre::RenderingAPIException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@17
	push	OFFSET ??1RenderingAPIException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@17
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@17
$LN3@vector@17:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderingAPIException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@17:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERenderingAPIException@Ogre@@UAEPAXI@Z ENDP		; Ogre::RenderingAPIException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7RuntimeAssertionException@Ogre@@6B@		; Ogre::RuntimeAssertionException::`vftable'
PUBLIC	??_C@_0BK@LFIEAKED@RuntimeAssertionException?$AA@ ; `string'
PUBLIC	??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::RuntimeAssertionException::RuntimeAssertionException
PUBLIC	??_R4RuntimeAssertionException@Ogre@@6B@	; Ogre::RuntimeAssertionException::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRuntimeAssertionException@Ogre@@@8	; Ogre::RuntimeAssertionException `RTTI Type Descriptor'
PUBLIC	??_R3RuntimeAssertionException@Ogre@@8		; Ogre::RuntimeAssertionException::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RuntimeAssertionException@Ogre@@8		; Ogre::RuntimeAssertionException::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RuntimeAssertionException@Ogre@@8	; Ogre::RuntimeAssertionException::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERuntimeAssertionException@Ogre@@UAEPAXI@Z	; Ogre::RuntimeAssertionException::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@RuntimeAssertionException@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RuntimeAssertionException@Ogre@@8 DD FLAT:??_R0?AVRuntimeAssertionException@Ogre@@@8 ; Ogre::RuntimeAssertionException::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RuntimeAssertionException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RuntimeAssertionException@Ogre@@8
rdata$r	SEGMENT
??_R2RuntimeAssertionException@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RuntimeAssertionException@Ogre@@8 ; Ogre::RuntimeAssertionException::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3RuntimeAssertionException@Ogre@@8
rdata$r	SEGMENT
??_R3RuntimeAssertionException@Ogre@@8 DD 00H		; Ogre::RuntimeAssertionException::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2RuntimeAssertionException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRuntimeAssertionException@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRuntimeAssertionException@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RuntimeAssertionException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRuntimeAssertionException@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RuntimeAssertionException@Ogre@@6B@
rdata$r	SEGMENT
??_R4RuntimeAssertionException@Ogre@@6B@ DD 00H		; Ogre::RuntimeAssertionException::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRuntimeAssertionException@Ogre@@@8
	DD	FLAT:??_R3RuntimeAssertionException@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RuntimeAssertionException@Ogre@@6B@
CONST	SEGMENT
??_7RuntimeAssertionException@Ogre@@6B@ DD FLAT:??_R4RuntimeAssertionException@Ogre@@6B@ ; Ogre::RuntimeAssertionException::`vftable'
	DD	FLAT:??_ERuntimeAssertionException@Ogre@@UAEPAXI@Z
	DD	FLAT:?what@Exception@Ogre@@UBEPBDXZ
	DD	FLAT:?getFullDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getNumber@Exception@Ogre@@UBEHXZ
	DD	FLAT:?getSource@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getFile@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?getLine@Exception@Ogre@@UBEJXZ
	DD	FLAT:?getDescription@Exception@Ogre@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
CONST	ENDS
;	COMDAT ??_C@_0BK@LFIEAKED@RuntimeAssertionException?$AA@
CONST	SEGMENT
??_C@_0BK@LFIEAKED@RuntimeAssertionException?$AA@ DB 'RuntimeAssertionExc'
	DB	'eption', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0
__ehfuncinfo$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_number$ = 8						; size = 4
_description$ = 12					; size = 4
_source$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z PROC ; Ogre::RuntimeAssertionException::RuntimeAssertionException, COMDAT
; _this$ = ecx

; 239  : 		RuntimeAssertionException(int number, const String& description, const String& source, const char* file, long line)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BK@LFIEAKED@RuntimeAssertionException?$AA@
	mov	edx, DWORD PTR _source$[ebp]
	push	edx
	mov	eax, DWORD PTR _description$[ebp]
	push	eax
	mov	ecx, DWORD PTR _number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBD1J@Z ; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7RuntimeAssertionException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RuntimeAssertionException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ENDP ; Ogre::RuntimeAssertionException::RuntimeAssertionException
PUBLIC	??1RuntimeAssertionException@Ogre@@UAE@XZ	; Ogre::RuntimeAssertionException::~RuntimeAssertionException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RuntimeAssertionException@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RuntimeAssertionException@Ogre@@UAE@XZ$0
__ehfuncinfo$??1RuntimeAssertionException@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RuntimeAssertionException@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1RuntimeAssertionException@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RuntimeAssertionException@Ogre@@UAE@XZ PROC		; Ogre::RuntimeAssertionException::~RuntimeAssertionException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RuntimeAssertionException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RuntimeAssertionException@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??1RuntimeAssertionException@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RuntimeAssertionException@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RuntimeAssertionException@Ogre@@UAE@XZ ENDP		; Ogre::RuntimeAssertionException::~RuntimeAssertionException
PUBLIC	??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z	; Ogre::RuntimeAssertionException::RuntimeAssertionException
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z PROC	; Ogre::RuntimeAssertionException::RuntimeAssertionException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Exception@Ogre@@QAE@ABV01@@Z		; Ogre::Exception::Exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RuntimeAssertionException@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Exception@Ogre@@UAE@XZ		; Ogre::Exception::~Exception
__ehhandler$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RuntimeAssertionException@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::RuntimeAssertionException::RuntimeAssertionException
PUBLIC	??4RuntimeAssertionException@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::RuntimeAssertionException::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeAssertionException@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeAssertionException@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::RuntimeAssertionException::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Exception@Ogre@@QAEXABV01@@Z		; Ogre::Exception::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeAssertionException@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::RuntimeAssertionException::operator=
_TEXT	ENDS
PUBLIC	??_GRuntimeAssertionException@Ogre@@UAEPAXI@Z	; Ogre::RuntimeAssertionException::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GRuntimeAssertionException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRuntimeAssertionException@Ogre@@UAEPAXI@Z PROC	; Ogre::RuntimeAssertionException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RuntimeAssertionException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRuntimeAssertionException@Ogre@@UAEPAXI@Z ENDP	; Ogre::RuntimeAssertionException::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERuntimeAssertionException@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERuntimeAssertionException@Ogre@@UAEPAXI@Z PROC	; Ogre::RuntimeAssertionException::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@18
	push	OFFSET ??1RuntimeAssertionException@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	160					; 000000a0H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@18
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@18
$LN3@vector@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RuntimeAssertionException@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERuntimeAssertionException@Ogre@@UAEPAXI@Z ENDP	; Ogre::RuntimeAssertionException::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::StringUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::StringUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::StringUtil::operator=
_TEXT	ENDS
PUBLIC	?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getMemorySize
PUBLIC	?getDepth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getDepth
PUBLIC	?getConsecutiveSize@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getConsecutiveSize
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getConsecutiveSize@PixelBox@Ogre@@QBEIXZ PROC		; Ogre::PixelBox::getConsecutiveSize
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		return PixelUtil::getMemorySize(getWidth(), getHeight(), getDepth(), format);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getDepth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getDepth
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	push	eax
	call	?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getMemorySize
	add	esp, 16					; 00000010H

; 613  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getConsecutiveSize@PixelBox@Ogre@@QBEIXZ ENDP		; Ogre::PixelBox::getConsecutiveSize
_TEXT	ENDS
PUBLIC	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
PUBLIC	?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z		; Ogre::TBox<int>::contains
PUBLIC	__TI3?AVInvalidParametersException@Ogre@@
PUBLIC	?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
PUBLIC	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
PUBLIC	?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z ; Ogre::PixelBox::getSubVolume
PUBLIC	__CTA3?AVInvalidParametersException@Ogre@@
PUBLIC	__CT??_R0?AVInvalidParametersException@Ogre@@@8??0InvalidParametersException@Ogre@@QAE@ABV01@@Z160
PUBLIC	__CT??_R0?AVException@Ogre@@@8??0Exception@Ogre@@QAE@ABV01@@Z160
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVException@Ogre@@@8??0Exception@Ogre@@QAE@ABV01@@Z160
xdata$x	SEGMENT
__CT??_R0?AVException@Ogre@@@8??0Exception@Ogre@@QAE@ABV01@@Z160 DD 00H
	DD	FLAT:??_R0?AVException@Ogre@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0a0H
	DD	FLAT:??0Exception@Ogre@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVInvalidParametersException@Ogre@@@8??0InvalidParametersException@Ogre@@QAE@ABV01@@Z160
xdata$x	SEGMENT
__CT??_R0?AVInvalidParametersException@Ogre@@@8??0InvalidParametersException@Ogre@@QAE@ABV01@@Z160 DD 00H
	DD	FLAT:??_R0?AVInvalidParametersException@Ogre@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0a0H
	DD	FLAT:??0InvalidParametersException@Ogre@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVInvalidParametersException@Ogre@@
xdata$x	SEGMENT
__CTA3?AVInvalidParametersException@Ogre@@ DD 03H
	DD	FLAT:__CT??_R0?AVInvalidParametersException@Ogre@@@8??0InvalidParametersException@Ogre@@QAE@ABV01@@Z160
	DD	FLAT:__CT??_R0?AVException@Ogre@@@8??0Exception@Ogre@@QAE@ABV01@@Z160
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVInvalidParametersException@Ogre@@
xdata$x	SEGMENT
__TI3?AVInvalidParametersException@Ogre@@ DD 00H
	DD	FLAT:??1InvalidParametersException@Ogre@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVInvalidParametersException@Ogre@@
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$3
__ehfuncinfo$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -500						; size = 4
$T70485 = -496						; size = 160
$T70484 = -333						; size = 1
$T70483 = -332						; size = 28
$T70482 = -304						; size = 28
$T70480 = -276						; size = 160
$T70479 = -113						; size = 1
$T70478 = -112						; size = 28
$T70477 = -84						; size = 28
_elemSize$ = -56					; size = 4
_rval$ = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_def$ = 12						; size = 4
?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z PROC ; Ogre::PixelBox::getSubVolume
; _this$ = ecx

; 615  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 488				; 000001e8H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		if(PixelUtil::isCompressed(format))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	$LN3@getSubVolu

; 617  : 		{
; 618  : 			if(def.m_Left == m_Left && def.m_Top == m_Top && def.m_Front == m_Front &&
; 619  : 				def.m_Right == m_Right && def.m_Bottom == m_Bottom && def.m_Back == m_Back)

	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@getSubVolu
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN2@getSubVolu
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@getSubVolu
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN2@getSubVolu
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN2@getSubVolu
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN2@getSubVolu

; 620  : 			{
; 621  : 				// Entire buffer is being queried
; 622  : 				return *this;

	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@getSubVolu
$LN2@getSubVolu:

; 623  : 			}
; 624  : 			OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume");

	push	OFFSET $SG61413
	lea	ecx, DWORD PTR $T70477[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET $SG61414
	lea	ecx, DWORD PTR $T70478[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	xor	eax, eax
	mov	BYTE PTR $T70479[ebp], al
	push	624					; 00000270H
	push	OFFSET $SG61412
	lea	ecx, DWORD PTR $T70477[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70478[ebp]
	push	edx
	movzx	eax, BYTE PTR $T70479[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70480[ebp]
	push	ecx
	call	?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVInvalidParametersException@Ogre@@
	lea	edx, DWORD PTR $T70480[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70478[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70477[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@getSubVolu:

; 625  : 		}
; 626  : 		if(!contains(def))

	mov	eax, DWORD PTR _def$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z	; Ogre::TBox<int>::contains
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN1@getSubVolu

; 627  : 			OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Bounds out of range", "PixelBox::getSubVolume");

	push	OFFSET $SG61422
	lea	ecx, DWORD PTR $T70482[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	OFFSET $SG61423
	lea	ecx, DWORD PTR $T70483[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	xor	edx, edx
	mov	BYTE PTR $T70484[ebp], dl
	push	627					; 00000273H
	push	OFFSET $SG61421
	lea	eax, DWORD PTR $T70482[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70483[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T70484[ebp]
	push	edx
	lea	eax, DWORD PTR $T70485[ebp]
	push	eax
	call	?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVInvalidParametersException@Ogre@@
	lea	ecx, DWORD PTR $T70485[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T70483[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70482[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@getSubVolu:

; 628  : 
; 629  : 		const size_t elemSize = PixelUtil::getNumElemBytes(format);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	mov	DWORD PTR _elemSize$[ebp], eax

; 630  : 		// Calculate new data origin
; 631  : 		PixelBox rval(def, format, ((uint8*)data)
; 632  : 			+ ((def.m_Left-m_Left)*elemSize)
; 633  : 			+ ((def.m_Top-m_Top)*rowPitch*elemSize)
; 634  : 			+ ((def.m_Front-m_Front)*slicePitch*elemSize)
; 635  : 			);

	mov	ecx, DWORD PTR _def$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	imul	eax, DWORD PTR _elemSize$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, eax
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+32]
	imul	eax, DWORD PTR _elemSize$[ebp]
	add	edx, eax
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+36]
	imul	eax, DWORD PTR _elemSize$[ebp]
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _def$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _rval$[ebp]
	call	??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox

; 636  : 
; 637  : 		rval.rowPitch = rowPitch;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _rval$[ebp+32], eax

; 638  : 		rval.slicePitch = slicePitch;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR _rval$[ebp+36], edx

; 639  : 		rval.format = format;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR _rval$[ebp+28], ecx

; 640  : 
; 641  : 		return rval;

	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _rval$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@getSubVolu:

; 642  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$0:
	lea	ecx, DWORD PTR $T70477[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$1:
	lea	ecx, DWORD PTR $T70478[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$2:
	lea	ecx, DWORD PTR $T70482[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z$3:
	lea	ecx, DWORD PTR $T70483[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-500]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getSubVolume@PixelBox@Ogre@@QBE?AV12@ABV?$TBox@H@2@@Z ENDP ; Ogre::PixelBox::getSubVolume
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogreexception.h
xdata$x	SEGMENT
__unwindtable$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z$0
__ehfuncinfo$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
_TEXT	SEGMENT
$T70496 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_code$ = 12						; size = 1
_desc$ = 16						; size = 4
_src$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z PROC ; Ogre::ExceptionFactory::create, COMDAT

; 291  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T70496[ebp], 0

; 292  : 			return InvalidParametersException(code.number, desc, src, file, line);

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0InvalidParametersException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::InvalidParametersException::InvalidParametersException
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T70496[ebp]
	or	ecx, 1
	mov	DWORD PTR $T70496[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 293  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z$0:
	mov	eax, DWORD PTR $T70496[ebp]
	and	eax, 1
	je	$LN4@create
	and	DWORD PTR $T70496[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1InvalidParametersException@Ogre@@UAE@XZ
$LN4@create:
	ret	0
__ehhandler$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ENDP ; Ogre::ExceptionFactory::create
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getNumElemBytes

; 657  : 	{

	push	ebp
	mov	ebp, esp

; 658  : 		return getDescriptionFor(format).elemBytes;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	movzx	eax, BYTE PTR [eax+4]

; 659  : 	}

	pop	ebp
	ret	0
?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getNumElemBytes
; Function compile flags: /Odtp
_ord$ = -4						; size = 4
_fmt$ = 8						; size = 4
?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z PROC ; Ogre::getDescriptionFor

; 649  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 650  : 		const int ord = (int)fmt;

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR _ord$[ebp], eax

; 651  : 		assert(ord>=0 && ord<PF_COUNT);
; 652  : 
; 653  : 		return _pixelFormats[ord];

	mov	eax, DWORD PTR _ord$[ebp]
	imul	eax, 44					; 0000002cH
	add	eax, OFFSET ?_pixelFormats@Ogre@@3PAUPixelFormatDescription@1@A ; Ogre::_pixelFormats

; 654  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ENDP ; Ogre::getDescriptionFor
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z$1
__ehfuncinfo$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv68 = -236						; size = 4
$T70511 = -232						; size = 160
$T70510 = -69						; size = 1
$T70509 = -68						; size = 28
$T70508 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_format$ = 20						; size = 4
?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getMemorySize

; 662  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 663  : 		if(isCompressed(format))

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@getMemoryS

; 664  : 		{
; 665  : 			switch(format)

	mov	edx, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 17			; 00000011H
	je	SHORT $LN4@getMemoryS
	cmp	DWORD PTR tv68[ebp], 17			; 00000011H
	jle	SHORT $LN2@getMemoryS
	cmp	DWORD PTR tv68[ebp], 21			; 00000015H
	jle	SHORT $LN3@getMemoryS
	jmp	SHORT $LN2@getMemoryS
$LN4@getMemoryS:

; 666  : 			{
; 667  : 				// DXT formats work by dividing the image into 4x4 blocks, then encoding each
; 668  : 				// 4x4 block with a certain number of bytes. DXT can only be used on 2D images.
; 669  : 			case PF_DXT1:
; 670  : 				assert(depth == 1);
; 671  : 				return ((width+3)/4)*((height+3)/4)*8;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	shr	eax, 2
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, 3
	shr	ecx, 2
	imul	eax, ecx
	shl	eax, 3
	jmp	$LN9@getMemoryS
$LN3@getMemoryS:

; 672  : 			case PF_DXT2:
; 673  : 			case PF_DXT3:
; 674  : 			case PF_DXT4:
; 675  : 			case PF_DXT5:
; 676  : 				assert(depth == 1);
; 677  : 				return ((width+3)/4)*((height+3)/4)*16;

	mov	eax, DWORD PTR _width$[ebp]
	add	eax, 3
	shr	eax, 2
	mov	edx, DWORD PTR _height$[ebp]
	add	edx, 3
	shr	edx, 2
	imul	eax, edx
	shl	eax, 4
	jmp	$LN9@getMemoryS
$LN2@getMemoryS:

; 678  : 			default:
; 679  : 				OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "Invalid compressed pixel format",
; 680  : 					"PixelUtil::getMemorySize");

	push	OFFSET $SG61458
	lea	ecx, DWORD PTR $T70508[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET $SG61459
	lea	ecx, DWORD PTR $T70509[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	xor	eax, eax
	mov	BYTE PTR $T70510[ebp], al
	push	680					; 000002a8H
	push	OFFSET $SG61457
	lea	ecx, DWORD PTR $T70508[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70509[ebp]
	push	edx
	movzx	eax, BYTE PTR $T70510[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70511[ebp]
	push	ecx
	call	?create@ExceptionFactory@Ogre@@SA?AVInvalidParametersException@2@U?$ExceptionCodeType@$01@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVInvalidParametersException@Ogre@@
	lea	edx, DWORD PTR $T70511[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70509[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70508[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 681  : 			}
; 682  : 		}
; 683  : 		else

	jmp	SHORT $LN9@getMemoryS
$LN7@getMemoryS:

; 684  : 		{
; 685  : 			return width*height*depth*getNumElemBytes(format);

	mov	esi, DWORD PTR _width$[ebp]
	imul	esi, DWORD PTR _height$[ebp]
	imul	esi, DWORD PTR _depth$[ebp]
	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	imul	eax, esi
$LN9@getMemoryS:

; 686  : 		}
; 687  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z$0:
	lea	ecx, DWORD PTR $T70508[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z$1:
	lea	ecx, DWORD PTR $T70509[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getMemorySize@PixelUtil@Ogre@@SAIIIIW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getMemorySize
PUBLIC	?getNumElemBits@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBits
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?getNumElemBits@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getNumElemBits

; 690  : 	{

	push	ebp
	mov	ebp, esp

; 691  : 		return getDescriptionFor(format).elemBytes * 8;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	movzx	eax, BYTE PTR [eax+4]
	shl	eax, 3

; 692  : 	}

	pop	ebp
	ret	0
?getNumElemBits@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getNumElemBits
_TEXT	ENDS
PUBLIC	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z	; Ogre::PixelUtil::getFlags
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z PROC	; Ogre::PixelUtil::getFlags

; 695  : 	{

	push	ebp
	mov	ebp, esp

; 696  : 		return getDescriptionFor(format).flags;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	eax, DWORD PTR [eax+8]

; 697  : 	}

	pop	ebp
	ret	0
?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ENDP	; Ogre::PixelUtil::getFlags
_TEXT	ENDS
PUBLIC	?hasAlpha@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::hasAlpha
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?hasAlpha@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC	; Ogre::PixelUtil::hasAlpha

; 700  : 	{

	push	ebp
	mov	ebp, esp

; 701  : 		return (PixelUtil::getFlags(format) & PFF_HASALPHA) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 1
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 702  : 	}

	pop	ebp
	ret	0
?hasAlpha@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP	; Ogre::PixelUtil::hasAlpha
_TEXT	ENDS
PUBLIC	?isFloatingPoint@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isFloatingPoint
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?isFloatingPoint@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isFloatingPoint

; 705  : 	{

	push	ebp
	mov	ebp, esp

; 706  : 		return (PixelUtil::getFlags(format) & PFF_FLOAT) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 4
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 707  : 	}

	pop	ebp
	ret	0
?isFloatingPoint@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isFloatingPoint
; Function compile flags: /Odtp
_format$ = 8						; size = 4
?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isCompressed

; 710  : 	{

	push	ebp
	mov	ebp, esp

; 711  : 		return (PixelUtil::getFlags(format) & PFF_COMPRESSED) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 2
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 712  : 	}

	pop	ebp
	ret	0
?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isCompressed
_TEXT	ENDS
PUBLIC	?isDepth@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z	; Ogre::PixelUtil::isDepth
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?isDepth@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC	; Ogre::PixelUtil::isDepth

; 715  : 	{

	push	ebp
	mov	ebp, esp

; 716  : 		return (PixelUtil::getFlags(format) & PFF_DEPTH) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 8
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 717  : 	}

	pop	ebp
	ret	0
?isDepth@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP	; Ogre::PixelUtil::isDepth
_TEXT	ENDS
PUBLIC	?isNativeEndian@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isNativeEndian
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?isNativeEndian@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isNativeEndian

; 720  : 	{

	push	ebp
	mov	ebp, esp

; 721  : 		return (PixelUtil::getFlags(format) & PFF_NATIVEENDIAN) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 16					; 00000010H
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 722  : 	}

	pop	ebp
	ret	0
?isNativeEndian@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isNativeEndian
_TEXT	ENDS
PUBLIC	?isLuminance@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isLuminance
; Function compile flags: /Odtp
_TEXT	SEGMENT
_format$ = 8						; size = 4
?isLuminance@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isLuminance

; 725  : 	{

	push	ebp
	mov	ebp, esp

; 726  : 		return (PixelUtil::getFlags(format) & PFF_LUMINANCE) > 0;

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 727  : 	}

	pop	ebp
	ret	0
?isLuminance@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isLuminance
_TEXT	ENDS
PUBLIC	?isValidExtent@PixelUtil@Ogre@@SA_NIIIW4PixelFormat@2@@Z ; Ogre::PixelUtil::isValidExtent
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv74 = -8						; size = 4
tv68 = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_format$ = 20						; size = 4
?isValidExtent@PixelUtil@Ogre@@SA_NIIIW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isValidExtent

; 730  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 731  : 		if(isCompressed(format))

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@isValidExt

; 732  : 		{
; 733  : 			switch(format)

	mov	edx, DWORD PTR _format$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 17			; 00000011H
	jl	SHORT $LN2@isValidExt
	cmp	DWORD PTR tv68[ebp], 21			; 00000015H
	jle	SHORT $LN3@isValidExt
	jmp	SHORT $LN2@isValidExt
$LN3@isValidExt:

; 734  : 			{
; 735  : 			case PF_DXT1:
; 736  : 			case PF_DXT2:
; 737  : 			case PF_DXT3:
; 738  : 			case PF_DXT4:
; 739  : 			case PF_DXT5:
; 740  : 				return ((width&3)==0 && (height&3)==0 && depth==1);

	mov	eax, DWORD PTR _width$[ebp]
	and	eax, 3
	jne	SHORT $LN9@isValidExt
	mov	ecx, DWORD PTR _height$[ebp]
	and	ecx, 3
	jne	SHORT $LN9@isValidExt
	cmp	DWORD PTR _depth$[ebp], 1
	jne	SHORT $LN9@isValidExt
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN10@isValidExt
$LN9@isValidExt:
	mov	DWORD PTR tv74[ebp], 0
$LN10@isValidExt:
	mov	al, BYTE PTR tv74[ebp]
	jmp	SHORT $LN7@isValidExt
$LN2@isValidExt:

; 741  : 			default:
; 742  : 				return true;

	mov	al, 1
	jmp	SHORT $LN7@isValidExt

; 743  : 			}
; 744  : 		}
; 745  : 		else

	jmp	SHORT $LN7@isValidExt
$LN6@isValidExt:

; 746  : 		{
; 747  : 			return true;

	mov	al, 1
$LN7@isValidExt:

; 748  : 		}
; 749  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isValidExtent@PixelUtil@Ogre@@SA_NIIIW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isValidExtent
_TEXT	ENDS
PUBLIC	?getBitDepths@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAH@Z ; Ogre::PixelUtil::getBitDepths
; Function compile flags: /Odtp
_TEXT	SEGMENT
_des$ = -4						; size = 4
_format$ = 8						; size = 4
_rgba$ = 12						; size = 4
?getBitDepths@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAH@Z PROC ; Ogre::PixelUtil::getBitDepths

; 752  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 753  : 		const PixelFormatDescription &des = getDescriptionFor(format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 754  : 		rgba[0] = des.rbits;

	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+17]
	mov	eax, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax], edx

; 755  : 		rgba[1] = des.gbits;

	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	mov	eax, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax+4], edx

; 756  : 		rgba[2] = des.bbits;

	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+19]
	mov	eax, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax+8], edx

; 757  : 		rgba[3] = des.abits;

	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	mov	eax, DWORD PTR _rgba$[ebp]
	mov	DWORD PTR [eax+12], edx

; 758  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBitDepths@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAH@Z ENDP ; Ogre::PixelUtil::getBitDepths
_TEXT	ENDS
PUBLIC	?getBitMasks@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAI@Z ; Ogre::PixelUtil::getBitMasks
; Function compile flags: /Odtp
_TEXT	SEGMENT
_des$ = -4						; size = 4
_format$ = 8						; size = 4
_rgba$ = 12						; size = 4
?getBitMasks@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAI@Z PROC ; Ogre::PixelUtil::getBitMasks

; 761  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 762  : 		const PixelFormatDescription &des = getDescriptionFor(format);

	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 763  : 		rgba[0] = des.rmask;

	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx], eax

; 764  : 		rgba[1] = des.gmask;

	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+4], eax

; 765  : 		rgba[2] = des.bmask;

	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+8], eax

; 766  : 		rgba[3] = des.amask;

	mov	ecx, DWORD PTR _rgba$[ebp]
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+12], eax

; 767  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBitMasks@PixelUtil@Ogre@@SAXW4PixelFormat@2@QAI@Z ENDP ; Ogre::PixelUtil::getBitMasks
_TEXT	ENDS
PUBLIC	?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getFormatName
xdata$x	SEGMENT
__unwindtable$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z$0
__ehfuncinfo$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
$T70533 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_srcformat$ = 12					; size = 4
?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getFormatName

; 770  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T70533[ebp], 0

; 771  : 		return getDescriptionFor(srcformat).name;

	mov	eax, DWORD PTR _srcformat$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T70533[ebp]
	or	edx, 1
	mov	DWORD PTR $T70533[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 772  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z$0:
	mov	eax, DWORD PTR $T70533[ebp]
	and	eax, 1
	je	$LN4@getFormatN
	and	DWORD PTR $T70533[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@getFormatN:
	ret	0
__ehhandler$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getFormatName
PUBLIC	?isAccessible@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isAccessible
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv71 = -8						; size = 4
_flags$ = -4						; size = 4
_srcformat$ = 8						; size = 4
?isAccessible@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::isAccessible

; 775  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 776  : 		if (srcformat == PF_UNKNOWN)

	cmp	DWORD PTR _srcformat$[ebp], 0
	jne	SHORT $LN1@isAccessib

; 777  : 			return false;

	xor	al, al
	jmp	SHORT $LN2@isAccessib
$LN1@isAccessib:

; 778  : 		unsigned int flags = getFlags(srcformat);

	mov	eax, DWORD PTR _srcformat$[ebp]
	push	eax
	call	?getFlags@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getFlags
	add	esp, 4
	mov	DWORD PTR _flags$[ebp], eax

; 779  : 		return !((flags & PFF_COMPRESSED) || (flags & PFF_DEPTH));

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2
	jne	SHORT $LN4@isAccessib
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 8
	jne	SHORT $LN4@isAccessib
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN5@isAccessib
$LN4@isAccessib:
	mov	DWORD PTR tv71[ebp], 0
$LN5@isAccessib:
	mov	al, BYTE PTR tv71[ebp]
$LN2@isAccessib:

; 780  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isAccessible@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::isAccessible
_TEXT	ENDS
PUBLIC	?getComponentType@PixelUtil@Ogre@@SA?AW4PixelComponentType@2@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getComponentType
; Function compile flags: /Odtp
_TEXT	SEGMENT
_des$ = -4						; size = 4
_fmt$ = 8						; size = 4
?getComponentType@PixelUtil@Ogre@@SA?AW4PixelComponentType@2@W4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getComponentType

; 783  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 784  : 		const PixelFormatDescription &des = getDescriptionFor(fmt);

	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 785  : 		return des.componentType;

	mov	ecx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [ecx+12]

; 786  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getComponentType@PixelUtil@Ogre@@SA?AW4PixelComponentType@2@W4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getComponentType
_TEXT	ENDS
PUBLIC	?getComponentCount@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getComponentCount
; Function compile flags: /Odtp
_TEXT	SEGMENT
_des$ = -4						; size = 4
_fmt$ = 8						; size = 4
?getComponentCount@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z PROC ; Ogre::PixelUtil::getComponentCount

; 789  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 790  : 		const PixelFormatDescription &des = getDescriptionFor(fmt);

	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 791  : 		return des.componentCount;

	mov	ecx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [ecx+16]

; 792  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getComponentCount@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ENDP ; Ogre::PixelUtil::getComponentCount
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ; Ogre::PixelUtil::getFormatFromName
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z:PROC
EXTRN	?toUpperCase@StringUtil@Ogre@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::StringUtil::toUpperCase
xdata$x	SEGMENT
__unwindtable$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$1
__ehfuncinfo$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv91 = -100						; size = 4
tv65 = -96						; size = 4
$T70549 = -92						; size = 4
$T70548 = -88						; size = 4
$T70547 = -84						; size = 28
$T70546 = -53						; size = 1
_pf$61537 = -52						; size = 4
_i$61533 = -48						; size = 4
_tmp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_accessibleOnly$ = 12					; size = 1
_caseSensitive$ = 16					; size = 1
?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z PROC ; Ogre::PixelUtil::getFormatFromName

; 795  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 796  : 		String tmp = name;

	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 797  : 		if (!caseSensitive)

	movzx	ecx, BYTE PTR _caseSensitive$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@getFormatF

; 798  : 		{
; 799  : 			// We are stored upper-case format names.
; 800  : 			StringUtil::toUpperCase(tmp);

	lea	edx, DWORD PTR _tmp$[ebp]
	push	edx
	call	?toUpperCase@StringUtil@Ogre@@SAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::StringUtil::toUpperCase
	add	esp, 4
$LN7@getFormatF:

; 801  : 		}
; 802  : 
; 803  : 		for (int i = 0; i < PF_COUNT; ++i)

	mov	DWORD PTR _i$61533[ebp], 0
	jmp	SHORT $LN6@getFormatF
$LN5@getFormatF:
	mov	eax, DWORD PTR _i$61533[ebp]
	add	eax, 1
	mov	DWORD PTR _i$61533[ebp], eax
$LN6@getFormatF:
	cmp	DWORD PTR _i$61533[ebp], 40		; 00000028H
	jge	$LN4@getFormatF

; 804  : 		{
; 805  : 			PixelFormat pf = static_cast<PixelFormat>(i);

	mov	ecx, DWORD PTR _i$61533[ebp]
	mov	DWORD PTR _pf$61537[ebp], ecx

; 806  : 			if (!accessibleOnly || isAccessible(pf))

	movzx	edx, BYTE PTR _accessibleOnly$[ebp]
	test	edx, edx
	je	SHORT $LN2@getFormatF
	mov	eax, DWORD PTR _pf$61537[ebp]
	push	eax
	call	?isAccessible@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isAccessible
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@getFormatF
$LN2@getFormatF:

; 807  : 			{
; 808  : 				if (tmp == getFormatName(pf))

	mov	edx, DWORD PTR _pf$61537[ebp]
	push	edx
	lea	eax, DWORD PTR $T70547[ebp]
	push	eax
	call	?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getFormatName
	add	esp, 8
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv91[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv91[ebp]
	push	edx
	lea	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
	add	esp, 8
	mov	BYTE PTR $T70546[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70547[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	movzx	ecx, BYTE PTR $T70546[ebp]
	test	ecx, ecx
	je	SHORT $LN3@getFormatF

; 809  : 					return pf;

	mov	edx, DWORD PTR _pf$61537[ebp]
	mov	DWORD PTR $T70548[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T70548[ebp]
	jmp	SHORT $LN8@getFormatF
$LN3@getFormatF:

; 810  : 			}
; 811  : 		}

	jmp	$LN5@getFormatF
$LN4@getFormatF:

; 812  : 		return PF_UNKNOWN;

	mov	DWORD PTR $T70549[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T70549[ebp]
$LN8@getFormatF:

; 813  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$0:
	lea	ecx, DWORD PTR _tmp$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z$1:
	lea	ecx, DWORD PTR $T70547[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormatFromName@PixelUtil@Ogre@@SA?AW4PixelFormat@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N1@Z ENDP ; Ogre::PixelUtil::getFormatFromName
PUBLIC	??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??C?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEPAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator->
PUBLIC	??$?9Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ; std::operator!=<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
PUBLIC	?rend@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rend
PUBLIC	??E?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEAAV01@XZ ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::operator++
PUBLIC	?rbegin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rbegin
PUBLIC	??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?insert@?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::insert
PUBLIC	??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::make_pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	__$ArrayPad$
PUBLIC	?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Ogre::PixelUtil::getBNFExpressionOfPixelFormats
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ:PROC
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
xdata$x	SEGMENT
__ehfuncinfo$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4
	DD	01H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$6
	DD	07H
	DD	FLAT:__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$7
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv204 = -296						; size = 4
tv82 = -292						; size = 4
tv202 = -288						; size = 4
tv140 = -284						; size = 4
tv198 = -280						; size = 4
tv196 = -276						; size = 4
tv195 = -272						; size = 4
tv75 = -268						; size = 4
$T70574 = -264						; size = 4
$T70564 = -260						; size = 28
$T70563 = -232						; size = 28
$T70562 = -204						; size = 8
$T70561 = -196						; size = 8
$T70560 = -188						; size = 32
$T70559 = -156						; size = 4
$T70558 = -152						; size = 32
_j$62724 = -120						; size = 8
_formatName$62318 = -112				; size = 28
_pf$62314 = -84						; size = 4
_i$62310 = -80						; size = 4
_result$ = -76						; size = 28
__$ArrayPad$ = -48					; size = 4
_formatNames$ = -44					; size = 32
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_accessibleOnly$ = 12					; size = 1
?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Ogre::PixelUtil::getBNFExpressionOfPixelFormats

; 816  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T70574[ebp], 0

; 817  : 		// Collect format names sorted by length, it's required by BNF compiler
; 818  : 		// that similar tokens need longer ones comes first.
; 819  : 		typedef std::multimap<String::size_type, String> FormatNameMap;
; 820  : 		FormatNameMap formatNames;

	lea	ecx, DWORD PTR _formatNames$[ebp]
	call	??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 821  : 		for (size_t i = 0; i < PF_COUNT; ++i)

	mov	DWORD PTR _i$62310[ebp], 0
	jmp	SHORT $LN9@getBNFExpr
$LN8@getBNFExpr:
	mov	eax, DWORD PTR _i$62310[ebp]
	add	eax, 1
	mov	DWORD PTR _i$62310[ebp], eax
$LN9@getBNFExpr:
	cmp	DWORD PTR _i$62310[ebp], 40		; 00000028H
	jae	$LN7@getBNFExpr

; 822  : 		{
; 823  : 			PixelFormat pf = static_cast<PixelFormat>(i);

	mov	ecx, DWORD PTR _i$62310[ebp]
	mov	DWORD PTR _pf$62314[ebp], ecx

; 824  : 			if (!accessibleOnly || isAccessible(pf))

	movzx	edx, BYTE PTR _accessibleOnly$[ebp]
	test	edx, edx
	je	SHORT $LN5@getBNFExpr
	mov	eax, DWORD PTR _pf$62314[ebp]
	push	eax
	call	?isAccessible@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isAccessible
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@getBNFExpr
$LN5@getBNFExpr:

; 825  : 			{
; 826  : 				String formatName = getFormatName(pf);

	mov	edx, DWORD PTR _pf$62314[ebp]
	push	edx
	lea	eax, DWORD PTR _formatName$62318[ebp]
	push	eax
	call	?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getFormatName
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 827  : 				formatNames.insert(std::make_pair(formatName.length(), formatName));

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T70559[ebp], esp
	lea	edx, DWORD PTR _formatName$62318[ebp]
	push	edx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv75[ebp], eax
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv195[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _formatName$62318[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	push	eax
	lea	ecx, DWORD PTR $T70560[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::make_pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 36					; 00000024H
	mov	DWORD PTR tv196[ebp], eax
	mov	edx, DWORD PTR tv196[ebp]
	mov	DWORD PTR tv198[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv198[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70558[ebp]
	call	??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T70558[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70561[ebp]
	push	edx
	lea	ecx, DWORD PTR _formatNames$[ebp]
	call	?insert@?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::insert
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T70558[ebp]
	call	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T70560[ebp]
	call	??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ

; 828  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _formatName$62318[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@getBNFExpr:

; 829  : 		}

	jmp	$LN8@getBNFExpr
$LN7@getBNFExpr:

; 830  : 
; 831  : 		// Populate the BNF expression in reverse order
; 832  : 		String result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 833  : 		// Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
; 834  : 		for (FormatNameMap::reverse_iterator j = formatNames.rbegin(); j != formatNames.rend(); ++j)

	lea	eax, DWORD PTR _j$62724[ebp]
	push	eax
	lea	ecx, DWORD PTR _formatNames$[ebp]
	call	?rbegin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rbegin
	jmp	SHORT $LN4@getBNFExpr
$LN3@getBNFExpr:
	lea	ecx, DWORD PTR _j$62724[ebp]
	call	??E?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEAAV01@XZ ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::operator++
$LN4@getBNFExpr:
	lea	ecx, DWORD PTR $T70562[ebp]
	push	ecx
	lea	ecx, DWORD PTR _formatNames$[ebp]
	call	?rend@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rend
	push	eax
	lea	edx, DWORD PTR _j$62724[ebp]
	push	edx
	call	??$?9Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ; std::operator!=<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN2@getBNFExpr

; 835  : 		{
; 836  : 			if (!result.empty())

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@getBNFExpr

; 837  : 				result += " | ";

	push	OFFSET $SG62764
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@getBNFExpr:

; 838  : 			result += "'" + j->second + "'";

	push	OFFSET $SG62767
	lea	ecx, DWORD PTR _j$62724[ebp]
	call	??C?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEPAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator->
	add	eax, 4
	push	eax
	push	OFFSET $SG62768
	lea	edx, DWORD PTR $T70563[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv140[ebp], eax
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv202[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv202[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70564[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv82[ebp], eax
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv204[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR tv204[ebp]
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T70564[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T70563[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 839  : 		}

	jmp	$LN3@getBNFExpr
$LN2@getBNFExpr:

; 840  : 
; 841  : 		return result;

	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T70574[ebp]
	or	eax, 1
	mov	DWORD PTR $T70574[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _formatNames$[ebp]
	call	??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 842  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0:
	lea	ecx, DWORD PTR _formatNames$[ebp]
	jmp	??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$1:
	lea	ecx, DWORD PTR _formatName$62318[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$2:
	mov	ecx, DWORD PTR $T70559[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$3:
	lea	ecx, DWORD PTR $T70560[ebp]
	jmp	??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$4:
	lea	ecx, DWORD PTR $T70558[ebp]
	jmp	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$5:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$6:
	lea	ecx, DWORD PTR $T70563[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$7:
	lea	ecx, DWORD PTR $T70564[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$8:
	mov	eax, DWORD PTR $T70574[ebp]
	and	eax, 1
	je	$LN21@getBNFExpr
	and	DWORD PTR $T70574[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN21@getBNFExpr:
	ret	0
__ehhandler$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getBNFExpressionOfPixelFormats@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Ogre::PixelUtil::getBNFExpressionOfPixelFormats
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
__ehhandler$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?getFormatForBitDepths@PixelUtil@Ogre@@SA?AW4PixelFormat@2@W432@GG@Z ; Ogre::PixelUtil::getFormatForBitDepths
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv80 = -24						; size = 4
tv76 = -20						; size = 4
tv75 = -16						; size = 4
tv69 = -12						; size = 4
tv66 = -8						; size = 4
tv65 = -4						; size = 4
_fmt$ = 8						; size = 4
_integerBits$ = 12					; size = 2
_floatBits$ = 16					; size = 2
?getFormatForBitDepths@PixelUtil@Ogre@@SA?AW4PixelFormat@2@W432@GG@Z PROC ; Ogre::PixelUtil::getFormatForBitDepths

; 845  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 846  : 		switch (integerBits)

	movzx	eax, WORD PTR _integerBits$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	je	SHORT $LN34@getFormatF@2
	cmp	DWORD PTR tv65[ebp], 32			; 00000020H
	je	SHORT $LN26@getFormatF@2
	jmp	$LN35@getFormatF@2
$LN34@getFormatF@2:

; 847  : 		{
; 848  : 		case 16:
; 849  : 			switch (fmt)

	mov	ecx, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	sub	edx, 10					; 0000000aH
	mov	DWORD PTR tv66[ebp], edx
	cmp	DWORD PTR tv66[ebp], 18			; 00000012H
	ja	SHORT $LN32@getFormatF@2
	mov	eax, DWORD PTR tv66[ebp]
	movzx	ecx, BYTE PTR $LN39@getFormatF@2[eax]
	jmp	DWORD PTR $LN40@getFormatF@2[ecx*4]
$LN31@getFormatF@2:

; 850  : 			{
; 851  : 			case PF_R8G8B8:
; 852  : 			case PF_X8R8G8B8:
; 853  : 				return PF_R5G6B5;

	mov	eax, 6
	jmp	$LN37@getFormatF@2
$LN30@getFormatF@2:

; 854  : 
; 855  : 			case PF_B8G8R8:
; 856  : 			case PF_X8B8G8R8:
; 857  : 				return PF_B5G6R5;

	mov	eax, 7
	jmp	$LN37@getFormatF@2
$LN29@getFormatF@2:

; 858  : 
; 859  : 			case PF_A8R8G8B8:
; 860  : 			case PF_R8G8B8A8:
; 861  : 			case PF_A8B8G8R8:
; 862  : 			case PF_B8G8R8A8:
; 863  : 				return PF_A4R4G4B4;

	mov	eax, 8
	jmp	$LN37@getFormatF@2
$LN28@getFormatF@2:

; 864  : 
; 865  : 			case PF_A2R10G10B10:
; 866  : 			case PF_A2B10G10R10:
; 867  : 				return PF_A1R5G5B5;

	mov	eax, 9
	jmp	$LN37@getFormatF@2
$LN32@getFormatF@2:

; 868  : 
; 869  : 			default:
; 870  : 				// use original image format
; 871  : 				break;
; 872  : 			}
; 873  : 			break;

	jmp	SHORT $LN35@getFormatF@2
$LN26@getFormatF@2:

; 874  : 
; 875  : 		case 32:
; 876  : 			switch (fmt)

	mov	edx, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	sub	eax, 6
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 3
	ja	SHORT $LN35@getFormatF@2
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN41@getFormatF@2[ecx*4]
$LN23@getFormatF@2:

; 877  : 			{
; 878  : 			case PF_R5G6B5:
; 879  : 				return PF_X8R8G8B8;

	mov	eax, 26					; 0000001aH
	jmp	$LN37@getFormatF@2
$LN22@getFormatF@2:

; 880  : 
; 881  : 			case PF_B5G6R5:
; 882  : 				return PF_X8B8G8R8;

	mov	eax, 27					; 0000001bH
	jmp	$LN37@getFormatF@2
$LN21@getFormatF@2:

; 883  : 
; 884  : 			case PF_A4R4G4B4:
; 885  : 				return PF_A8R8G8B8;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN37@getFormatF@2
$LN20@getFormatF@2:

; 886  : 
; 887  : 			case PF_A1R5G5B5:
; 888  : 				return PF_A2R10G10B10;

	mov	eax, 15					; 0000000fH
	jmp	SHORT $LN37@getFormatF@2
$LN35@getFormatF@2:

; 889  : 
; 890  : 			default:
; 891  : 				// use original image format
; 892  : 				break;
; 893  : 			}
; 894  : 			break;
; 895  : 
; 896  : 		default:
; 897  : 			// use original image format
; 898  : 			break;
; 899  : 		}
; 900  : 
; 901  : 		switch (floatBits)

	movzx	edx, WORD PTR _floatBits$[ebp]
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 16			; 00000010H
	je	SHORT $LN15@getFormatF@2
	cmp	DWORD PTR tv75[ebp], 32			; 00000020H
	je	SHORT $LN8@getFormatF@2
	jmp	SHORT $LN16@getFormatF@2
$LN15@getFormatF@2:

; 902  : 		{
; 903  : 		case 16:
; 904  : 			switch (fmt)

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	cmp	DWORD PTR tv76[ebp], 24			; 00000018H
	je	SHORT $LN11@getFormatF@2
	cmp	DWORD PTR tv76[ebp], 25			; 00000019H
	je	SHORT $LN10@getFormatF@2
	cmp	DWORD PTR tv76[ebp], 33			; 00000021H
	je	SHORT $LN12@getFormatF@2
	jmp	SHORT $LN13@getFormatF@2
$LN12@getFormatF@2:

; 905  : 			{
; 906  : 			case PF_FLOAT32_R:
; 907  : 				return PF_FLOAT16_R;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN37@getFormatF@2
$LN11@getFormatF@2:

; 908  : 
; 909  : 			case PF_FLOAT32_RGB:
; 910  : 				return PF_FLOAT16_RGB;

	mov	eax, 22					; 00000016H
	jmp	SHORT $LN37@getFormatF@2
$LN10@getFormatF@2:

; 911  : 
; 912  : 			case PF_FLOAT32_RGBA:
; 913  : 				return PF_FLOAT16_RGBA;

	mov	eax, 23					; 00000017H
	jmp	SHORT $LN37@getFormatF@2
$LN13@getFormatF@2:

; 914  : 
; 915  : 			default:
; 916  : 				// use original image format
; 917  : 				break;
; 918  : 			}
; 919  : 			break;

	jmp	SHORT $LN16@getFormatF@2
$LN8@getFormatF@2:

; 920  : 
; 921  : 		case 32:
; 922  : 			switch (fmt)

	mov	ecx, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 22			; 00000016H
	je	SHORT $LN4@getFormatF@2
	cmp	DWORD PTR tv80[ebp], 23			; 00000017H
	je	SHORT $LN3@getFormatF@2
	cmp	DWORD PTR tv80[ebp], 32			; 00000020H
	je	SHORT $LN5@getFormatF@2
	jmp	SHORT $LN16@getFormatF@2
$LN5@getFormatF@2:

; 923  : 			{
; 924  : 			case PF_FLOAT16_R:
; 925  : 				return PF_FLOAT32_R;

	mov	eax, 33					; 00000021H
	jmp	SHORT $LN37@getFormatF@2
$LN4@getFormatF@2:

; 926  : 
; 927  : 			case PF_FLOAT16_RGB:
; 928  : 				return PF_FLOAT32_RGB;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN37@getFormatF@2
$LN3@getFormatF@2:

; 929  : 
; 930  : 			case PF_FLOAT16_RGBA:
; 931  : 				return PF_FLOAT32_RGBA;

	mov	eax, 25					; 00000019H
	jmp	SHORT $LN37@getFormatF@2
$LN16@getFormatF@2:

; 932  : 
; 933  : 			default:
; 934  : 				// use original image format
; 935  : 				break;
; 936  : 			}
; 937  : 			break;
; 938  : 
; 939  : 		default:
; 940  : 			// use original image format
; 941  : 			break;
; 942  : 		}
; 943  : 
; 944  : 		return fmt;

	mov	eax, DWORD PTR _fmt$[ebp]
$LN37@getFormatF@2:

; 945  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN40@getFormatF@2:
	DD	$LN31@getFormatF@2
	DD	$LN30@getFormatF@2
	DD	$LN29@getFormatF@2
	DD	$LN28@getFormatF@2
	DD	$LN32@getFormatF@2
$LN39@getFormatF@2:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	3
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	1
	DB	2
	npad	1
$LN41@getFormatF@2:
	DD	$LN23@getFormatF@2
	DD	$LN22@getFormatF@2
	DD	$LN21@getFormatF@2
	DD	$LN20@getFormatF@2
?getFormatForBitDepths@PixelUtil@Ogre@@SA?AW4PixelFormat@2@W432@GG@Z ENDP ; Ogre::PixelUtil::getFormatForBitDepths
_TEXT	ENDS
PUBLIC	?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
PUBLIC	?packColour@PixelUtil@Ogre@@SAXABVColourValue@2@W4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
; Function compile flags: /Odtp
_TEXT	SEGMENT
_colour$ = 8						; size = 4
_pf$ = 12						; size = 4
_dest$ = 16						; size = 4
?packColour@PixelUtil@Ogre@@SAXABVColourValue@2@W4PixelFormat@2@PAX@Z PROC ; Ogre::PixelUtil::packColour

; 951  : 	{

	push	ebp
	mov	ebp, esp

; 952  : 		packColour(colour.r, colour.g, colour.b, colour.a, pf, dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _colour$[ebp]
	push	ecx
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _colour$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _colour$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _colour$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	call	?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
	add	esp, 24					; 00000018H

; 953  : 	}

	pop	ebp
	ret	0
?packColour@PixelUtil@Ogre@@SAXABVColourValue@2@W4PixelFormat@2@PAX@Z ENDP ; Ogre::PixelUtil::packColour
_TEXT	ENDS
PUBLIC	__real@406fe00000000000
PUBLIC	?intWrite@Bitwise@Ogre@@SAXPAXHI@Z		; Ogre::Bitwise::intWrite
PUBLIC	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z		; Ogre::Bitwise::fixedToFixed
PUBLIC	?packColour@PixelUtil@Ogre@@SAXEEEEW4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv225 = -40						; size = 4
tv223 = -36						; size = 4
tv222 = -32						; size = 4
tv220 = -28						; size = 4
tv219 = -24						; size = 4
tv217 = -20						; size = 4
tv216 = -16						; size = 4
tv214 = -12						; size = 4
_value$62843 = -8					; size = 4
_des$ = -4						; size = 4
_r$ = 8							; size = 1
_g$ = 12						; size = 1
_b$ = 16						; size = 1
_a$ = 20						; size = 1
_pf$ = 24						; size = 4
_dest$ = 28						; size = 4
?packColour@PixelUtil@Ogre@@SAXEEEEW4PixelFormat@2@PAX@Z PROC ; Ogre::PixelUtil::packColour

; 956  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 957  : 		const PixelFormatDescription &des = getDescriptionFor(pf);

	mov	eax, DWORD PTR _pf$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 958  : 		if(des.flags & PFF_NATIVEENDIAN) {

	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	$LN2@packColour

; 959  : 			// Shortcut for integer formats packing
; 960  : 			unsigned int value = ((Bitwise::fixedToFixed(r, 8, des.rbits)<<des.rshift) & des.rmask) |
; 961  : 				((Bitwise::fixedToFixed(g, 8, des.gbits)<<des.gshift) & des.gmask) |
; 962  : 				((Bitwise::fixedToFixed(b, 8, des.bbits)<<des.bshift) & des.bmask) |
; 963  : 				((Bitwise::fixedToFixed(a, 8, des.abits)<<des.ashift) & des.amask);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	push	8
	movzx	edx, BYTE PTR _r$[ebp]
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	esi, eax
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	shl	esi, cl
	mov	ecx, DWORD PTR _des$[ebp]
	and	esi, DWORD PTR [ecx+24]
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	push	eax
	push	8
	movzx	ecx, BYTE PTR _g$[ebp]
	push	ecx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [edx+41]
	shl	eax, cl
	mov	ecx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [ecx+28]
	or	esi, eax
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	push	eax
	push	8
	movzx	ecx, BYTE PTR _b$[ebp]
	push	ecx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [edx+42]
	shl	eax, cl
	mov	ecx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [ecx+32]
	or	esi, eax
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	push	eax
	push	8
	movzx	ecx, BYTE PTR _a$[ebp]
	push	ecx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [edx+43]
	shl	eax, cl
	mov	ecx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [ecx+36]
	or	esi, eax
	mov	DWORD PTR _value$62843[ebp], esi

; 964  : 			// And write to memory
; 965  : 			Bitwise::intWrite(dest, des.elemBytes, value);

	mov	edx, DWORD PTR _value$62843[ebp]
	push	edx
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	?intWrite@Bitwise@Ogre@@SAXPAXHI@Z	; Ogre::Bitwise::intWrite
	add	esp, 12					; 0000000cH

; 966  : 		} else {

	jmp	SHORT $LN1@packColour
$LN2@packColour:

; 967  : 			// Convert to float
; 968  : 			packColour((float)r/255.0f,(float)g/255.0f,(float)b/255.0f,(float)a/255.0f, pf, dest);

	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _a$[ebp]
	mov	DWORD PTR tv214[ebp], edx
	fild	DWORD PTR tv214[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR tv216[ebp]
	fld	DWORD PTR tv216[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	movzx	eax, BYTE PTR _b$[ebp]
	mov	DWORD PTR tv217[ebp], eax
	fild	DWORD PTR tv217[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR tv219[ebp]
	fld	DWORD PTR tv219[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	movzx	ecx, BYTE PTR _g$[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	fild	DWORD PTR tv220[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR tv222[ebp]
	fld	DWORD PTR tv222[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	movzx	edx, BYTE PTR _r$[ebp]
	mov	DWORD PTR tv223[ebp], edx
	fild	DWORD PTR tv223[ebp]
	fdiv	QWORD PTR __real@406fe00000000000
	fstp	DWORD PTR tv225[ebp]
	fld	DWORD PTR tv225[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
	add	esp, 24					; 00000018H
$LN1@packColour:

; 969  : 		}
; 970  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?packColour@PixelUtil@Ogre@@SAXEEEEW4PixelFormat@2@PAX@Z ENDP ; Ogre::PixelUtil::packColour
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebitwise.h
_TEXT	ENDS
;	COMDAT ?fixedToFixed@Bitwise@Ogre@@SAIIII@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_n$ = 12						; size = 4
_p$ = 16						; size = 4
?fixedToFixed@Bitwise@Ogre@@SAIIII@Z PROC		; Ogre::Bitwise::fixedToFixed, COMDAT

; 123  : 		{

	push	ebp
	mov	ebp, esp
	push	esi

; 124  : 			if(n > p) 

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _p$[ebp]
	jbe	SHORT $LN7@fixedToFix

; 125  : 			{
; 126  : 				// Less bits required than available; this is easy
; 127  : 				value >>= n-p;

	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	shr	edx, cl
	mov	DWORD PTR _value$[ebp], edx
	jmp	SHORT $LN6@fixedToFix
$LN7@fixedToFix:

; 128  : 			} 
; 129  : 			else if(n < p)

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _p$[ebp]
	jae	SHORT $LN6@fixedToFix

; 130  : 			{
; 131  : 				// More bits required than are there, do the fill
; 132  : 				// Use old fashioned division, probably better than a loop
; 133  : 				if(value == 0)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN4@fixedToFix

; 134  : 					value = 0;

	mov	DWORD PTR _value$[ebp], 0
	jmp	SHORT $LN6@fixedToFix
$LN4@fixedToFix:

; 135  : 				else if(value == (static_cast<unsigned int>(1)<<n)-1)

	mov	edx, 1
	mov	ecx, DWORD PTR _n$[ebp]
	shl	edx, cl
	sub	edx, 1
	cmp	DWORD PTR _value$[ebp], edx
	jne	SHORT $LN2@fixedToFix

; 136  : 					value = (1<<p)-1;

	mov	eax, 1
	mov	ecx, DWORD PTR _p$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	DWORD PTR _value$[ebp], eax
	jmp	SHORT $LN6@fixedToFix
$LN2@fixedToFix:

; 137  : 				else    value = value*(1<<p)/((1<<n)-1);

	mov	edx, 1
	mov	ecx, DWORD PTR _p$[ebp]
	shl	edx, cl
	mov	eax, edx
	imul	eax, DWORD PTR _value$[ebp]
	mov	esi, 1
	mov	ecx, DWORD PTR _n$[ebp]
	shl	esi, cl
	sub	esi, 1
	xor	edx, edx
	div	esi
	mov	DWORD PTR _value$[ebp], eax
$LN6@fixedToFix:

; 138  : 			}
; 139  : 			return value;    

	mov	eax, DWORD PTR _value$[ebp]

; 140  : 		}

	pop	esi
	pop	ebp
	ret	0
?fixedToFixed@Bitwise@Ogre@@SAIIII@Z ENDP		; Ogre::Bitwise::fixedToFixed
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?intWrite@Bitwise@Ogre@@SAXPAXHI@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
_dest$ = 8						; size = 4
_n$ = 12						; size = 4
_value$ = 16						; size = 4
?intWrite@Bitwise@Ogre@@SAXPAXHI@Z PROC			; Ogre::Bitwise::intWrite, COMDAT

; 165  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 166  : 			switch(n) {

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN7@intWrite
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN9@intWrite[edx*4]
$LN4@intWrite:

; 167  : 	case 1:
; 168  : 		((uint8*)dest)[0] = (uint8)value;

	mov	eax, DWORD PTR _dest$[ebp]
	mov	cl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [eax], cl

; 169  : 		break;

	jmp	SHORT $LN7@intWrite
$LN3@intWrite:

; 170  : 	case 2:
; 171  : 		((uint16*)dest)[0] = (uint16)value;

	mov	edx, DWORD PTR _dest$[ebp]
	mov	ax, WORD PTR _value$[ebp]
	mov	WORD PTR [edx], ax

; 172  : 		break;

	jmp	SHORT $LN7@intWrite
$LN2@intWrite:

; 173  : 	case 3:
; 174  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG      
; 175  : 		((uint8*)dest)[0] = (uint8)((value >> 16) & 0xFF);
; 176  : 		((uint8*)dest)[1] = (uint8)((value >> 8) & 0xFF);
; 177  : 		((uint8*)dest)[2] = (uint8)(value & 0xFF);
; 178  : #else
; 179  : 		((uint8*)dest)[2] = (uint8)((value >> 16) & 0xFF);

	mov	ecx, DWORD PTR _value$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [edx+2], cl

; 180  : 		((uint8*)dest)[1] = (uint8)((value >> 8) & 0xFF);

	mov	eax, DWORD PTR _value$[ebp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [ecx+1], al

; 181  : 		((uint8*)dest)[0] = (uint8)(value & 0xFF);

	mov	edx, DWORD PTR _value$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [eax], dl

; 182  : #endif
; 183  : 		break;

	jmp	SHORT $LN7@intWrite
$LN1@intWrite:

; 184  : 	case 4:
; 185  : 		((uint32*)dest)[0] = (uint32)value;                

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], edx
$LN7@intWrite:

; 186  : 		break;                
; 187  : 			}        
; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@intWrite:
	DD	$LN4@intWrite
	DD	$LN3@intWrite
	DD	$LN2@intWrite
	DD	$LN1@intWrite
?intWrite@Bitwise@Ogre@@SAXPAXHI@Z ENDP			; Ogre::Bitwise::intWrite
_TEXT	ENDS
PUBLIC	__TI3?AVUnimplementedException@Ogre@@
PUBLIC	?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
PUBLIC	?floatToHalf@Bitwise@Ogre@@SAGM@Z		; Ogre::Bitwise::floatToHalf
PUBLIC	?floatToFixed@Bitwise@Ogre@@SAIMI@Z		; Ogre::Bitwise::floatToFixed
PUBLIC	__CTA3?AVUnimplementedException@Ogre@@
PUBLIC	__CT??_R0?AVUnimplementedException@Ogre@@@8??0UnimplementedException@Ogre@@QAE@ABV01@@Z160
;	COMDAT __CT??_R0?AVUnimplementedException@Ogre@@@8??0UnimplementedException@Ogre@@QAE@ABV01@@Z160
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
xdata$x	SEGMENT
__CT??_R0?AVUnimplementedException@Ogre@@@8??0UnimplementedException@Ogre@@QAE@ABV01@@Z160 DD 00H
	DD	FLAT:??_R0?AVUnimplementedException@Ogre@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0a0H
	DD	FLAT:??0UnimplementedException@Ogre@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVUnimplementedException@Ogre@@
xdata$x	SEGMENT
__CTA3?AVUnimplementedException@Ogre@@ DD 03H
	DD	FLAT:__CT??_R0?AVUnimplementedException@Ogre@@@8??0UnimplementedException@Ogre@@QAE@ABV01@@Z160
	DD	FLAT:__CT??_R0?AVException@Ogre@@@8??0Exception@Ogre@@QAE@ABV01@@Z160
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVUnimplementedException@Ogre@@
xdata$x	SEGMENT
__TI3?AVUnimplementedException@Ogre@@ DD 00H
	DD	FLAT:??1UnimplementedException@Ogre@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVUnimplementedException@Ogre@@
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$3
__ehfuncinfo$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv264 = -324						; size = 4
tv266 = -320						; size = 4
tv262 = -316						; size = 4
tv265 = -312						; size = 4
tv260 = -308						; size = 4
tv228 = -304						; size = 4
tv149 = -300						; size = 4
$T70626 = -296						; size = 160
$T70625 = -133						; size = 1
$T70624 = -132						; size = 28
$T70623 = -104						; size = 28
$T70622 = -76						; size = 28
$T70621 = -48						; size = 28
_value$62859 = -20					; size = 4
_des$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_pf$ = 24						; size = 4
_dest$ = 28						; size = 4
?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z PROC ; Ogre::PixelUtil::packColour

; 973  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 974  : 		// Catch-it-all here
; 975  : 		const PixelFormatDescription &des = getDescriptionFor(pf);

	mov	eax, DWORD PTR _pf$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 976  : 		if(des.flags & PFF_NATIVEENDIAN) {

	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	$LN16@packColour@2

; 977  : 			// Do the packing
; 978  : 			//std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
; 979  : 			const unsigned int value = ((Bitwise::floatToFixed(r, des.rbits)<<des.rshift) & des.rmask) |
; 980  : 				((Bitwise::floatToFixed(g, des.gbits)<<des.gshift) & des.gmask) |
; 981  : 				((Bitwise::floatToFixed(b, des.bbits)<<des.bshift) & des.bmask) |
; 982  : 				((Bitwise::floatToFixed(a, des.abits)<<des.ashift) & des.amask);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [edx+40]
	shl	esi, cl
	mov	eax, DWORD PTR _des$[ebp]
	and	esi, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+18]
	push	edx
	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [ecx+41]
	shl	eax, cl
	mov	edx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [edx+28]
	or	esi, eax
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	push	ecx
	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [edx+42]
	shl	eax, cl
	mov	ecx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [ecx+32]
	or	esi, eax
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	push	eax
	push	ecx
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [ecx+43]
	shl	eax, cl
	mov	edx, DWORD PTR _des$[ebp]
	and	eax, DWORD PTR [edx+36]
	or	esi, eax
	mov	DWORD PTR _value$62859[ebp], esi

; 983  : 			// And write to memory
; 984  : 			Bitwise::intWrite(dest, des.elemBytes, value);

	mov	eax, DWORD PTR _value$62859[ebp]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	?intWrite@Bitwise@Ogre@@SAXPAXHI@Z	; Ogre::Bitwise::intWrite
	add	esp, 12					; 0000000cH

; 985  : 		} else {

	jmp	$LN13@packColour@2
$LN16@packColour@2:

; 986  : 			switch(pf)

	mov	ecx, DWORD PTR _pf$[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR tv149[ebp]
	sub	edx, 5
	mov	DWORD PTR tv149[ebp], edx
	cmp	DWORD PTR tv149[ebp], 32		; 00000020H
	ja	$LN1@packColour@2
	mov	eax, DWORD PTR tv149[ebp]
	movzx	ecx, BYTE PTR $LN23@packColour@2[eax]
	jmp	DWORD PTR $LN25@packColour@2[ecx*4]
$LN12@packColour@2:

; 987  : 			{
; 988  : 			case PF_FLOAT32_R:
; 989  : 				((float*)dest)[0] = r;

	mov	edx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 990  : 				break;

	jmp	$LN13@packColour@2
$LN11@packColour@2:

; 991  : 			case PF_FLOAT32_GR:
; 992  : 				((float*)dest)[0] = g;

	mov	eax, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [eax]

; 993  : 				((float*)dest)[1] = r;

	mov	ecx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [ecx+4]

; 994  : 				break;

	jmp	$LN13@packColour@2
$LN10@packColour@2:

; 995  : 			case PF_FLOAT32_RGB:
; 996  : 				((float*)dest)[0] = r;

	mov	edx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 997  : 				((float*)dest)[1] = g;

	mov	eax, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [eax+4]

; 998  : 				((float*)dest)[2] = b;

	mov	ecx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx+8]

; 999  : 				break;

	jmp	$LN13@packColour@2
$LN9@packColour@2:

; 1000 : 			case PF_FLOAT32_RGBA:
; 1001 : 				((float*)dest)[0] = r;

	mov	edx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 1002 : 				((float*)dest)[1] = g;

	mov	eax, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [eax+4]

; 1003 : 				((float*)dest)[2] = b;

	mov	ecx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx+8]

; 1004 : 				((float*)dest)[3] = a;

	mov	edx, DWORD PTR _dest$[ebp]
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [edx+12]

; 1005 : 				break;

	jmp	$LN13@packColour@2
$LN8@packColour@2:

; 1006 : 			case PF_FLOAT16_R:
; 1007 : 				((uint16*)dest)[0] = Bitwise::floatToHalf(r);

	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx], ax

; 1008 : 				break;

	jmp	$LN13@packColour@2
$LN7@packColour@2:

; 1009 : 			case PF_FLOAT16_GR:
; 1010 : 				((uint16*)dest)[0] = Bitwise::floatToHalf(g);

	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx], ax

; 1011 : 				((uint16*)dest)[1] = Bitwise::floatToHalf(r);

	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1012 : 				break;

	jmp	$LN13@packColour@2
$LN6@packColour@2:

; 1013 : 			case PF_FLOAT16_RGB:
; 1014 : 				((uint16*)dest)[0] = Bitwise::floatToHalf(r);

	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx], ax

; 1015 : 				((uint16*)dest)[1] = Bitwise::floatToHalf(g);

	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1016 : 				((uint16*)dest)[2] = Bitwise::floatToHalf(b);

	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+4], ax

; 1017 : 				break;

	jmp	$LN13@packColour@2
$LN5@packColour@2:

; 1018 : 			case PF_FLOAT16_RGBA:
; 1019 : 				((uint16*)dest)[0] = Bitwise::floatToHalf(r);

	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx], ax

; 1020 : 				((uint16*)dest)[1] = Bitwise::floatToHalf(g);

	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+2], ax

; 1021 : 				((uint16*)dest)[2] = Bitwise::floatToHalf(b);

	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1022 : 				((uint16*)dest)[3] = Bitwise::floatToHalf(a);

	push	ecx
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToHalf@Bitwise@Ogre@@SAGM@Z	; Ogre::Bitwise::floatToHalf
	add	esp, 4
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+6], ax

; 1023 : 				break;

	jmp	$LN13@packColour@2
$LN4@packColour@2:

; 1024 : 			case PF_SHORT_RGB:
; 1025 : 				((uint16*)dest)[0] = Bitwise::floatToFixed(r, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx], ax

; 1026 : 				((uint16*)dest)[1] = Bitwise::floatToFixed(g, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+2], ax

; 1027 : 				((uint16*)dest)[2] = Bitwise::floatToFixed(b, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1028 : 				break;

	jmp	$LN13@packColour@2
$LN3@packColour@2:

; 1029 : 			case PF_SHORT_RGBA:
; 1030 : 				((uint16*)dest)[0] = Bitwise::floatToFixed(r, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx], ax

; 1031 : 				((uint16*)dest)[1] = Bitwise::floatToFixed(g, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1032 : 				((uint16*)dest)[2] = Bitwise::floatToFixed(b, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [edx+4], ax

; 1033 : 				((uint16*)dest)[3] = Bitwise::floatToFixed(a, 16);

	push	16					; 00000010H
	push	ecx
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	WORD PTR [ecx+6], ax

; 1034 : 				break;

	jmp	$LN13@packColour@2
$LN2@packColour@2:

; 1035 : 			case PF_BYTE_LA:
; 1036 : 				((uint8*)dest)[0] = Bitwise::floatToFixed(r, 8);

	push	8
	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [edx], al

; 1037 : 				((uint8*)dest)[1] = Bitwise::floatToFixed(a, 8);

	push	8
	push	ecx
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	BYTE PTR [ecx+1], al

; 1038 : 				break;

	jmp	$LN13@packColour@2
$LN1@packColour@2:

; 1039 : 			default:
; 1040 : 				// Not yet supported
; 1041 : 				OGRE_EXCEPT(
; 1042 : 					Exception::ERR_NOT_IMPLEMENTED,
; 1043 : 					"pack to "+getFormatName(pf)+" not implemented",
; 1044 : 					"PixelUtil::packColour");

	push	OFFSET $SG62918
	lea	ecx, DWORD PTR $T70621[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	xor	edx, edx
	mov	BYTE PTR $T70625[ebp], dl
	push	1044					; 00000414H
	push	OFFSET $SG62917
	lea	eax, DWORD PTR $T70621[ebp]
	push	eax
	push	OFFSET $SG62919
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70622[ebp]
	push	edx
	call	?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getFormatName
	add	esp, 8
	mov	DWORD PTR tv228[ebp], eax
	mov	eax, DWORD PTR tv228[ebp]
	mov	DWORD PTR tv260[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv260[ebp]
	push	ecx
	push	OFFSET $SG62920
	lea	edx, DWORD PTR $T70623[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv265[ebp], eax
	mov	eax, DWORD PTR tv265[ebp]
	mov	DWORD PTR tv262[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv262[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70624[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv266[ebp], eax
	mov	eax, DWORD PTR tv266[ebp]
	mov	DWORD PTR tv264[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv264[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T70625[ebp]
	push	edx
	lea	eax, DWORD PTR $T70626[ebp]
	push	eax
	call	?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVUnimplementedException@Ogre@@
	lea	ecx, DWORD PTR $T70626[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T70624[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T70623[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70622[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70621[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@packColour@2:
$LN17@packColour@2:

; 1045 : 				break;
; 1046 : 			}
; 1047 : 		}
; 1048 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN25@packColour@2:
	DD	$LN2@packColour@2
	DD	$LN6@packColour@2
	DD	$LN5@packColour@2
	DD	$LN10@packColour@2
	DD	$LN9@packColour@2
	DD	$LN3@packColour@2
	DD	$LN8@packColour@2
	DD	$LN12@packColour@2
	DD	$LN7@packColour@2
	DD	$LN11@packColour@2
	DD	$LN4@packColour@2
	DD	$LN1@packColour@2
$LN23@packColour@2:
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	2
	DB	3
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	11					; 0000000bH
	DB	6
	DB	7
	DB	11					; 0000000bH
	DB	8
	DB	9
	DB	10					; 0000000aH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$0:
	lea	ecx, DWORD PTR $T70621[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$1:
	lea	ecx, DWORD PTR $T70622[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$2:
	lea	ecx, DWORD PTR $T70623[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z$3:
	lea	ecx, DWORD PTR $T70624[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z ENDP ; Ogre::PixelUtil::packColour
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebitwise.h
;	COMDAT ?floatToFixed@Bitwise@Ogre@@SAIMI@Z
_TEXT	SEGMENT
tv130 = -20						; size = 8
tv128 = -12						; size = 4
tv93 = -6						; size = 2
tv91 = -4						; size = 4
_value$ = 8						; size = 4
_bits$ = 12						; size = 4
?floatToFixed@Bitwise@Ogre@@SAIMI@Z PROC		; Ogre::Bitwise::floatToFixed, COMDAT

; 147  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 148  : 			if(value <= 0.0f) return 0;

	fld	DWORD PTR _value$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN4@floatToFix
	xor	eax, eax
	jmp	SHORT $LN1@floatToFix
	jmp	SHORT $LN1@floatToFix
$LN4@floatToFix:

; 149  : 			else if (value >= 1.0f) return (1<<bits)-1;

	fld	DWORD PTR _value$[ebp]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN2@floatToFix
	mov	eax, 1
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	sub	eax, 1
	jmp	SHORT $LN1@floatToFix
	jmp	SHORT $LN1@floatToFix
$LN2@floatToFix:

; 150  : 			else return (unsigned int)(value * (1<<bits));     

	mov	eax, 1
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	eax, cl
	mov	DWORD PTR tv91[ebp], eax
	fild	DWORD PTR tv91[ebp]
	fmul	DWORD PTR _value$[ebp]
	fnstcw	WORD PTR tv93[ebp]
	movzx	eax, WORD PTR tv93[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv128[ebp], eax
	fldcw	WORD PTR tv128[ebp]
	fistp	QWORD PTR tv130[ebp]
	fldcw	WORD PTR tv93[ebp]
	mov	eax, DWORD PTR tv130[ebp]
$LN1@floatToFix:

; 151  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?floatToFixed@Bitwise@Ogre@@SAIMI@Z ENDP		; Ogre::Bitwise::floatToFixed
_TEXT	ENDS
PUBLIC	?floatToHalfI@Bitwise@Ogre@@SAGI@Z		; Ogre::Bitwise::floatToHalfI
; Function compile flags: /Odtp
;	COMDAT ?floatToHalf@Bitwise@Ogre@@SAGM@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_i$ = 8							; size = 4
?floatToHalf@Bitwise@Ogre@@SAGM@Z PROC			; Ogre::Bitwise::floatToHalf, COMDAT

; 218  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 219  : 			union { float f; uint32 i; } v;
; 220  : 			v.f = i;

	fld	DWORD PTR _i$[ebp]
	fstp	DWORD PTR _v$[ebp]

; 221  : 			return floatToHalfI(v.i);

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	?floatToHalfI@Bitwise@Ogre@@SAGI@Z	; Ogre::Bitwise::floatToHalfI
	add	esp, 4

; 222  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?floatToHalf@Bitwise@Ogre@@SAGM@Z ENDP			; Ogre::Bitwise::floatToHalf
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?floatToHalfI@Bitwise@Ogre@@SAGI@Z
_TEXT	SEGMENT
_m$ = -12						; size = 4
_e$ = -8						; size = 4
_s$ = -4						; size = 4
_i$ = 8							; size = 4
?floatToHalfI@Bitwise@Ogre@@SAGI@Z PROC			; Ogre::Bitwise::floatToHalfI, COMDAT

; 226  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 227  : 			register int s =  (i >> 16) & 0x00008000;

	mov	eax, DWORD PTR _i$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 32768				; 00008000H
	mov	DWORD PTR _s$[ebp], eax

; 228  : 			register int e = ((i >> 23) & 0x000000ff) - (127 - 15);

	mov	ecx, DWORD PTR _i$[ebp]
	shr	ecx, 23					; 00000017H
	and	ecx, 255				; 000000ffH
	sub	ecx, 112				; 00000070H
	mov	DWORD PTR _e$[ebp], ecx

; 229  : 			register int m =   i        & 0x007fffff;

	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 8388607				; 007fffffH
	mov	DWORD PTR _m$[ebp], edx

; 230  : 
; 231  : 			if (e <= 0)

	cmp	DWORD PTR _e$[ebp], 0
	jg	SHORT $LN8@floatToHal

; 232  : 			{
; 233  : 				if (e < -10)

	cmp	DWORD PTR _e$[ebp], -10			; fffffff6H
	jge	SHORT $LN7@floatToHal

; 234  : 				{
; 235  : 					return 0;

	xor	eax, eax
	jmp	$LN9@floatToHal
$LN7@floatToHal:

; 236  : 				}
; 237  : 				m = (m | 0x00800000) >> (1 - e);

	mov	eax, DWORD PTR _m$[ebp]
	or	eax, 8388608				; 00800000H
	mov	ecx, 1
	sub	ecx, DWORD PTR _e$[ebp]
	sar	eax, cl
	mov	DWORD PTR _m$[ebp], eax

; 238  : 
; 239  : 				return s | (m >> 13);

	mov	eax, DWORD PTR _m$[ebp]
	sar	eax, 13					; 0000000dH
	or	eax, DWORD PTR _s$[ebp]
	jmp	SHORT $LN9@floatToHal
	jmp	SHORT $LN9@floatToHal
$LN8@floatToHal:

; 240  : 			}
; 241  : 			else if (e == 0xff - (127 - 15))

	cmp	DWORD PTR _e$[ebp], 143			; 0000008fH
	jne	SHORT $LN5@floatToHal

; 242  : 			{
; 243  : 				if (m == 0) // Inf

	cmp	DWORD PTR _m$[ebp], 0
	jne	SHORT $LN4@floatToHal

; 244  : 				{
; 245  : 					return s | 0x7c00;

	mov	eax, DWORD PTR _s$[ebp]
	or	eax, 31744				; 00007c00H
	jmp	SHORT $LN9@floatToHal

; 246  : 				} 
; 247  : 				else    // NAN

	jmp	SHORT $LN3@floatToHal
$LN4@floatToHal:

; 248  : 				{
; 249  : 					m >>= 13;

	mov	ecx, DWORD PTR _m$[ebp]
	sar	ecx, 13					; 0000000dH
	mov	DWORD PTR _m$[ebp], ecx

; 250  : 					return s | 0x7c00 | m | (m == 0);

	mov	eax, DWORD PTR _s$[ebp]
	or	eax, 31744				; 00007c00H
	or	eax, DWORD PTR _m$[ebp]
	xor	edx, edx
	cmp	DWORD PTR _m$[ebp], 0
	sete	dl
	or	eax, edx
	jmp	SHORT $LN9@floatToHal
$LN3@floatToHal:

; 251  : 				}
; 252  : 			}
; 253  : 			else

	jmp	SHORT $LN9@floatToHal
$LN5@floatToHal:

; 254  : 			{
; 255  : 				if (e > 30) // Overflow

	cmp	DWORD PTR _e$[ebp], 30			; 0000001eH
	jle	SHORT $LN1@floatToHal

; 256  : 				{
; 257  : 					return s | 0x7c00;

	mov	eax, DWORD PTR _s$[ebp]
	or	eax, 31744				; 00007c00H
	jmp	SHORT $LN9@floatToHal
$LN1@floatToHal:

; 258  : 				}
; 259  : 
; 260  : 				return s | (e << 10) | (m >> 13);

	mov	eax, DWORD PTR _e$[ebp]
	shl	eax, 10					; 0000000aH
	or	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _m$[ebp]
	sar	ecx, 13					; 0000000dH
	or	eax, ecx
$LN9@floatToHal:

; 261  : 			}
; 262  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?floatToHalfI@Bitwise@Ogre@@SAGI@Z ENDP			; Ogre::Bitwise::floatToHalfI
_TEXT	ENDS
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogreexception.h
xdata$x	SEGMENT
__unwindtable$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z$0
__ehfuncinfo$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
_TEXT	SEGMENT
$T70645 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_code$ = 12						; size = 1
_desc$ = 16						; size = 4
_src$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z PROC ; Ogre::ExceptionFactory::create, COMDAT

; 263  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T70645[ebp], 0

; 264  : 			return UnimplementedException(code.number, desc, src, file, line);

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	push	9
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0UnimplementedException@Ogre@@QAE@HABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBDJ@Z ; Ogre::UnimplementedException::UnimplementedException
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T70645[ebp]
	or	ecx, 1
	mov	DWORD PTR $T70645[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 265  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z$0:
	mov	eax, DWORD PTR $T70645[ebp]
	and	eax, 1
	je	$LN4@create@2
	and	DWORD PTR $T70645[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1UnimplementedException@Ogre@@UAE@XZ
$LN4@create@2:
	ret	0
__ehhandler$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ENDP ; Ogre::ExceptionFactory::create
PUBLIC	?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
PUBLIC	?unpackColour@PixelUtil@Ogre@@SAXPAVColourValue@2@W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
_TEXT	SEGMENT
_colour$ = 8						; size = 4
_pf$ = 12						; size = 4
_src$ = 16						; size = 4
?unpackColour@PixelUtil@Ogre@@SAXPAVColourValue@2@W4PixelFormat@2@PBX@Z PROC ; Ogre::PixelUtil::unpackColour

; 1051 : 	{

	push	ebp
	mov	ebp, esp

; 1052 : 		unpackColour(&colour->r, &colour->g, &colour->b, &colour->a, pf, src);

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _colour$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _colour$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _colour$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _colour$[ebp]
	push	edx
	call	?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
	add	esp, 24					; 00000018H

; 1053 : 	}

	pop	ebp
	ret	0
?unpackColour@PixelUtil@Ogre@@SAXPAVColourValue@2@W4PixelFormat@2@PBX@Z ENDP ; Ogre::PixelUtil::unpackColour
_TEXT	ENDS
PUBLIC	?intRead@Bitwise@Ogre@@SAIPBXH@Z		; Ogre::Bitwise::intRead
PUBLIC	?unpackColour@PixelUtil@Ogre@@SAXPAE000W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
; Function compile flags: /Odtp
_TEXT	SEGMENT
_rr$62942 = -24						; size = 4
_gg$62943 = -20						; size = 4
_bb$62944 = -16						; size = 4
_aa$62945 = -12						; size = 4
_value$62936 = -8					; size = 4
_des$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_pf$ = 24						; size = 4
_src$ = 28						; size = 4
?unpackColour@PixelUtil@Ogre@@SAXPAE000W4PixelFormat@2@PBX@Z PROC ; Ogre::PixelUtil::unpackColour

; 1056 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1057 : 		const PixelFormatDescription &des = getDescriptionFor(pf);

	mov	eax, DWORD PTR _pf$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 1058 : 		if(des.flags & PFF_NATIVEENDIAN) {

	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	$LN6@unpackColo

; 1059 : 			// Shortcut for integer formats unpacking
; 1060 : 			const unsigned int value = Bitwise::intRead(src, des.elemBytes);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?intRead@Bitwise@Ogre@@SAIPBXH@Z	; Ogre::Bitwise::intRead
	add	esp, 8
	mov	DWORD PTR _value$62936[ebp], eax

; 1061 : 			if(des.flags & PFF_LUMINANCE)

	mov	eax, DWORD PTR _des$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN5@unpackColo

; 1062 : 			{
; 1063 : 				// Luminance format -- only rbits used
; 1064 : 				*r = *g = *b = Bitwise::fixedToFixed(
; 1065 : 					(value & des.rmask)>>des.rshift, des.rbits, 8);

	push	8
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62936[ebp]
	and	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	shr	edx, cl
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _g$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1066 : 			}
; 1067 : 			else

	jmp	SHORT $LN4@unpackColo
$LN5@unpackColo:

; 1068 : 			{
; 1069 : 				*r = Bitwise::fixedToFixed((value & des.rmask)>>des.rshift, des.rbits, 8);

	push	8
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62936[ebp]
	and	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	shr	edx, cl
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [ecx], al

; 1070 : 				*g = Bitwise::fixedToFixed((value & des.gmask)>>des.gshift, des.gbits, 8);

	push	8
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62936[ebp]
	and	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+41]
	shr	edx, cl
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _g$[ebp]
	mov	BYTE PTR [ecx], al

; 1071 : 				*b = Bitwise::fixedToFixed((value & des.bmask)>>des.bshift, des.bbits, 8);

	push	8
	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+19]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62936[ebp]
	and	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+42]
	shr	edx, cl
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al
$LN4@unpackColo:

; 1072 : 			}
; 1073 : 			if(des.flags & PFF_HASALPHA)

	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	je	SHORT $LN3@unpackColo

; 1074 : 			{
; 1075 : 				*a = Bitwise::fixedToFixed((value & des.amask)>>des.ashift, des.abits, 8);

	push	8
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62936[ebp]
	and	edx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+43]
	shr	edx, cl
	push	edx
	call	?fixedToFixed@Bitwise@Ogre@@SAIIII@Z	; Ogre::Bitwise::fixedToFixed
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _a$[ebp]
	mov	BYTE PTR [ecx], al

; 1076 : 			}
; 1077 : 			else

	jmp	SHORT $LN2@unpackColo
$LN3@unpackColo:

; 1078 : 			{
; 1079 : 				*a = 255; // No alpha, default a component to full

	mov	edx, DWORD PTR _a$[ebp]
	mov	BYTE PTR [edx], 255			; 000000ffH
$LN2@unpackColo:

; 1080 : 			}
; 1081 : 		} else {

	jmp	SHORT $LN1@unpackColo
$LN6@unpackColo:

; 1082 : 			// Do the operation with the more generic floating point
; 1083 : 			float rr, gg, bb, aa;
; 1084 : 			unpackColour(&rr,&gg,&bb,&aa, pf, src);

	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _aa$62945[ebp]
	push	edx
	lea	eax, DWORD PTR _bb$62944[ebp]
	push	eax
	lea	ecx, DWORD PTR _gg$62943[ebp]
	push	ecx
	lea	edx, DWORD PTR _rr$62942[ebp]
	push	edx
	call	?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
	add	esp, 24					; 00000018H

; 1085 : 			*r = Bitwise::floatToFixed(rr, 8);

	push	8
	push	ecx
	fld	DWORD PTR _rr$62942[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _r$[ebp]
	mov	BYTE PTR [ecx], al

; 1086 : 			*g = Bitwise::floatToFixed(gg, 8);

	push	8
	push	ecx
	fld	DWORD PTR _gg$62943[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _g$[ebp]
	mov	BYTE PTR [edx], al

; 1087 : 			*b = Bitwise::floatToFixed(bb, 8);

	push	8
	push	ecx
	fld	DWORD PTR _bb$62944[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	ecx, DWORD PTR _b$[ebp]
	mov	BYTE PTR [ecx], al

; 1088 : 			*a = Bitwise::floatToFixed(aa, 8);

	push	8
	push	ecx
	fld	DWORD PTR _aa$62945[ebp]
	fstp	DWORD PTR [esp]
	call	?floatToFixed@Bitwise@Ogre@@SAIMI@Z	; Ogre::Bitwise::floatToFixed
	add	esp, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	BYTE PTR [edx], al
$LN1@unpackColo:

; 1089 : 		}
; 1090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?unpackColour@PixelUtil@Ogre@@SAXPAE000W4PixelFormat@2@PBX@Z ENDP ; Ogre::PixelUtil::unpackColour
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebitwise.h
_TEXT	ENDS
;	COMDAT ?intRead@Bitwise@Ogre@@SAIPBXH@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
_src$ = 8						; size = 4
_n$ = 12						; size = 4
?intRead@Bitwise@Ogre@@SAIPBXH@Z PROC			; Ogre::Bitwise::intRead, COMDAT

; 192  : 		static inline unsigned int intRead(const void *src, int n) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 193  : 			switch(n) {

	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN5@intRead
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN9@intRead[edx*4]
$LN4@intRead:

; 194  : 				case 1:
; 195  : 					return ((uint8*)src)[0];

	mov	eax, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [eax]
	jmp	SHORT $LN7@intRead
$LN3@intRead:

; 196  : 				case 2:
; 197  : 					return ((uint16*)src)[0];

	mov	ecx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [ecx]
	jmp	SHORT $LN7@intRead
$LN2@intRead:

; 198  : 				case 3:
; 199  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG      
; 200  : 					return ((uint32)((uint8*)src)[0]<<16)|
; 201  : 						((uint32)((uint8*)src)[1]<<8)|
; 202  : 						((uint32)((uint8*)src)[2]);
; 203  : #else
; 204  : 					return ((uint32)((uint8*)src)[0])|
; 205  : 						((uint32)((uint8*)src)[1]<<8)|
; 206  : 						((uint32)((uint8*)src)[2]<<16);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 16					; 00000010H
	or	eax, edx
	jmp	SHORT $LN7@intRead
$LN1@intRead:

; 207  : #endif
; 208  : 				case 4:
; 209  : 					return ((uint32*)src)[0];

	mov	eax, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN7@intRead
$LN5@intRead:

; 210  : 			} 
; 211  : 			return 0; // ?

	xor	eax, eax
$LN7@intRead:

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@intRead:
	DD	$LN4@intRead
	DD	$LN3@intRead
	DD	$LN2@intRead
	DD	$LN1@intRead
?intRead@Bitwise@Ogre@@SAIPBXH@Z ENDP			; Ogre::Bitwise::intRead
_TEXT	ENDS
PUBLIC	?halfToFloat@Bitwise@Ogre@@SAMG@Z		; Ogre::Bitwise::halfToFloat
PUBLIC	?fixedToFloat@Bitwise@Ogre@@SAMII@Z		; Ogre::Bitwise::fixedToFloat
xdata$x	SEGMENT
__unwindtable$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$3
__ehfuncinfo$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv277 = -324						; size = 4
tv279 = -320						; size = 4
tv275 = -316						; size = 4
tv278 = -312						; size = 4
tv273 = -308						; size = 4
tv241 = -304						; size = 4
tv162 = -300						; size = 4
$T70665 = -296						; size = 160
$T70664 = -133						; size = 1
$T70663 = -132						; size = 28
$T70662 = -104						; size = 28
$T70661 = -76						; size = 28
$T70660 = -48						; size = 28
_value$62956 = -20					; size = 4
_des$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
_pf$ = 24						; size = 4
_src$ = 28						; size = 4
?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z PROC ; Ogre::PixelUtil::unpackColour

; 1094 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1095 : 		const PixelFormatDescription &des = getDescriptionFor(pf);

	mov	eax, DWORD PTR _pf$[ebp]
	push	eax
	call	?getDescriptionFor@Ogre@@YAABUPixelFormatDescription@1@W4PixelFormat@1@@Z ; Ogre::getDescriptionFor
	add	esp, 4
	mov	DWORD PTR _des$[ebp], eax

; 1096 : 		if(des.flags & PFF_NATIVEENDIAN) {

	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16					; 00000010H
	je	$LN20@unpackColo@2

; 1097 : 			// Shortcut for integer formats unpacking
; 1098 : 			const unsigned int value = Bitwise::intRead(src, des.elemBytes);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?intRead@Bitwise@Ogre@@SAIPBXH@Z	; Ogre::Bitwise::intRead
	add	esp, 8
	mov	DWORD PTR _value$62956[ebp], eax

; 1099 : 			if(des.flags & PFF_LUMINANCE)

	mov	eax, DWORD PTR _des$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 32					; 00000020H
	je	SHORT $LN19@unpackColo@2

; 1100 : 			{
; 1101 : 				// Luminance format -- only rbits used
; 1102 : 				*r = *g = *b = Bitwise::fixedToFloat(
; 1103 : 					(value & des.rmask)>>des.rshift, des.rbits);

	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+17]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62956[ebp]
	and	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	shr	edx, cl
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	ecx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _g$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx]

; 1104 : 			}
; 1105 : 			else

	jmp	SHORT $LN18@unpackColo@2
$LN19@unpackColo@2:

; 1106 : 			{
; 1107 : 				*r = Bitwise::fixedToFloat((value & des.rmask)>>des.rshift, des.rbits);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+17]
	push	ecx
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR _value$62956[ebp]
	and	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [ecx+40]
	shr	eax, cl
	push	eax
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 1108 : 				*g = Bitwise::fixedToFloat((value & des.gmask)>>des.gshift, des.gbits);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+18]
	push	ecx
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR _value$62956[ebp]
	and	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [ecx+41]
	shr	eax, cl
	push	eax
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [edx]

; 1109 : 				*b = Bitwise::fixedToFloat((value & des.bmask)>>des.bshift, des.bbits);

	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+19]
	push	ecx
	mov	edx, DWORD PTR _des$[ebp]
	mov	eax, DWORD PTR _value$62956[ebp]
	and	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [ecx+42]
	shr	eax, cl
	push	eax
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx]
$LN18@unpackColo@2:

; 1110 : 			}
; 1111 : 			if(des.flags & PFF_HASALPHA)

	mov	eax, DWORD PTR _des$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 1
	je	SHORT $LN17@unpackColo@2

; 1112 : 			{
; 1113 : 				*a = Bitwise::fixedToFloat((value & des.amask)>>des.ashift, des.abits);

	mov	edx, DWORD PTR _des$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _des$[ebp]
	mov	edx, DWORD PTR _value$62956[ebp]
	and	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _des$[ebp]
	movzx	ecx, BYTE PTR [eax+43]
	shr	edx, cl
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	ecx, DWORD PTR _a$[ebp]
	fstp	DWORD PTR [ecx]

; 1114 : 			}
; 1115 : 			else

	jmp	SHORT $LN16@unpackColo@2
$LN17@unpackColo@2:

; 1116 : 			{
; 1117 : 				*a = 1.0f; // No alpha, default a component to full

	mov	edx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [edx]
$LN16@unpackColo@2:

; 1118 : 			}
; 1119 : 		} else {

	jmp	$LN13@unpackColo@2
$LN20@unpackColo@2:

; 1120 : 			switch(pf)

	mov	eax, DWORD PTR _pf$[ebp]
	mov	DWORD PTR tv162[ebp], eax
	mov	ecx, DWORD PTR tv162[ebp]
	sub	ecx, 5
	mov	DWORD PTR tv162[ebp], ecx
	cmp	DWORD PTR tv162[ebp], 32		; 00000020H
	ja	$LN1@unpackColo@2
	mov	edx, DWORD PTR tv162[ebp]
	movzx	eax, BYTE PTR $LN27@unpackColo@2[edx]
	jmp	DWORD PTR $LN29@unpackColo@2[eax*4]
$LN12@unpackColo@2:

; 1121 : 			{
; 1122 : 			case PF_FLOAT32_R:
; 1123 : 				*r = *g = *b = ((float*)src)[0];

	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _g$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]

; 1124 : 				*a = 1.0f;

	mov	ecx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [ecx]

; 1125 : 				break;

	jmp	$LN13@unpackColo@2
$LN11@unpackColo@2:

; 1126 : 			case PF_FLOAT32_GR:
; 1127 : 				*g = ((float*)src)[0];

	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]

; 1128 : 				*r = *b = ((float*)src)[1];

	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 1129 : 				*a = 1.0f;

	mov	edx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [edx]

; 1130 : 				break;

	jmp	$LN13@unpackColo@2
$LN10@unpackColo@2:

; 1131 : 			case PF_FLOAT32_RGB:
; 1132 : 				*r = ((float*)src)[0];

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 1133 : 				*g = ((float*)src)[1];

	mov	edx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx]

; 1134 : 				*b = ((float*)src)[2];

	mov	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx]

; 1135 : 				*a = 1.0f;

	mov	eax, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [eax]

; 1136 : 				break;

	jmp	$LN13@unpackColo@2
$LN9@unpackColo@2:

; 1137 : 			case PF_FLOAT32_RGBA:
; 1138 : 				*r = ((float*)src)[0];

	mov	ecx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx]

; 1139 : 				*g = ((float*)src)[1];

	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax]

; 1140 : 				*b = ((float*)src)[2];

	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [edx]

; 1141 : 				*a = ((float*)src)[3];

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx]

; 1142 : 				break;

	jmp	$LN13@unpackColo@2
$LN8@unpackColo@2:

; 1143 : 			case PF_FLOAT16_R:
; 1144 : 				*r = *g = *b = Bitwise::halfToFloat(((uint16*)src)[0]);

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _g$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _g$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]

; 1145 : 				*a = 1.0f;

	mov	ecx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [ecx]

; 1146 : 				break;

	jmp	$LN13@unpackColo@2
$LN7@unpackColo@2:

; 1147 : 			case PF_FLOAT16_GR:
; 1148 : 				*g = Bitwise::halfToFloat(((uint16*)src)[0]);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [ecx]

; 1149 : 				*r = *b = Bitwise::halfToFloat(((uint16*)src)[1]);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	ecx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx]
	mov	edx, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [edx]

; 1150 : 				*a = 1.0f;

	mov	ecx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [ecx]

; 1151 : 				break;

	jmp	$LN13@unpackColo@2
$LN6@unpackColo@2:

; 1152 : 			case PF_FLOAT16_RGB:
; 1153 : 				*r = Bitwise::halfToFloat(((uint16*)src)[0]);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx]
	push	eax
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	ecx, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [ecx]

; 1154 : 				*g = Bitwise::halfToFloat(((uint16*)src)[1]);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	ecx, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [ecx]

; 1155 : 				*b = Bitwise::halfToFloat(((uint16*)src)[2]);

	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, WORD PTR [edx+4]
	push	eax
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	ecx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx]

; 1156 : 				*a = 1.0f;

	mov	edx, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [edx]

; 1157 : 				break;

	jmp	$LN13@unpackColo@2
$LN5@unpackColo@2:

; 1158 : 			case PF_FLOAT16_RGBA:
; 1159 : 				*r = Bitwise::halfToFloat(((uint16*)src)[0]);

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	edx, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 1160 : 				*g = Bitwise::halfToFloat(((uint16*)src)[1]);

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	edx, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [edx]

; 1161 : 				*b = Bitwise::halfToFloat(((uint16*)src)[2]);

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx]

; 1162 : 				*a = Bitwise::halfToFloat(((uint16*)src)[3]);

	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	push	ecx
	call	?halfToFloat@Bitwise@Ogre@@SAMG@Z	; Ogre::Bitwise::halfToFloat
	add	esp, 4
	mov	edx, DWORD PTR _a$[ebp]
	fstp	DWORD PTR [edx]

; 1163 : 				break;

	jmp	$LN13@unpackColo@2
$LN4@unpackColo@2:

; 1164 : 			case PF_SHORT_RGB:
; 1165 : 				*r = Bitwise::fixedToFloat(((uint16*)src)[0], 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [edx]

; 1166 : 				*g = Bitwise::fixedToFloat(((uint16*)src)[1], 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [edx]

; 1167 : 				*b = Bitwise::fixedToFloat(((uint16*)src)[2], 16);

	push	16					; 00000010H
	mov	eax, DWORD PTR _src$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	push	ecx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	edx, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [edx]

; 1168 : 				*a = 1.0f;

	mov	eax, DWORD PTR _a$[ebp]
	fld1
	fstp	DWORD PTR [eax]

; 1169 : 				break;

	jmp	$LN13@unpackColo@2
$LN3@unpackColo@2:

; 1170 : 			case PF_SHORT_RGBA:
; 1171 : 				*r = Bitwise::fixedToFloat(((uint16*)src)[0], 16);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, WORD PTR [ecx]
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	eax, DWORD PTR _r$[ebp]
	fstp	DWORD PTR [eax]

; 1172 : 				*g = Bitwise::fixedToFloat(((uint16*)src)[1], 16);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	eax, DWORD PTR _g$[ebp]
	fstp	DWORD PTR [eax]

; 1173 : 				*b = Bitwise::fixedToFloat(((uint16*)src)[2], 16);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	eax, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [eax]

; 1174 : 				*a = Bitwise::fixedToFloat(((uint16*)src)[3], 16);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, WORD PTR [ecx+6]
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	eax, DWORD PTR _a$[ebp]
	fstp	DWORD PTR [eax]

; 1175 : 				break;

	jmp	$LN13@unpackColo@2
$LN2@unpackColo@2:

; 1176 : 			case PF_BYTE_LA:
; 1177 : 				*r = *g = *b = Bitwise::fixedToFloat(((uint8*)src)[0], 8);

	push	8
	mov	ecx, DWORD PTR _src$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	eax, DWORD PTR _b$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _g$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [ecx]
	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR _g$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 1178 : 				*a = Bitwise::fixedToFloat(((uint8*)src)[1], 8);

	push	8
	mov	edx, DWORD PTR _src$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	call	?fixedToFloat@Bitwise@Ogre@@SAMII@Z	; Ogre::Bitwise::fixedToFloat
	add	esp, 8
	mov	ecx, DWORD PTR _a$[ebp]
	fstp	DWORD PTR [ecx]

; 1179 : 				break;

	jmp	$LN13@unpackColo@2
$LN1@unpackColo@2:

; 1180 : 			default:
; 1181 : 				// Not yet supported
; 1182 : 				OGRE_EXCEPT(Exception::ERR_NOT_IMPLEMENTED,
; 1183 : 					"unpack from "+getFormatName(pf)+" not implemented",
; 1184 : 					"PixelUtil::unpackColour");

	push	OFFSET $SG63015
	lea	ecx, DWORD PTR $T70660[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	xor	edx, edx
	mov	BYTE PTR $T70664[ebp], dl
	push	1184					; 000004a0H
	push	OFFSET $SG63014
	lea	eax, DWORD PTR $T70660[ebp]
	push	eax
	push	OFFSET $SG63016
	mov	ecx, DWORD PTR _pf$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70661[ebp]
	push	edx
	call	?getFormatName@PixelUtil@Ogre@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4PixelFormat@2@@Z ; Ogre::PixelUtil::getFormatName
	add	esp, 8
	mov	DWORD PTR tv241[ebp], eax
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR tv273[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv273[ebp]
	push	ecx
	push	OFFSET $SG63017
	lea	edx, DWORD PTR $T70662[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv278[ebp], eax
	mov	eax, DWORD PTR tv278[ebp]
	mov	DWORD PTR tv275[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv275[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70663[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv279[ebp], eax
	mov	eax, DWORD PTR tv279[ebp]
	mov	DWORD PTR tv277[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv277[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T70664[ebp]
	push	edx
	lea	eax, DWORD PTR $T70665[ebp]
	push	eax
	call	?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVUnimplementedException@Ogre@@
	lea	ecx, DWORD PTR $T70665[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T70663[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T70662[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70661[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70660[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN13@unpackColo@2:
$LN21@unpackColo@2:

; 1185 : 				break;
; 1186 : 			}
; 1187 : 		}
; 1188 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN29@unpackColo@2:
	DD	$LN2@unpackColo@2
	DD	$LN6@unpackColo@2
	DD	$LN5@unpackColo@2
	DD	$LN10@unpackColo@2
	DD	$LN9@unpackColo@2
	DD	$LN3@unpackColo@2
	DD	$LN8@unpackColo@2
	DD	$LN12@unpackColo@2
	DD	$LN7@unpackColo@2
	DD	$LN11@unpackColo@2
	DD	$LN4@unpackColo@2
	DD	$LN1@unpackColo@2
$LN27@unpackColo@2:
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	2
	DB	3
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	11					; 0000000bH
	DB	6
	DB	7
	DB	11					; 0000000bH
	DB	8
	DB	9
	DB	10					; 0000000aH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$0:
	lea	ecx, DWORD PTR $T70660[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$1:
	lea	ecx, DWORD PTR $T70661[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$2:
	lea	ecx, DWORD PTR $T70662[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z$3:
	lea	ecx, DWORD PTR $T70663[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-316]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z ENDP ; Ogre::PixelUtil::unpackColour
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebitwise.h
;	COMDAT ?fixedToFloat@Bitwise@Ogre@@SAMII@Z
_TEXT	SEGMENT
tv82 = -16						; size = 4
tv79 = -12						; size = 4
tv73 = -8						; size = 8
_value$ = 8						; size = 4
_bits$ = 12						; size = 4
?fixedToFloat@Bitwise@Ogre@@SAMII@Z PROC		; Ogre::Bitwise::fixedToFloat, COMDAT

; 157  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 158  : 			return (float)value/(float)((1<<bits)-1);

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	DWORD PTR tv73[ebp+4], 0
	fild	QWORD PTR tv73[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR _bits$[ebp]
	shl	edx, cl
	sub	edx, 1
	mov	DWORD PTR tv79[ebp], edx
	fidiv	DWORD PTR tv79[ebp]
	fstp	DWORD PTR tv82[ebp]
	fld	DWORD PTR tv82[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?fixedToFloat@Bitwise@Ogre@@SAMII@Z ENDP		; Ogre::Bitwise::fixedToFloat
_TEXT	ENDS
PUBLIC	?halfToFloatI@Bitwise@Ogre@@SAIG@Z		; Ogre::Bitwise::halfToFloatI
; Function compile flags: /Odtp
;	COMDAT ?halfToFloat@Bitwise@Ogre@@SAMG@Z
_TEXT	SEGMENT
_v$ = -4						; size = 4
_y$ = 8							; size = 2
?halfToFloat@Bitwise@Ogre@@SAMG@Z PROC			; Ogre::Bitwise::halfToFloat, COMDAT

; 269  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 270  : 			union { float f; uint32 i; } v;
; 271  : 			v.i = halfToFloatI(y);

	movzx	eax, WORD PTR _y$[ebp]
	push	eax
	call	?halfToFloatI@Bitwise@Ogre@@SAIG@Z	; Ogre::Bitwise::halfToFloatI
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax

; 272  : 			return v.f;

	fld	DWORD PTR _v$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?halfToFloat@Bitwise@Ogre@@SAMG@Z ENDP			; Ogre::Bitwise::halfToFloat
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?halfToFloatI@Bitwise@Ogre@@SAIG@Z
_TEXT	SEGMENT
_m$ = -12						; size = 4
_e$ = -8						; size = 4
_s$ = -4						; size = 4
_y$ = 8							; size = 2
?halfToFloatI@Bitwise@Ogre@@SAIG@Z PROC			; Ogre::Bitwise::halfToFloatI, COMDAT

; 278  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 279  : 			register int s = (y >> 15) & 0x00000001;

	movzx	eax, WORD PTR _y$[ebp]
	sar	eax, 15					; 0000000fH
	and	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 280  : 			register int e = (y >> 10) & 0x0000001f;

	movzx	ecx, WORD PTR _y$[ebp]
	sar	ecx, 10					; 0000000aH
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _e$[ebp], ecx

; 281  : 			register int m =  y        & 0x000003ff;

	movzx	edx, WORD PTR _y$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _m$[ebp], edx

; 282  : 
; 283  : 			if (e == 0)

	cmp	DWORD PTR _e$[ebp], 0
	jne	SHORT $LN9@halfToFloa

; 284  : 			{
; 285  : 				if (m == 0) // Plus or minus zero

	cmp	DWORD PTR _m$[ebp], 0
	jne	SHORT $LN6@halfToFloa

; 286  : 				{
; 287  : 					return s << 31;

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 31					; 0000001fH
	jmp	$LN10@halfToFloa

; 288  : 				}
; 289  : 				else // Denormalized number -- renormalize it

	jmp	SHORT $LN7@halfToFloa
$LN6@halfToFloa:

; 290  : 				{
; 291  : 					while (!(m & 0x00000400))

	mov	eax, DWORD PTR _m$[ebp]
	and	eax, 1024				; 00000400H
	jne	SHORT $LN5@halfToFloa

; 292  : 					{
; 293  : 						m <<= 1;

	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _m$[ebp], ecx

; 294  : 						e -=  1;

	mov	edx, DWORD PTR _e$[ebp]
	sub	edx, 1
	mov	DWORD PTR _e$[ebp], edx

; 295  : 					}

	jmp	SHORT $LN6@halfToFloa
$LN5@halfToFloa:

; 296  : 
; 297  : 					e += 1;

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 1
	mov	DWORD PTR _e$[ebp], eax

; 298  : 					m &= ~0x00000400;

	mov	ecx, DWORD PTR _m$[ebp]
	and	ecx, -1025				; fffffbffH
	mov	DWORD PTR _m$[ebp], ecx
$LN7@halfToFloa:

; 299  : 				}

	jmp	SHORT $LN4@halfToFloa
$LN9@halfToFloa:

; 300  : 			}
; 301  : 			else if (e == 31)

	cmp	DWORD PTR _e$[ebp], 31			; 0000001fH
	jne	SHORT $LN4@halfToFloa

; 302  : 			{
; 303  : 				if (m == 0) // Inf

	cmp	DWORD PTR _m$[ebp], 0
	jne	SHORT $LN2@halfToFloa

; 304  : 				{
; 305  : 					return (s << 31) | 0x7f800000;

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 31					; 0000001fH
	or	eax, 2139095040				; 7f800000H
	jmp	SHORT $LN10@halfToFloa

; 306  : 				}
; 307  : 				else // NaN

	jmp	SHORT $LN4@halfToFloa
$LN2@halfToFloa:

; 308  : 				{
; 309  : 					return (s << 31) | 0x7f800000 | (m << 13);

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 31					; 0000001fH
	or	eax, 2139095040				; 7f800000H
	mov	edx, DWORD PTR _m$[ebp]
	shl	edx, 13					; 0000000dH
	or	eax, edx
	jmp	SHORT $LN10@halfToFloa
$LN4@halfToFloa:

; 310  : 				}
; 311  : 			}
; 312  : 
; 313  : 			e = e + (127 - 15);

	mov	eax, DWORD PTR _e$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR _e$[ebp], eax

; 314  : 			m = m << 13;

	mov	ecx, DWORD PTR _m$[ebp]
	shl	ecx, 13					; 0000000dH
	mov	DWORD PTR _m$[ebp], ecx

; 315  : 
; 316  : 			return (s << 31) | (e << 23) | m;

	mov	eax, DWORD PTR _s$[ebp]
	shl	eax, 31					; 0000001fH
	mov	edx, DWORD PTR _e$[ebp]
	shl	edx, 23					; 00000017H
	or	eax, edx
	or	eax, DWORD PTR _m$[ebp]
$LN10@halfToFloa:

; 317  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?halfToFloatI@Bitwise@Ogre@@SAIG@Z ENDP			; Ogre::Bitwise::halfToFloatI
_TEXT	ENDS
PUBLIC	?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z ; Ogre::PixelUtil::bulkPixelConversion
PUBLIC	?bulkPixelConversion@PixelUtil@Ogre@@SAXPAXW4PixelFormat@2@01I@Z ; Ogre::PixelUtil::bulkPixelConversion
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.cpp
_TEXT	SEGMENT
_src$ = -80						; size = 40
_dst$ = -40						; size = 40
_srcp$ = 8						; size = 4
_srcFormat$ = 12					; size = 4
_destp$ = 16						; size = 4
_dstFormat$ = 20					; size = 4
_count$ = 24						; size = 4
?bulkPixelConversion@PixelUtil@Ogre@@SAXPAXW4PixelFormat@2@01I@Z PROC ; Ogre::PixelUtil::bulkPixelConversion

; 1193 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1194 : 		PixelBox src(count, 1, 1, srcFormat, srcp),

	mov	eax, DWORD PTR _srcp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcFormat$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	lea	ecx, DWORD PTR _src$[ebp]
	call	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox

; 1195 : 			dst(count, 1, 1, dstFormat, destp);

	mov	eax, DWORD PTR _destp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dstFormat$[ebp]
	push	ecx
	push	1
	push	1
	mov	edx, DWORD PTR _count$[ebp]
	push	edx
	lea	ecx, DWORD PTR _dst$[ebp]
	call	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox

; 1196 : 
; 1197 : 		bulkPixelConversion(src, dst);

	lea	eax, DWORD PTR _dst$[ebp]
	push	eax
	lea	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z ; Ogre::PixelUtil::bulkPixelConversion
	add	esp, 8

; 1198 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?bulkPixelConversion@PixelUtil@Ogre@@SAXPAXW4PixelFormat@2@01I@Z ENDP ; Ogre::PixelUtil::bulkPixelConversion
_TEXT	ENDS
PUBLIC	?doOptimizedConversion@?A0xbce8a349@@YAHABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::doOptimizedConversion
EXTRN	_memcpy:PROC
xdata$x	SEGMENT
__unwindtable$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z$1
__ehfuncinfo$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
$T70687 = -416						; size = 160
$T70686 = -253						; size = 1
$T70685 = -252						; size = 28
$T70684 = -224						; size = 28
_x$63094 = -196						; size = 4
_y$63090 = -192						; size = 4
_z$63086 = -188						; size = 4
_tempsrc$63070 = -184					; size = 40
_tempdst$63067 = -144					; size = 40
_y$63061 = -104						; size = 4
_z$63057 = -100						; size = 4
_srcSliceSkipBytes$63053 = -96				; size = 4
_rowSize$63056 = -92					; size = 4
_srcRowPitchBytes$63052 = -88				; size = 4
_srcptr$63046 = -84					; size = 4
_srcPixelSize$63050 = -80				; size = 4
_dstPixelSize$63051 = -76				; size = 4
_dstRowPitchBytes$63054 = -72				; size = 4
_dstSliceSkipBytes$63055 = -68				; size = 4
_dstptr$63048 = -64					; size = 4
_srcSliceSkipBytes$ = -60				; size = 4
_r$ = -56						; size = 4
_srcptr$ = -52						; size = 4
_g$ = -48						; size = 4
_b$ = -44						; size = 4
_srcPixelSize$ = -40					; size = 4
_dstPixelSize$ = -36					; size = 4
_srcRowSkipBytes$ = -32					; size = 4
_dstRowSkipBytes$ = -28					; size = 4
_dstSliceSkipBytes$ = -24				; size = 4
_a$ = -20						; size = 4
_dstptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z PROC ; Ogre::PixelUtil::bulkPixelConversion

; 1201 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 404				; 00000194H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1202 : 		assert(src.getWidth() == dst.getWidth() &&
; 1203 : 			src.getHeight() == dst.getHeight() &&
; 1204 : 			src.getDepth() == dst.getDepth());
; 1205 : 
; 1206 : 		// Check for compressed formats, we don't support decompression, compression or recoding
; 1207 : 		if(PixelUtil::isCompressed(src.format) || PixelUtil::isCompressed(dst.format))

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN25@bulkPixelC
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?isCompressed@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::isCompressed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	$LN23@bulkPixelC
$LN25@bulkPixelC:

; 1208 : 		{
; 1209 : 			if(src.format == dst.format)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+28]
	jne	SHORT $LN24@bulkPixelC

; 1210 : 			{
; 1211 : 				memcpy(dst.data, src.data, src.getConsecutiveSize());

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getConsecutiveSize@PixelBox@Ogre@@QBEIXZ ; Ogre::PixelBox::getConsecutiveSize
	push	eax
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1212 : 				return;

	jmp	$LN27@bulkPixelC

; 1213 : 			}
; 1214 : 			else

	jmp	$LN23@bulkPixelC
$LN24@bulkPixelC:

; 1215 : 			{
; 1216 : 				OGRE_EXCEPT(Exception::ERR_NOT_IMPLEMENTED,
; 1217 : 					"This method can not be used to compress or decompress images",
; 1218 : 					"PixelUtil::bulkPixelConversion");

	push	OFFSET $SG63042
	lea	ecx, DWORD PTR $T70684[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET $SG63043
	lea	ecx, DWORD PTR $T70685[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	xor	ecx, ecx
	mov	BYTE PTR $T70686[ebp], cl
	push	1218					; 000004c2H
	push	OFFSET $SG63041
	lea	edx, DWORD PTR $T70684[ebp]
	push	edx
	lea	eax, DWORD PTR $T70685[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T70686[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70687[ebp]
	push	edx
	call	?create@ExceptionFactory@Ogre@@SA?AVUnimplementedException@2@U?$ExceptionCodeType@$08@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1PBDJ@Z ; Ogre::ExceptionFactory::create
	add	esp, 24					; 00000018H
	push	OFFSET __TI3?AVUnimplementedException@Ogre@@
	lea	eax, DWORD PTR $T70687[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T70685[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T70684[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@bulkPixelC:

; 1219 : 			}
; 1220 : 		}
; 1221 : 
; 1222 : 		// The easy case
; 1223 : 		if(src.format == dst.format) {

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [ecx+28]
	cmp	eax, DWORD PTR [edx+28]
	jne	$LN22@bulkPixelC

; 1224 : 			// Everything consecutive?
; 1225 : 			if(src.isConsecutive() && dst.isConsecutive())

	mov	ecx, DWORD PTR _src$[ebp]
	call	?isConsecutive@PixelBox@Ogre@@QBE_NXZ	; Ogre::PixelBox::isConsecutive
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@bulkPixelC
	mov	ecx, DWORD PTR _dst$[ebp]
	call	?isConsecutive@PixelBox@Ogre@@QBE_NXZ	; Ogre::PixelBox::isConsecutive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@bulkPixelC

; 1226 : 			{
; 1227 : 				memcpy(dst.data, src.data, src.getConsecutiveSize());

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getConsecutiveSize@PixelBox@Ogre@@QBEIXZ ; Ogre::PixelBox::getConsecutiveSize
	push	eax
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1228 : 				return;

	jmp	$LN27@bulkPixelC
$LN21@bulkPixelC:

; 1229 : 			}
; 1230 : 
; 1231 : 			uint8 *srcptr = static_cast<uint8*>(src.data);

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _srcptr$63046[ebp], edx

; 1232 : 			uint8 *dstptr = static_cast<uint8*>(dst.data);

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _dstptr$63048[ebp], ecx

; 1233 : 			const size_t srcPixelSize = PixelUtil::getNumElemBytes(src.format);

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	mov	DWORD PTR _srcPixelSize$63050[ebp], eax

; 1234 : 			const size_t dstPixelSize = PixelUtil::getNumElemBytes(dst.format);

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	mov	DWORD PTR _dstPixelSize$63051[ebp], eax

; 1235 : 
; 1236 : 			// Calculate pitches+skips in bytes
; 1237 : 			const size_t srcRowPitchBytes = src.rowPitch*srcPixelSize;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, DWORD PTR _srcPixelSize$63050[ebp]
	mov	DWORD PTR _srcRowPitchBytes$63052[ebp], ecx

; 1238 : 			//const size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
; 1239 : 			const size_t srcSliceSkipBytes = src.getSliceSkip()*srcPixelSize;

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	imul	eax, DWORD PTR _srcPixelSize$63050[ebp]
	mov	DWORD PTR _srcSliceSkipBytes$63053[ebp], eax

; 1240 : 
; 1241 : 			const size_t dstRowPitchBytes = dst.rowPitch*dstPixelSize;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, DWORD PTR _dstPixelSize$63051[ebp]
	mov	DWORD PTR _dstRowPitchBytes$63054[ebp], eax

; 1242 : 			//const size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
; 1243 : 			const size_t dstSliceSkipBytes = dst.getSliceSkip()*dstPixelSize;

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	imul	eax, DWORD PTR _dstPixelSize$63051[ebp]
	mov	DWORD PTR _dstSliceSkipBytes$63055[ebp], eax

; 1244 : 
; 1245 : 			// Otherwise, copy per row
; 1246 : 			const size_t rowSize = src.getWidth()*srcPixelSize;

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	imul	eax, DWORD PTR _srcPixelSize$63050[ebp]
	mov	DWORD PTR _rowSize$63056[ebp], eax

; 1247 : 			for(int z=src.m_Front; z<src.m_Back; z++)

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$63057[ebp], edx
	jmp	SHORT $LN20@bulkPixelC
$LN19@bulkPixelC:
	mov	eax, DWORD PTR _z$63057[ebp]
	add	eax, 1
	mov	DWORD PTR _z$63057[ebp], eax
$LN20@bulkPixelC:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$63057[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	SHORT $LN18@bulkPixelC

; 1248 : 			{
; 1249 : 				for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$63061[ebp], ecx
	jmp	SHORT $LN17@bulkPixelC
$LN16@bulkPixelC:
	mov	edx, DWORD PTR _y$63061[ebp]
	add	edx, 1
	mov	DWORD PTR _y$63061[ebp], edx
$LN17@bulkPixelC:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$63061[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN15@bulkPixelC

; 1250 : 				{
; 1251 : 					memcpy(dstptr, srcptr, rowSize);

	mov	edx, DWORD PTR _rowSize$63056[ebp]
	push	edx
	mov	eax, DWORD PTR _srcptr$63046[ebp]
	push	eax
	mov	ecx, DWORD PTR _dstptr$63048[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1252 : 					srcptr += srcRowPitchBytes;

	mov	edx, DWORD PTR _srcptr$63046[ebp]
	add	edx, DWORD PTR _srcRowPitchBytes$63052[ebp]
	mov	DWORD PTR _srcptr$63046[ebp], edx

; 1253 : 					dstptr += dstRowPitchBytes;

	mov	eax, DWORD PTR _dstptr$63048[ebp]
	add	eax, DWORD PTR _dstRowPitchBytes$63054[ebp]
	mov	DWORD PTR _dstptr$63048[ebp], eax

; 1254 : 				}

	jmp	SHORT $LN16@bulkPixelC
$LN15@bulkPixelC:

; 1255 : 				srcptr += srcSliceSkipBytes;

	mov	ecx, DWORD PTR _srcptr$63046[ebp]
	add	ecx, DWORD PTR _srcSliceSkipBytes$63053[ebp]
	mov	DWORD PTR _srcptr$63046[ebp], ecx

; 1256 : 				dstptr += dstSliceSkipBytes;

	mov	edx, DWORD PTR _dstptr$63048[ebp]
	add	edx, DWORD PTR _dstSliceSkipBytes$63055[ebp]
	mov	DWORD PTR _dstptr$63048[ebp], edx

; 1257 : 			}

	jmp	SHORT $LN19@bulkPixelC
$LN18@bulkPixelC:

; 1258 : 			return;

	jmp	$LN27@bulkPixelC
$LN22@bulkPixelC:

; 1259 : 		}
; 1260 : 		// Converting to PF_X8R8G8B8 is exactly the same as converting to
; 1261 : 		// PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
; 1262 : 		if(dst.format == PF_X8R8G8B8 || dst.format == PF_X8B8G8R8)

	mov	eax, DWORD PTR _dst$[ebp]
	cmp	DWORD PTR [eax+28], 26			; 0000001aH
	je	SHORT $LN13@bulkPixelC
	mov	ecx, DWORD PTR _dst$[ebp]
	cmp	DWORD PTR [ecx+28], 27			; 0000001bH
	jne	SHORT $LN14@bulkPixelC
$LN13@bulkPixelC:

; 1263 : 		{
; 1264 : 			// Do the same conversion, with PF_A8R8G8B8, which has a lot of
; 1265 : 			// optimized conversions
; 1266 : 			PixelBox tempdst = dst;

	mov	esi, DWORD PTR _dst$[ebp]
	mov	ecx, 10					; 0000000aH
	lea	edi, DWORD PTR _tempdst$63067[ebp]
	rep movsd

; 1267 : 			tempdst.format = dst.format==PF_X8R8G8B8?PF_A8R8G8B8:PF_A8B8G8R8;

	mov	edx, DWORD PTR _dst$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+28], 26			; 0000001aH
	setne	al
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _tempdst$63067[ebp+28], eax

; 1268 : 			bulkPixelConversion(src, tempdst);

	lea	ecx, DWORD PTR _tempdst$63067[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z ; Ogre::PixelUtil::bulkPixelConversion
	add	esp, 8

; 1269 : 			return;

	jmp	$LN27@bulkPixelC
$LN14@bulkPixelC:

; 1270 : 		}
; 1271 : 		// Converting from PF_X8R8G8B8 is exactly the same as converting from
; 1272 : 		// PF_A8R8G8B8, given that the destination format does not have alpha.
; 1273 : 		if((src.format == PF_X8R8G8B8||src.format == PF_X8B8G8R8) && !hasAlpha(dst.format))

	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+28], 26			; 0000001aH
	je	SHORT $LN11@bulkPixelC
	mov	ecx, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [ecx+28], 27			; 0000001bH
	jne	SHORT $LN12@bulkPixelC
$LN11@bulkPixelC:
	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?hasAlpha@PixelUtil@Ogre@@SA_NW4PixelFormat@2@@Z ; Ogre::PixelUtil::hasAlpha
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN12@bulkPixelC

; 1274 : 		{
; 1275 : 			// Do the same conversion, with PF_A8R8G8B8, which has a lot of
; 1276 : 			// optimized conversions
; 1277 : 			PixelBox tempsrc = src;

	mov	esi, DWORD PTR _src$[ebp]
	mov	ecx, 10					; 0000000aH
	lea	edi, DWORD PTR _tempsrc$63070[ebp]
	rep movsd

; 1278 : 			tempsrc.format = src.format==PF_X8R8G8B8?PF_A8R8G8B8:PF_A8B8G8R8;

	mov	edx, DWORD PTR _src$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+28], 26			; 0000001aH
	setne	al
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _tempsrc$63070[ebp+28], eax

; 1279 : 			bulkPixelConversion(tempsrc, dst);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	lea	edx, DWORD PTR _tempsrc$63070[ebp]
	push	edx
	call	?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z ; Ogre::PixelUtil::bulkPixelConversion
	add	esp, 8

; 1280 : 			return;

	jmp	$LN27@bulkPixelC
$LN12@bulkPixelC:

; 1281 : 		}
; 1282 : 
; 1283 : 		// NB VC6 can't handle the templates required for optimised conversion, tough
; 1284 : #if OGRE_COMPILER != OGRE_COMPILER_MSVC || OGRE_COMP_VER >= 1300
; 1285 : 		// Is there a specialized, inlined, conversion?
; 1286 : 		if(doOptimizedConversion(src, dst))

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?doOptimizedConversion@?A0xbce8a349@@YAHABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::doOptimizedConversion
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@bulkPixelC

; 1287 : 		{
; 1288 : 			// If so, good
; 1289 : 			return;

	jmp	$LN27@bulkPixelC
$LN10@bulkPixelC:

; 1290 : 		}
; 1291 : #endif
; 1292 : 
; 1293 : 		uint8 *srcptr = static_cast<uint8*>(src.data);

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _srcptr$[ebp], eax

; 1294 : 		uint8 *dstptr = static_cast<uint8*>(dst.data);

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _dstptr$[ebp], edx

; 1295 : 		const size_t srcPixelSize = PixelUtil::getNumElemBytes(src.format);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	mov	DWORD PTR _srcPixelSize$[ebp], eax

; 1296 : 		const size_t dstPixelSize = PixelUtil::getNumElemBytes(dst.format);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?getNumElemBytes@PixelUtil@Ogre@@SAIW4PixelFormat@2@@Z ; Ogre::PixelUtil::getNumElemBytes
	add	esp, 4
	mov	DWORD PTR _dstPixelSize$[ebp], eax

; 1297 : 
; 1298 : 		// Calculate pitches+skips in bytes
; 1299 : 		const size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getRowSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getRowSkip
	imul	eax, DWORD PTR _srcPixelSize$[ebp]
	mov	DWORD PTR _srcRowSkipBytes$[ebp], eax

; 1300 : 		const size_t srcSliceSkipBytes = src.getSliceSkip()*srcPixelSize;

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	imul	eax, DWORD PTR _srcPixelSize$[ebp]
	mov	DWORD PTR _srcSliceSkipBytes$[ebp], eax

; 1301 : 		const size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getRowSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getRowSkip
	imul	eax, DWORD PTR _dstPixelSize$[ebp]
	mov	DWORD PTR _dstRowSkipBytes$[ebp], eax

; 1302 : 		const size_t dstSliceSkipBytes = dst.getSliceSkip()*dstPixelSize;

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	imul	eax, DWORD PTR _dstPixelSize$[ebp]
	mov	DWORD PTR _dstSliceSkipBytes$[ebp], eax

; 1303 : 
; 1304 : 		// The brute force fallback
; 1305 : 		float r,g,b,a;
; 1306 : 		for(int z=src.m_Front; z<src.m_Back; z++)

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$63086[ebp], edx
	jmp	SHORT $LN9@bulkPixelC
$LN8@bulkPixelC:
	mov	eax, DWORD PTR _z$63086[ebp]
	add	eax, 1
	mov	DWORD PTR _z$63086[ebp], eax
$LN9@bulkPixelC:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$63086[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN7@bulkPixelC

; 1307 : 		{
; 1308 : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$63090[ebp], ecx
	jmp	SHORT $LN6@bulkPixelC
$LN5@bulkPixelC:
	mov	edx, DWORD PTR _y$63090[ebp]
	add	edx, 1
	mov	DWORD PTR _y$63090[ebp], edx
$LN6@bulkPixelC:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$63090[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	$LN4@bulkPixelC

; 1309 : 			{
; 1310 : 				for(int x=src.m_Left; x<src.m_Right; x++)

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _x$63094[ebp], eax
	jmp	SHORT $LN3@bulkPixelC
$LN2@bulkPixelC:
	mov	ecx, DWORD PTR _x$63094[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$63094[ebp], ecx
$LN3@bulkPixelC:
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR _x$63094[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jge	SHORT $LN1@bulkPixelC

; 1311 : 				{
; 1312 : 					unpackColour(&r, &g, &b, &a, src.format, srcptr);

	mov	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	lea	ecx, DWORD PTR _a$[ebp]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	lea	ecx, DWORD PTR _r$[ebp]
	push	ecx
	call	?unpackColour@PixelUtil@Ogre@@SAXPAM000W4PixelFormat@2@PBX@Z ; Ogre::PixelUtil::unpackColour
	add	esp, 24					; 00000018H

; 1313 : 					packColour(r, g, b, a, dst.format, dstptr);

	mov	edx, DWORD PTR _dstptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	ecx
	fld	DWORD PTR _a$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _b$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _g$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _r$[ebp]
	fstp	DWORD PTR [esp]
	call	?packColour@PixelUtil@Ogre@@SAXMMMMW4PixelFormat@2@PAX@Z ; Ogre::PixelUtil::packColour
	add	esp, 24					; 00000018H

; 1314 : 					srcptr += srcPixelSize;

	mov	edx, DWORD PTR _srcptr$[ebp]
	add	edx, DWORD PTR _srcPixelSize$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 1315 : 					dstptr += dstPixelSize;

	mov	eax, DWORD PTR _dstptr$[ebp]
	add	eax, DWORD PTR _dstPixelSize$[ebp]
	mov	DWORD PTR _dstptr$[ebp], eax

; 1316 : 				}

	jmp	$LN2@bulkPixelC
$LN1@bulkPixelC:

; 1317 : 				srcptr += srcRowSkipBytes;

	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR _srcRowSkipBytes$[ebp]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 1318 : 				dstptr += dstRowSkipBytes;

	mov	edx, DWORD PTR _dstptr$[ebp]
	add	edx, DWORD PTR _dstRowSkipBytes$[ebp]
	mov	DWORD PTR _dstptr$[ebp], edx

; 1319 : 			}

	jmp	$LN5@bulkPixelC
$LN4@bulkPixelC:

; 1320 : 			srcptr += srcSliceSkipBytes;

	mov	eax, DWORD PTR _srcptr$[ebp]
	add	eax, DWORD PTR _srcSliceSkipBytes$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 1321 : 			dstptr += dstSliceSkipBytes;

	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR _dstSliceSkipBytes$[ebp]
	mov	DWORD PTR _dstptr$[ebp], ecx
	jmp	$LN8@bulkPixelC
$LN7@bulkPixelC:
$LN27@bulkPixelC:

; 1322 : 		}
; 1323 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z$0:
	lea	ecx, DWORD PTR $T70684[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z$1:
	lea	ecx, DWORD PTR $T70685[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-416]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?bulkPixelConversion@PixelUtil@Ogre@@SAXABVPixelBox@2@0@Z ENDP ; Ogre::PixelUtil::bulkPixelConversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::conversion
PUBLIC	?conversion@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelconversions.h
;	COMDAT ?doOptimizedConversion@?A0xbce8a349@@YAHABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?doOptimizedConversion@?A0xbce8a349@@YAHABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::doOptimizedConversion, COMDAT

; 379  : {;

	push	ebp
	mov	ebp, esp
	push	ecx

; 380  : switch(FMTCONVERTERID(src.format, dst.format))

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	shl	ecx, 8
	mov	edx, DWORD PTR _dst$[ebp]
	or	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3329		; 00000d01H
	jg	$LN44@doOptimize
	cmp	DWORD PTR tv68[ebp], 3329		; 00000d01H
	je	$LN27@doOptimize
	cmp	DWORD PTR tv68[ebp], 2826		; 00000b0aH
	jg	SHORT $LN45@doOptimize
	cmp	DWORD PTR tv68[ebp], 2826		; 00000b0aH
	je	$LN19@doOptimize
	cmp	DWORD PTR tv68[ebp], 513		; 00000201H
	jg	SHORT $LN46@doOptimize
	cmp	DWORD PTR tv68[ebp], 513		; 00000201H
	je	$LN20@doOptimize
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 258				; 00000102H
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 12			; 0000000cH
	ja	$LN1@doOptimize
	mov	ecx, DWORD PTR tv68[ebp]
	movzx	edx, BYTE PTR $LN52@doOptimize[ecx]
	jmp	DWORD PTR $LN57@doOptimize[edx*4]
$LN46@doOptimize:
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 2571				; 00000a0bH
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN1@doOptimize
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN58@doOptimize[ecx*4]
$LN45@doOptimize:
	cmp	DWORD PTR tv68[ebp], 3082		; 00000c0aH
	jg	SHORT $LN47@doOptimize
	cmp	DWORD PTR tv68[ebp], 3082		; 00000c0aH
	je	$LN10@doOptimize
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 2828				; 00000b0cH
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 245		; 000000f5H
	ja	$LN1@doOptimize
	mov	eax, DWORD PTR tv68[ebp]
	movzx	ecx, BYTE PTR $LN53@doOptimize[eax]
	jmp	DWORD PTR $LN59@doOptimize[ecx*4]
$LN47@doOptimize:
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 3083				; 00000c0bH
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 17			; 00000011H
	ja	$LN1@doOptimize
	mov	eax, DWORD PTR tv68[ebp]
	movzx	ecx, BYTE PTR $LN54@doOptimize[eax]
	jmp	DWORD PTR $LN60@doOptimize[ecx*4]
$LN44@doOptimize:
	cmp	DWORD PTR tv68[ebp], 6670		; 00001a0eH
	jg	$LN48@doOptimize
	cmp	DWORD PTR tv68[ebp], 6670		; 00001a0eH
	je	$LN7@doOptimize
	cmp	DWORD PTR tv68[ebp], 3596		; 00000e0cH
	jg	SHORT $LN49@doOptimize
	cmp	DWORD PTR tv68[ebp], 3596		; 00000e0cH
	je	$LN33@doOptimize
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 3340				; 00000d0cH
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 245		; 000000f5H
	ja	$LN1@doOptimize
	mov	eax, DWORD PTR tv68[ebp]
	movzx	ecx, BYTE PTR $LN55@doOptimize[eax]
	jmp	DWORD PTR $LN61@doOptimize[ecx*4]
$LN49@doOptimize:
	cmp	DWORD PTR tv68[ebp], 6668		; 00001a0cH
	jg	SHORT $LN50@doOptimize
	cmp	DWORD PTR tv68[ebp], 6668		; 00001a0cH
	je	$LN9@doOptimize
	cmp	DWORD PTR tv68[ebp], 3597		; 00000e0dH
	je	$LN32@doOptimize
	cmp	DWORD PTR tv68[ebp], 3612		; 00000e1cH
	je	$LN31@doOptimize
	jmp	$LN1@doOptimize
$LN50@doOptimize:
	cmp	DWORD PTR tv68[ebp], 6669		; 00001a0dH
	je	$LN8@doOptimize
	jmp	$LN1@doOptimize
$LN48@doOptimize:
	cmp	DWORD PTR tv68[ebp], 6940		; 00001b1cH
	jg	SHORT $LN51@doOptimize
	cmp	DWORD PTR tv68[ebp], 6940		; 00001b1cH
	je	$LN2@doOptimize
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 6684				; 00001a1cH
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 242		; 000000f2H
	ja	$LN1@doOptimize
	mov	eax, DWORD PTR tv68[ebp]
	movzx	ecx, BYTE PTR $LN56@doOptimize[eax]
	jmp	DWORD PTR $LN62@doOptimize[ecx*4]
$LN51@doOptimize:
	cmp	DWORD PTR tv68[ebp], 7180		; 00001c0cH
	je	$LN30@doOptimize
	cmp	DWORD PTR tv68[ebp], 7181		; 00001c0dH
	je	$LN29@doOptimize
	cmp	DWORD PTR tv68[ebp], 7182		; 00001c0eH
	je	$LN28@doOptimize
	jmp	$LN1@doOptimize
$LN39@doOptimize:

; 381  : {
; 382  : 	// Register converters here
; 383  : 	CASECONVERTER(A8R8G8B8toA8B8G8R8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN38@doOptimize:

; 384  : 	CASECONVERTER(A8R8G8B8toB8G8R8A8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN37@doOptimize:

; 385  : 	CASECONVERTER(A8R8G8B8toR8G8B8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN36@doOptimize:

; 386  : 	CASECONVERTER(A8B8G8R8toA8R8G8B8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN35@doOptimize:

; 387  : 	CASECONVERTER(A8B8G8R8toB8G8R8A8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN34@doOptimize:

; 388  : 	CASECONVERTER(A8B8G8R8toR8G8B8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN33@doOptimize:

; 389  : 	CASECONVERTER(B8G8R8A8toA8R8G8B8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN32@doOptimize:

; 390  : 	CASECONVERTER(B8G8R8A8toA8B8G8R8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN31@doOptimize:

; 391  : 	CASECONVERTER(B8G8R8A8toR8G8B8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN30@doOptimize:

; 392  : 	CASECONVERTER(R8G8B8A8toA8R8G8B8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN29@doOptimize:

; 393  : 	CASECONVERTER(R8G8B8A8toA8B8G8R8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN28@doOptimize:

; 394  : 	CASECONVERTER(R8G8B8A8toB8G8R8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN27@doOptimize:

; 395  : 	CASECONVERTER(A8B8G8R8toL8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN26@doOptimize:

; 396  : 	CASECONVERTER(L8toA8B8G8R8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN25@doOptimize:

; 397  : 	CASECONVERTER(A8R8G8B8toL8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN24@doOptimize:

; 398  : 	CASECONVERTER(L8toA8R8G8B8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN23@doOptimize:

; 399  : 	CASECONVERTER(B8G8R8A8toL8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN22@doOptimize:

; 400  : 	CASECONVERTER(L8toB8G8R8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN21@doOptimize:

; 401  : 	CASECONVERTER(L8toL16);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN20@doOptimize:

; 402  : 	CASECONVERTER(L16toL8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN19@doOptimize:

; 403  : 	CASECONVERTER(B8G8R8toR8G8B8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN18@doOptimize:

; 404  : 	CASECONVERTER(R8G8B8toB8G8R8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN17@doOptimize:

; 405  : 	CASECONVERTER(R8G8B8toA8R8G8B8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN16@doOptimize:

; 406  : 	CASECONVERTER(B8G8R8toA8R8G8B8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN15@doOptimize:

; 407  : 	CASECONVERTER(R8G8B8toA8B8G8R8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN14@doOptimize:

; 408  : 	CASECONVERTER(B8G8R8toA8B8G8R8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN13@doOptimize:

; 409  : 	CASECONVERTER(R8G8B8toB8G8R8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN12@doOptimize:

; 410  : 	CASECONVERTER(B8G8R8toB8G8R8A8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN11@doOptimize:

; 411  : 	CASECONVERTER(A8R8G8B8toR8G8B8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN10@doOptimize:

; 412  : 	CASECONVERTER(A8R8G8B8toB8G8R8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN9@doOptimize:

; 413  : 	CASECONVERTER(X8R8G8B8toA8R8G8B8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN8@doOptimize:

; 414  : 	CASECONVERTER(X8R8G8B8toA8B8G8R8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	$LN42@doOptimize
$LN7@doOptimize:

; 415  : 	CASECONVERTER(X8R8G8B8toB8G8R8A8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN6@doOptimize:

; 416  : 	CASECONVERTER(X8R8G8B8toR8G8B8A8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN5@doOptimize:

; 417  : 	CASECONVERTER(X8B8G8R8toA8R8G8B8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN4@doOptimize:

; 418  : 	CASECONVERTER(X8B8G8R8toA8B8G8R8);

	mov	eax, DWORD PTR _dst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	call	?conversion@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN3@doOptimize:

; 419  : 	CASECONVERTER(X8B8G8R8toB8G8R8A8);

	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	?conversion@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN2@doOptimize:

; 420  : 	CASECONVERTER(X8B8G8R8toR8G8B8A8);

	mov	ecx, DWORD PTR _dst$[ebp]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	call	?conversion@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::conversion
	add	esp, 8
	mov	eax, 1
	jmp	SHORT $LN42@doOptimize
$LN1@doOptimize:

; 421  : 
; 422  : default:
; 423  : 	return 0;

	xor	eax, eax
$LN42@doOptimize:

; 424  : }
; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN57@doOptimize:
	DD	$LN21@doOptimize
	DD	$LN24@doOptimize
	DD	$LN26@doOptimize
	DD	$LN22@doOptimize
	DD	$LN1@doOptimize
$LN52@doOptimize:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
	npad	3
$LN58@doOptimize:
	DD	$LN18@doOptimize
	DD	$LN17@doOptimize
	DD	$LN15@doOptimize
	DD	$LN13@doOptimize
$LN59@doOptimize:
	DD	$LN16@doOptimize
	DD	$LN14@doOptimize
	DD	$LN12@doOptimize
	DD	$LN25@doOptimize
	DD	$LN1@doOptimize
$LN53@doOptimize:
	DB	0
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	npad	2
$LN60@doOptimize:
	DD	$LN11@doOptimize
	DD	$LN39@doOptimize
	DD	$LN38@doOptimize
	DD	$LN37@doOptimize
	DD	$LN1@doOptimize
$LN54@doOptimize:
	DB	0
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	npad	2
$LN61@doOptimize:
	DD	$LN36@doOptimize
	DD	$LN35@doOptimize
	DD	$LN34@doOptimize
	DD	$LN23@doOptimize
	DD	$LN1@doOptimize
$LN55@doOptimize:
	DB	0
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	npad	2
$LN62@doOptimize:
	DD	$LN6@doOptimize
	DD	$LN5@doOptimize
	DD	$LN4@doOptimize
	DD	$LN3@doOptimize
	DD	$LN1@doOptimize
$LN56@doOptimize:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
?doOptimizedConversion@?A0xbce8a349@@YAHABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::doOptimizedConversion
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$TBox@H@Ogre@@QAE@XZ PROC				; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 68   : 		TBox(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$TBox@H@Ogre@@QAE@XZ ENDP				; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@HHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_front$ = 16						; size = 4
_right$ = 20						; size = 4
_bottom$ = 24						; size = 4
_back$ = 28						; size = 4
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z PROC			; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _top$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 71   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z ENDP			; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWidth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getWidth, COMDAT
; _this$ = ecx

; 73   : 		T getWidth() const{ return m_Right-m_Left; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getHeight@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getHeight, COMDAT
; _this$ = ecx

; 74   : 		T getHeight() const{ return m_Bottom-m_Top; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getHeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getDepth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDepth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getDepth, COMDAT
; _this$ = ecx

; 75   : 		T getDepth() const{ return m_Back-m_Front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?getDepth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getDepth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_def$ = 8						; size = 4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z PROC		; Ogre::TBox<int>::contains, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			return (def.m_Left >= m_Left && def.m_Top >= m_Top && def.m_Front >= m_Front &&
; 80   : 				def.m_Right <= m_Right && def.m_Bottom <= m_Bottom && def.m_Back <= m_Back);

	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN3@contains
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN4@contains
$LN3@contains:
	mov	DWORD PTR tv80[ebp], 0
$LN4@contains:
	mov	al, BYTE PTR tv80[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z ENDP		; Ogre::TBox<int>::contains
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelconversions.h
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64698 = -32						; size = 4
_y$64694 = -28						; size = 4
_z$64690 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64690[ebp], edx
	jmp	SHORT $LN9@conversion
$LN8@conversion:
	mov	eax, DWORD PTR _z$64690[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64690[ebp], eax
$LN9@conversion:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64690[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64694[ebp], ecx
	jmp	SHORT $LN6@conversion
$LN5@conversion:
	mov	edx, DWORD PTR _y$64694[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64694[ebp], edx
$LN6@conversion:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64694[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64698[ebp], 0
	jmp	SHORT $LN3@conversion
$LN2@conversion:
	mov	edx, DWORD PTR _x$64698[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64698[ebp], edx
$LN3@conversion:
	mov	eax, DWORD PTR _x$64698[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64698[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64698[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion
$LN1@conversion:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion
$LN4@conversion:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion
$LN10@conversion:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8R8G8B8toA8B8G8R8::pixelConvert, COMDAT

; 105  : 	{

	push	ebp
	mov	ebp, esp

; 106  : 		return ((inp&0x000000FF)<<16)|(inp&0xFF00FF00)|((inp&0x00FF0000)>>16);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16711936				; ff00ff00H
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	or	eax, edx

; 107  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8R8G8B8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64718 = -32						; size = 4
_y$64714 = -28						; size = 4
_z$64710 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64710[ebp], edx
	jmp	SHORT $LN9@conversion@2
$LN8@conversion@2:
	mov	eax, DWORD PTR _z$64710[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64710[ebp], eax
$LN9@conversion@2:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64710[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@2

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64714[ebp], ecx
	jmp	SHORT $LN6@conversion@2
$LN5@conversion@2:
	mov	edx, DWORD PTR _y$64714[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64714[ebp], edx
$LN6@conversion@2:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64714[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@2

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64718[ebp], 0
	jmp	SHORT $LN3@conversion@2
$LN2@conversion@2:
	mov	edx, DWORD PTR _x$64718[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64718[ebp], edx
$LN3@conversion@2:
	mov	eax, DWORD PTR _x$64718[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@2

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64718[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64718[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@2
$LN1@conversion@2:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@2
$LN4@conversion@2:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@2
$LN10@conversion@2:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8R8G8B8toB8G8R8A8::pixelConvert, COMDAT

; 113  : 	{

	push	ebp
	mov	ebp, esp

; 114  : 		return ((inp&0x000000FF)<<24)|((inp&0x0000FF00)<<8)|((inp&0x00FF0000)>>8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 115  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8R8G8B8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toR8G8B8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64738 = -32						; size = 4
_y$64734 = -28						; size = 4
_z$64730 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64730[ebp], edx
	jmp	SHORT $LN9@conversion@3
$LN8@conversion@3:
	mov	eax, DWORD PTR _z$64730[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64730[ebp], eax
$LN9@conversion@3:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64730[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@3

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64734[ebp], ecx
	jmp	SHORT $LN6@conversion@3
$LN5@conversion@3:
	mov	edx, DWORD PTR _y$64734[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64734[ebp], edx
$LN6@conversion@3:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64734[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@3

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64738[ebp], 0
	jmp	SHORT $LN3@conversion@3
$LN2@conversion@3:
	mov	edx, DWORD PTR _x$64738[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64738[ebp], edx
$LN3@conversion@3:
	mov	eax, DWORD PTR _x$64738[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@3

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64738[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8R8G8B8toR8G8B8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64738[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@3
$LN1@conversion@3:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@3
$LN4@conversion@3:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@3
$LN10@conversion@3:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8R8G8B8toR8G8B8A8::pixelConvert, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		return ((inp&0x00FFFFFF)<<8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 16777215				; 00ffffffH
	shl	eax, 8
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 123  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8R8G8B8toR8G8B8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64758 = -32						; size = 4
_y$64754 = -28						; size = 4
_z$64750 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64750[ebp], edx
	jmp	SHORT $LN9@conversion@4
$LN8@conversion@4:
	mov	eax, DWORD PTR _z$64750[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64750[ebp], eax
$LN9@conversion@4:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64750[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@4

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64754[ebp], ecx
	jmp	SHORT $LN6@conversion@4
$LN5@conversion@4:
	mov	edx, DWORD PTR _y$64754[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64754[ebp], edx
$LN6@conversion@4:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64754[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@4

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64758[ebp], 0
	jmp	SHORT $LN3@conversion@4
$LN2@conversion@4:
	mov	edx, DWORD PTR _x$64758[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64758[ebp], edx
$LN3@conversion@4:
	mov	eax, DWORD PTR _x$64758[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@4

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64758[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64758[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@4
$LN1@conversion@4:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@4
$LN4@conversion@4:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@4
$LN10@conversion@4:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8B8G8R8toA8R8G8B8::pixelConvert, COMDAT

; 129  : 	{

	push	ebp
	mov	ebp, esp

; 130  : 		return ((inp&0x000000FF)<<16)|(inp&0xFF00FF00)|((inp&0x00FF0000)>>16);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16711936				; ff00ff00H
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	or	eax, edx

; 131  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8B8G8R8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64778 = -32						; size = 4
_y$64774 = -28						; size = 4
_z$64770 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64770[ebp], edx
	jmp	SHORT $LN9@conversion@5
$LN8@conversion@5:
	mov	eax, DWORD PTR _z$64770[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64770[ebp], eax
$LN9@conversion@5:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64770[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@5

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64774[ebp], ecx
	jmp	SHORT $LN6@conversion@5
$LN5@conversion@5:
	mov	edx, DWORD PTR _y$64774[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64774[ebp], edx
$LN6@conversion@5:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64774[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@5

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64778[ebp], 0
	jmp	SHORT $LN3@conversion@5
$LN2@conversion@5:
	mov	edx, DWORD PTR _x$64778[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64778[ebp], edx
$LN3@conversion@5:
	mov	eax, DWORD PTR _x$64778[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@5

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64778[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64778[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@5
$LN1@conversion@5:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@5
$LN4@conversion@5:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@5
$LN10@conversion@5:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8B8G8R8toB8G8R8A8::pixelConvert, COMDAT

; 137  : 	{

	push	ebp
	mov	ebp, esp

; 138  : 		return ((inp&0x00FFFFFF)<<8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 16777215				; 00ffffffH
	shl	eax, 8
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 139  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8B8G8R8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toR8G8B8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64798 = -32						; size = 4
_y$64794 = -28						; size = 4
_z$64790 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64790[ebp], edx
	jmp	SHORT $LN9@conversion@6
$LN8@conversion@6:
	mov	eax, DWORD PTR _z$64790[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64790[ebp], eax
$LN9@conversion@6:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64790[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@6

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64794[ebp], ecx
	jmp	SHORT $LN6@conversion@6
$LN5@conversion@6:
	mov	edx, DWORD PTR _y$64794[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64794[ebp], edx
$LN6@conversion@6:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64794[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@6

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64798[ebp], 0
	jmp	SHORT $LN3@conversion@6
$LN2@conversion@6:
	mov	edx, DWORD PTR _x$64798[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64798[ebp], edx
$LN3@conversion@6:
	mov	eax, DWORD PTR _x$64798[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@6

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64798[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::A8B8G8R8toR8G8B8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64798[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@6
$LN1@conversion@6:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@6
$LN4@conversion@6:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@6
$LN10@conversion@6:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toR8G8B8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::A8B8G8R8toR8G8B8A8::pixelConvert, COMDAT

; 145  : 	{

	push	ebp
	mov	ebp, esp

; 146  : 		return ((inp&0x000000FF)<<24)|((inp&0x0000FF00)<<8)|((inp&0x00FF0000)>>8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 147  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::A8B8G8R8toR8G8B8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@B8G8R8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64818 = -32						; size = 4
_y$64814 = -28						; size = 4
_z$64810 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64810[ebp], edx
	jmp	SHORT $LN9@conversion@7
$LN8@conversion@7:
	mov	eax, DWORD PTR _z$64810[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64810[ebp], eax
$LN9@conversion@7:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64810[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@7

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64814[ebp], ecx
	jmp	SHORT $LN6@conversion@7
$LN5@conversion@7:
	mov	edx, DWORD PTR _y$64814[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64814[ebp], edx
$LN6@conversion@7:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64814[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@7

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64818[ebp], 0
	jmp	SHORT $LN3@conversion@7
$LN2@conversion@7:
	mov	edx, DWORD PTR _x$64818[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64818[ebp], edx
$LN3@conversion@7:
	mov	eax, DWORD PTR _x$64818[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@7

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64818[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@B8G8R8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64818[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@7
$LN1@conversion@7:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@7
$LN4@conversion@7:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@7
$LN10@conversion@7:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@B8G8R8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@B8G8R8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::B8G8R8A8toA8R8G8B8::pixelConvert, COMDAT

; 153  : 	{

	push	ebp
	mov	ebp, esp

; 154  : 		return ((inp&0x000000FF)<<24)|((inp&0x0000FF00)<<8)|((inp&0x00FF0000)>>8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 155  : 	}

	pop	ebp
	ret	0
?pixelConvert@B8G8R8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::B8G8R8A8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@B8G8R8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64838 = -32						; size = 4
_y$64834 = -28						; size = 4
_z$64830 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64830[ebp], edx
	jmp	SHORT $LN9@conversion@8
$LN8@conversion@8:
	mov	eax, DWORD PTR _z$64830[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64830[ebp], eax
$LN9@conversion@8:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64830[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@8

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64834[ebp], ecx
	jmp	SHORT $LN6@conversion@8
$LN5@conversion@8:
	mov	edx, DWORD PTR _y$64834[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64834[ebp], edx
$LN6@conversion@8:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64834[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@8

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64838[ebp], 0
	jmp	SHORT $LN3@conversion@8
$LN2@conversion@8:
	mov	edx, DWORD PTR _x$64838[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64838[ebp], edx
$LN3@conversion@8:
	mov	eax, DWORD PTR _x$64838[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@8

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64838[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@B8G8R8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64838[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@8
$LN1@conversion@8:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@8
$LN4@conversion@8:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@8
$LN10@conversion@8:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@B8G8R8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@B8G8R8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::B8G8R8A8toA8B8G8R8::pixelConvert, COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp

; 162  : 		return ((inp&0x000000FF)<<24)|((inp&0xFFFFFF00)>>8);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -256				; ffffff00H
	shr	ecx, 8
	or	eax, ecx

; 163  : 	}

	pop	ebp
	ret	0
?pixelConvert@B8G8R8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::B8G8R8A8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@B8G8R8A8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toR8G8B8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64858 = -32						; size = 4
_y$64854 = -28						; size = 4
_z$64850 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64850[ebp], edx
	jmp	SHORT $LN9@conversion@9
$LN8@conversion@9:
	mov	eax, DWORD PTR _z$64850[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64850[ebp], eax
$LN9@conversion@9:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64850[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@9

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64854[ebp], ecx
	jmp	SHORT $LN6@conversion@9
$LN5@conversion@9:
	mov	edx, DWORD PTR _y$64854[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64854[ebp], edx
$LN6@conversion@9:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64854[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@9

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64858[ebp], 0
	jmp	SHORT $LN3@conversion@9
$LN2@conversion@9:
	mov	edx, DWORD PTR _x$64858[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64858[ebp], edx
$LN3@conversion@9:
	mov	eax, DWORD PTR _x$64858[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@9

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64858[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@B8G8R8A8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::B8G8R8A8toR8G8B8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64858[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@9
$LN1@conversion@9:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@9
$LN4@conversion@9:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@9
$LN10@conversion@9:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8A8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toR8G8B8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@B8G8R8A8toR8G8B8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@B8G8R8A8toR8G8B8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::B8G8R8A8toR8G8B8A8::pixelConvert, COMDAT

; 169  : 	{

	push	ebp
	mov	ebp, esp

; 170  : 		return ((inp&0x0000FF00)<<16)|(inp&0x00FF00FF)|((inp&0xFF000000)>>16);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 65280				; 0000ff00H
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711935				; 00ff00ffH
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 16					; 00000010H
	or	eax, edx

; 171  : 	}

	pop	ebp
	ret	0
?pixelConvert@B8G8R8A8toR8G8B8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::B8G8R8A8toR8G8B8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@R8G8B8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64878 = -32						; size = 4
_y$64874 = -28						; size = 4
_z$64870 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64870[ebp], edx
	jmp	SHORT $LN9@conversion@10
$LN8@conversion@10:
	mov	eax, DWORD PTR _z$64870[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64870[ebp], eax
$LN9@conversion@10:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64870[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@10

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64874[ebp], ecx
	jmp	SHORT $LN6@conversion@10
$LN5@conversion@10:
	mov	edx, DWORD PTR _y$64874[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64874[ebp], edx
$LN6@conversion@10:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64874[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@10

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64878[ebp], 0
	jmp	SHORT $LN3@conversion@10
$LN2@conversion@10:
	mov	edx, DWORD PTR _x$64878[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64878[ebp], edx
$LN3@conversion@10:
	mov	eax, DWORD PTR _x$64878[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@10

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64878[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@R8G8B8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64878[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@10
$LN1@conversion@10:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@10
$LN4@conversion@10:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@10
$LN10@conversion@10:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8A8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@R8G8B8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@R8G8B8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::R8G8B8A8toA8R8G8B8::pixelConvert, COMDAT

; 177  : 	{

	push	ebp
	mov	ebp, esp

; 178  : 		return ((inp&0x000000FF)<<24)|((inp&0xFFFFFF00)>>8);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -256				; ffffff00H
	shr	ecx, 8
	or	eax, ecx

; 179  : 	}

	pop	ebp
	ret	0
?pixelConvert@R8G8B8A8toA8R8G8B8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::R8G8B8A8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@R8G8B8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64898 = -32						; size = 4
_y$64894 = -28						; size = 4
_z$64890 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64890[ebp], edx
	jmp	SHORT $LN9@conversion@11
$LN8@conversion@11:
	mov	eax, DWORD PTR _z$64890[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64890[ebp], eax
$LN9@conversion@11:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64890[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@11

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64894[ebp], ecx
	jmp	SHORT $LN6@conversion@11
$LN5@conversion@11:
	mov	edx, DWORD PTR _y$64894[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64894[ebp], edx
$LN6@conversion@11:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64894[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@11

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64898[ebp], 0
	jmp	SHORT $LN3@conversion@11
$LN2@conversion@11:
	mov	edx, DWORD PTR _x$64898[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64898[ebp], edx
$LN3@conversion@11:
	mov	eax, DWORD PTR _x$64898[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@11

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64898[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@R8G8B8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64898[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@11
$LN1@conversion@11:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@11
$LN4@conversion@11:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@11
$LN10@conversion@11:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8A8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@R8G8B8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@R8G8B8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::R8G8B8A8toA8B8G8R8::pixelConvert, COMDAT

; 185  : 	{

	push	ebp
	mov	ebp, esp

; 186  : 		return ((inp&0x000000FF)<<24)|((inp&0x0000FF00)<<8)|((inp&0x00FF0000)>>8)|((inp&0xFF000000)>>24);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 65280				; 0000ff00H
	shl	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	or	eax, ecx

; 187  : 	}

	pop	ebp
	ret	0
?pixelConvert@R8G8B8A8toA8B8G8R8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::R8G8B8A8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@R8G8B8A8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64918 = -32						; size = 4
_y$64914 = -28						; size = 4
_z$64910 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64910[ebp], edx
	jmp	SHORT $LN9@conversion@12
$LN8@conversion@12:
	mov	eax, DWORD PTR _z$64910[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64910[ebp], eax
$LN9@conversion@12:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64910[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@12

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64914[ebp], ecx
	jmp	SHORT $LN6@conversion@12
$LN5@conversion@12:
	mov	edx, DWORD PTR _y$64914[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64914[ebp], edx
$LN6@conversion@12:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64914[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@12

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64918[ebp], 0
	jmp	SHORT $LN3@conversion@12
$LN2@conversion@12:
	mov	edx, DWORD PTR _x$64918[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64918[ebp], edx
$LN3@conversion@12:
	mov	eax, DWORD PTR _x$64918[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@12

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64918[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@R8G8B8A8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::R8G8B8A8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64918[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@12
$LN1@conversion@12:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@12
$LN4@conversion@12:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@12
$LN10@conversion@12:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8A8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8A8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@R8G8B8A8toB8G8R8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@R8G8B8A8toB8G8R8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::R8G8B8A8toB8G8R8A8::pixelConvert, COMDAT

; 193  : 	{

	push	ebp
	mov	ebp, esp

; 194  : 		return ((inp&0x0000FF00)<<16)|(inp&0x00FF00FF)|((inp&0xFF000000)>>16);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 65280				; 0000ff00H
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711935				; 00ff00ffH
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 16					; 00000010H
	or	eax, edx

; 195  : 	}

	pop	ebp
	ret	0
?pixelConvert@R8G8B8A8toB8G8R8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::R8G8B8A8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8B8G8R8toL8@?A0xbce8a349@@SAEI@Z	; `anonymous namespace'::A8B8G8R8toL8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64938 = -32						; size = 4
_y$64934 = -28						; size = 4
_z$64930 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64930[ebp], edx
	jmp	SHORT $LN9@conversion@13
$LN8@conversion@13:
	mov	eax, DWORD PTR _z$64930[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64930[ebp], eax
$LN9@conversion@13:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64930[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@13

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64934[ebp], ecx
	jmp	SHORT $LN6@conversion@13
$LN5@conversion@13:
	mov	edx, DWORD PTR _y$64934[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64934[ebp], edx
$LN6@conversion@13:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64934[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@13

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64938[ebp], 0
	jmp	SHORT $LN3@conversion@13
$LN2@conversion@13:
	mov	edx, DWORD PTR _x$64938[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64938[ebp], edx
$LN3@conversion@13:
	mov	eax, DWORD PTR _x$64938[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@13

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64938[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8B8G8R8toL8@?A0xbce8a349@@SAEI@Z ; `anonymous namespace'::A8B8G8R8toL8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR _x$64938[ebp]
	mov	BYTE PTR [ecx], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@13
$LN1@conversion@13:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@13
$LN4@conversion@13:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstptr$[ebp]
	add	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@13
$LN10@conversion@13:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8B8G8R8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8B8G8R8toL8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8B8G8R8toL8@?A0xbce8a349@@SAEI@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8B8G8R8toL8@?A0xbce8a349@@SAEI@Z PROC	; `anonymous namespace'::A8B8G8R8toL8::pixelConvert, COMDAT

; 201  : 	{

	push	ebp
	mov	ebp, esp

; 202  : 		return (Ogre::uint8)(inp&0x000000FF);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH

; 203  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8B8G8R8toL8@?A0xbce8a349@@SAEI@Z ENDP	; `anonymous namespace'::A8B8G8R8toL8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@L8toA8B8G8R8@?A0xbce8a349@@SAIE@Z	; `anonymous namespace'::L8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64958 = -32						; size = 4
_y$64954 = -28						; size = 4
_z$64950 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64950[ebp], edx
	jmp	SHORT $LN9@conversion@14
$LN8@conversion@14:
	mov	eax, DWORD PTR _z$64950[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64950[ebp], eax
$LN9@conversion@14:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64950[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@14

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64954[ebp], ecx
	jmp	SHORT $LN6@conversion@14
$LN5@conversion@14:
	mov	edx, DWORD PTR _y$64954[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64954[ebp], edx
$LN6@conversion@14:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64954[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@14

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64958[ebp], 0
	jmp	SHORT $LN3@conversion@14
$LN2@conversion@14:
	mov	edx, DWORD PTR _x$64958[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64958[ebp], edx
$LN3@conversion@14:
	mov	eax, DWORD PTR _x$64958[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@14

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR _x$64958[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?pixelConvert@L8toA8B8G8R8@?A0xbce8a349@@SAIE@Z ; `anonymous namespace'::L8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64958[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@14
$LN1@conversion@14:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 67   : 			}

	jmp	SHORT $LN5@conversion@14
$LN4@conversion@14:

; 68   : 			srcptr += srcSliceSkip;

	mov	eax, DWORD PTR _srcptr$[ebp]
	add	eax, DWORD PTR _srcSliceSkip$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@14
$LN10@conversion@14:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UL8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@L8toA8B8G8R8@?A0xbce8a349@@SAIE@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 1
?pixelConvert@L8toA8B8G8R8@?A0xbce8a349@@SAIE@Z PROC	; `anonymous namespace'::L8toA8B8G8R8::pixelConvert, COMDAT

; 209  : 	{

	push	ebp
	mov	ebp, esp

; 210  : 		return 0xFF000000|(((unsigned int)inp)<<0)|(((unsigned int)inp)<<8)|(((unsigned int)inp)<<16);

	movzx	eax, BYTE PTR _inp$[ebp]
	or	eax, -16777216				; ff000000H
	movzx	ecx, BYTE PTR _inp$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movzx	edx, BYTE PTR _inp$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx

; 211  : 	}

	pop	ebp
	ret	0
?pixelConvert@L8toA8B8G8R8@?A0xbce8a349@@SAIE@Z ENDP	; `anonymous namespace'::L8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toL8@?A0xbce8a349@@SAEI@Z	; `anonymous namespace'::A8R8G8B8toL8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64978 = -32						; size = 4
_y$64974 = -28						; size = 4
_z$64970 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64970[ebp], edx
	jmp	SHORT $LN9@conversion@15
$LN8@conversion@15:
	mov	eax, DWORD PTR _z$64970[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64970[ebp], eax
$LN9@conversion@15:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64970[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@15

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64974[ebp], ecx
	jmp	SHORT $LN6@conversion@15
$LN5@conversion@15:
	mov	edx, DWORD PTR _y$64974[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64974[ebp], edx
$LN6@conversion@15:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64974[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@15

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64978[ebp], 0
	jmp	SHORT $LN3@conversion@15
$LN2@conversion@15:
	mov	edx, DWORD PTR _x$64978[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64978[ebp], edx
$LN3@conversion@15:
	mov	eax, DWORD PTR _x$64978[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@15

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$64978[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@A8R8G8B8toL8@?A0xbce8a349@@SAEI@Z ; `anonymous namespace'::A8R8G8B8toL8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR _x$64978[ebp]
	mov	BYTE PTR [ecx], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@15
$LN1@conversion@15:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@15
$LN4@conversion@15:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstptr$[ebp]
	add	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@15
$LN10@conversion@15:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toL8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toL8@?A0xbce8a349@@SAEI@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@A8R8G8B8toL8@?A0xbce8a349@@SAEI@Z PROC	; `anonymous namespace'::A8R8G8B8toL8::pixelConvert, COMDAT

; 217  : 	{

	push	ebp
	mov	ebp, esp

; 218  : 		return (Ogre::uint8)((inp&0x00FF0000)>>16);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H

; 219  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toL8@?A0xbce8a349@@SAEI@Z ENDP	; `anonymous namespace'::A8R8G8B8toL8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@L8toA8R8G8B8@?A0xbce8a349@@SAIE@Z	; `anonymous namespace'::L8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$64998 = -32						; size = 4
_y$64994 = -28						; size = 4
_z$64990 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$64990[ebp], edx
	jmp	SHORT $LN9@conversion@16
$LN8@conversion@16:
	mov	eax, DWORD PTR _z$64990[ebp]
	add	eax, 1
	mov	DWORD PTR _z$64990[ebp], eax
$LN9@conversion@16:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$64990[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@16

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$64994[ebp], ecx
	jmp	SHORT $LN6@conversion@16
$LN5@conversion@16:
	mov	edx, DWORD PTR _y$64994[ebp]
	add	edx, 1
	mov	DWORD PTR _y$64994[ebp], edx
$LN6@conversion@16:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$64994[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@16

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$64998[ebp], 0
	jmp	SHORT $LN3@conversion@16
$LN2@conversion@16:
	mov	edx, DWORD PTR _x$64998[ebp]
	add	edx, 1
	mov	DWORD PTR _x$64998[ebp], edx
$LN3@conversion@16:
	mov	eax, DWORD PTR _x$64998[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@16

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR _x$64998[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?pixelConvert@L8toA8R8G8B8@?A0xbce8a349@@SAIE@Z ; `anonymous namespace'::L8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$64998[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@16
$LN1@conversion@16:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 67   : 			}

	jmp	SHORT $LN5@conversion@16
$LN4@conversion@16:

; 68   : 			srcptr += srcSliceSkip;

	mov	eax, DWORD PTR _srcptr$[ebp]
	add	eax, DWORD PTR _srcSliceSkip$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@16
$LN10@conversion@16:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UL8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@L8toA8R8G8B8@?A0xbce8a349@@SAIE@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 1
?pixelConvert@L8toA8R8G8B8@?A0xbce8a349@@SAIE@Z PROC	; `anonymous namespace'::L8toA8R8G8B8::pixelConvert, COMDAT

; 225  : 	{

	push	ebp
	mov	ebp, esp

; 226  : 		return 0xFF000000|(((unsigned int)inp)<<0)|(((unsigned int)inp)<<8)|(((unsigned int)inp)<<16);

	movzx	eax, BYTE PTR _inp$[ebp]
	or	eax, -16777216				; ff000000H
	movzx	ecx, BYTE PTR _inp$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movzx	edx, BYTE PTR _inp$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx

; 227  : 	}

	pop	ebp
	ret	0
?pixelConvert@L8toA8R8G8B8@?A0xbce8a349@@SAIE@Z ENDP	; `anonymous namespace'::L8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@B8G8R8A8toL8@?A0xbce8a349@@SAEI@Z	; `anonymous namespace'::B8G8R8A8toL8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65018 = -32						; size = 4
_y$65014 = -28						; size = 4
_z$65010 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65010[ebp], edx
	jmp	SHORT $LN9@conversion@17
$LN8@conversion@17:
	mov	eax, DWORD PTR _z$65010[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65010[ebp], eax
$LN9@conversion@17:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65010[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@17

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65014[ebp], ecx
	jmp	SHORT $LN6@conversion@17
$LN5@conversion@17:
	mov	edx, DWORD PTR _y$65014[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65014[ebp], edx
$LN6@conversion@17:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65014[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@17

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65018[ebp], 0
	jmp	SHORT $LN3@conversion@17
$LN2@conversion@17:
	mov	edx, DWORD PTR _x$65018[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65018[ebp], edx
$LN3@conversion@17:
	mov	eax, DWORD PTR _x$65018[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@17

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65018[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@B8G8R8A8toL8@?A0xbce8a349@@SAEI@Z ; `anonymous namespace'::B8G8R8A8toL8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR _x$65018[ebp]
	mov	BYTE PTR [ecx], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@17
$LN1@conversion@17:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@17
$LN4@conversion@17:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstptr$[ebp]
	add	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@17
$LN10@conversion@17:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8A8toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8A8toL8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@B8G8R8A8toL8@?A0xbce8a349@@SAEI@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@B8G8R8A8toL8@?A0xbce8a349@@SAEI@Z PROC	; `anonymous namespace'::B8G8R8A8toL8::pixelConvert, COMDAT

; 233  : 	{

	push	ebp
	mov	ebp, esp

; 234  : 		return (Ogre::uint8)((inp&0x0000FF00)>>8);

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8

; 235  : 	}

	pop	ebp
	ret	0
?pixelConvert@B8G8R8A8toL8@?A0xbce8a349@@SAEI@Z ENDP	; `anonymous namespace'::B8G8R8A8toL8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@L8toB8G8R8A8@?A0xbce8a349@@SAIE@Z	; `anonymous namespace'::L8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65038 = -32						; size = 4
_y$65034 = -28						; size = 4
_z$65030 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65030[ebp], edx
	jmp	SHORT $LN9@conversion@18
$LN8@conversion@18:
	mov	eax, DWORD PTR _z$65030[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65030[ebp], eax
$LN9@conversion@18:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65030[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@18

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65034[ebp], ecx
	jmp	SHORT $LN6@conversion@18
$LN5@conversion@18:
	mov	edx, DWORD PTR _y$65034[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65034[ebp], edx
$LN6@conversion@18:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65034[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@18

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65038[ebp], 0
	jmp	SHORT $LN3@conversion@18
$LN2@conversion@18:
	mov	edx, DWORD PTR _x$65038[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65038[ebp], edx
$LN3@conversion@18:
	mov	eax, DWORD PTR _x$65038[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@18

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR _x$65038[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?pixelConvert@L8toB8G8R8A8@?A0xbce8a349@@SAIE@Z ; `anonymous namespace'::L8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65038[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@18
$LN1@conversion@18:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 67   : 			}

	jmp	SHORT $LN5@conversion@18
$LN4@conversion@18:

; 68   : 			srcptr += srcSliceSkip;

	mov	eax, DWORD PTR _srcptr$[ebp]
	add	eax, DWORD PTR _srcSliceSkip$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@18
$LN10@conversion@18:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UL8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@L8toB8G8R8A8@?A0xbce8a349@@SAIE@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 1
?pixelConvert@L8toB8G8R8A8@?A0xbce8a349@@SAIE@Z PROC	; `anonymous namespace'::L8toB8G8R8A8::pixelConvert, COMDAT

; 241  : 	{

	push	ebp
	mov	ebp, esp

; 242  : 		return 0x000000FF|(((unsigned int)inp)<<8)|(((unsigned int)inp)<<16)|(((unsigned int)inp)<<24);

	movzx	eax, BYTE PTR _inp$[ebp]
	shl	eax, 8
	or	eax, 255				; 000000ffH
	movzx	ecx, BYTE PTR _inp$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _inp$[ebp]
	shl	edx, 24					; 00000018H
	or	eax, edx

; 243  : 	}

	pop	ebp
	ret	0
?pixelConvert@L8toB8G8R8A8@?A0xbce8a349@@SAIE@Z ENDP	; `anonymous namespace'::L8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@L8toL16@?A0xbce8a349@@SAGE@Z	; `anonymous namespace'::L8toL16::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65058 = -32						; size = 4
_y$65054 = -28						; size = 4
_z$65050 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65050[ebp], edx
	jmp	SHORT $LN9@conversion@19
$LN8@conversion@19:
	mov	eax, DWORD PTR _z$65050[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65050[ebp], eax
$LN9@conversion@19:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65050[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@19

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65054[ebp], ecx
	jmp	SHORT $LN6@conversion@19
$LN5@conversion@19:
	mov	edx, DWORD PTR _y$65054[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65054[ebp], edx
$LN6@conversion@19:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65054[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@19

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65058[ebp], 0
	jmp	SHORT $LN3@conversion@19
$LN2@conversion@19:
	mov	edx, DWORD PTR _x$65058[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65058[ebp], edx
$LN3@conversion@19:
	mov	eax, DWORD PTR _x$65058[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@19

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR _x$65058[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?pixelConvert@L8toL16@?A0xbce8a349@@SAGE@Z ; `anonymous namespace'::L8toL16::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65058[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 64   : 				}

	jmp	SHORT $LN2@conversion@19
$LN1@conversion@19:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _dstptr$[ebp], edx

; 67   : 			}

	jmp	SHORT $LN5@conversion@19
$LN4@conversion@19:

; 68   : 			srcptr += srcSliceSkip;

	mov	eax, DWORD PTR _srcptr$[ebp]
	add	eax, DWORD PTR _srcSliceSkip$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@19
$LN10@conversion@19:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UL8toL16@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L8toL16>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@L8toL16@?A0xbce8a349@@SAGE@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 1
?pixelConvert@L8toL16@?A0xbce8a349@@SAGE@Z PROC		; `anonymous namespace'::L8toL16::pixelConvert, COMDAT

; 249  : 	{

	push	ebp
	mov	ebp, esp

; 250  : 		return (Ogre::uint16)((((unsigned int)inp)<<8)|(((unsigned int)inp)));

	movzx	eax, BYTE PTR _inp$[ebp]
	shl	eax, 8
	movzx	ecx, BYTE PTR _inp$[ebp]
	or	eax, ecx

; 251  : 	}

	pop	ebp
	ret	0
?pixelConvert@L8toL16@?A0xbce8a349@@SAGE@Z ENDP		; `anonymous namespace'::L8toL16::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@L16toL8@?A0xbce8a349@@SAEG@Z	; `anonymous namespace'::L16toL8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65078 = -32						; size = 4
_y$65074 = -28						; size = 4
_z$65070 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65070[ebp], edx
	jmp	SHORT $LN9@conversion@20
$LN8@conversion@20:
	mov	eax, DWORD PTR _z$65070[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65070[ebp], eax
$LN9@conversion@20:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65070[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@20

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65074[ebp], ecx
	jmp	SHORT $LN6@conversion@20
$LN5@conversion@20:
	mov	edx, DWORD PTR _y$65074[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65074[ebp], edx
$LN6@conversion@20:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65074[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@20

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65078[ebp], 0
	jmp	SHORT $LN3@conversion@20
$LN2@conversion@20:
	mov	edx, DWORD PTR _x$65078[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65078[ebp], edx
$LN3@conversion@20:
	mov	eax, DWORD PTR _x$65078[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@20

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65078[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	push	eax
	call	?pixelConvert@L16toL8@?A0xbce8a349@@SAEG@Z ; `anonymous namespace'::L16toL8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR _x$65078[ebp]
	mov	BYTE PTR [ecx], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@20
$LN1@conversion@20:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _srcptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@20
$LN4@conversion@20:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstptr$[ebp]
	add	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@20
$LN10@conversion@20:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UL16toL8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::L16toL8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@L16toL8@?A0xbce8a349@@SAEG@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 2
?pixelConvert@L16toL8@?A0xbce8a349@@SAEG@Z PROC		; `anonymous namespace'::L16toL8::pixelConvert, COMDAT

; 257  : 	{

	push	ebp
	mov	ebp, esp

; 258  : 		return (Ogre::uint8)(inp>>8);

	movzx	eax, WORD PTR _inp$[ebp]
	sar	eax, 8

; 259  : 	}

	pop	ebp
	ret	0
?pixelConvert@L16toL8@?A0xbce8a349@@SAEG@Z ENDP		; `anonymous namespace'::L16toL8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@B8G8R8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ; `anonymous namespace'::B8G8R8toR8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
$T70810 = -35						; size = 3
_x$65098 = -32						; size = 4
_y$65094 = -28						; size = 4
_z$65090 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65090[ebp], edx
	jmp	SHORT $LN9@conversion@21
$LN8@conversion@21:
	mov	eax, DWORD PTR _z$65090[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65090[ebp], eax
$LN9@conversion@21:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65090[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@21

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65094[ebp], ecx
	jmp	SHORT $LN6@conversion@21
$LN5@conversion@21:
	mov	edx, DWORD PTR _y$65094[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65094[ebp], edx
$LN6@conversion@21:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65094[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@21

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65098[ebp], 0
	jmp	SHORT $LN3@conversion@21
$LN2@conversion@21:
	mov	edx, DWORD PTR _x$65098[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65098[ebp], edx
$LN3@conversion@21:
	mov	eax, DWORD PTR _x$65098[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@21

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65098[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70810[ebp]
	push	edx
	call	?pixelConvert@B8G8R8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ; `anonymous namespace'::B8G8R8toR8G8B8::pixelConvert
	add	esp, 8
	mov	ecx, DWORD PTR _x$65098[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@21
$LN1@conversion@21:

; 65   : 				srcptr += src.rowPitch;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@21
$LN4@conversion@21:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	imul	eax, 3
	add	eax, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@21
$LN10@conversion@21:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toR8G8B8>::conversion
_TEXT	ENDS
PUBLIC	??0Col3b@?A0xbce8a349@@QAE@III@Z		; `anonymous namespace'::Col3b::Col3b
; Function compile flags: /Odtp
;	COMDAT ?pixelConvert@B8G8R8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_inp$ = 12						; size = 4
?pixelConvert@B8G8R8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z PROC ; `anonymous namespace'::B8G8R8toR8G8B8::pixelConvert, COMDAT

; 273  : 	{

	push	ebp
	mov	ebp, esp

; 274  : 		return Col3b(inp.z, inp.y, inp.x);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Col3b@?A0xbce8a349@@QAE@III@Z	; `anonymous namespace'::Col3b::Col3b
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 275  : 	}  

	pop	ebp
	ret	0
?pixelConvert@B8G8R8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ENDP ; `anonymous namespace'::B8G8R8toR8G8B8::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0Col3b@?A0xbce8a349@@QAE@III@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
??0Col3b@?A0xbce8a349@@QAE@III@Z PROC			; `anonymous namespace'::Col3b::Col3b, COMDAT
; _this$ = ecx

; 86   : x((Ogre::uint8)a), y((Ogre::uint8)b), z((Ogre::uint8)c) { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _a$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _b$[ebp]
	mov	BYTE PTR [edx+1], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx+2], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Col3b@?A0xbce8a349@@QAE@III@Z ENDP			; `anonymous namespace'::Col3b::Col3b
_TEXT	ENDS
PUBLIC	?pixelConvert@R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ; `anonymous namespace'::R8G8B8toB8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
$T70817 = -35						; size = 3
_x$65119 = -32						; size = 4
_y$65115 = -28						; size = 4
_z$65111 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65111[ebp], edx
	jmp	SHORT $LN9@conversion@22
$LN8@conversion@22:
	mov	eax, DWORD PTR _z$65111[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65111[ebp], eax
$LN9@conversion@22:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65111[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@22

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65115[ebp], ecx
	jmp	SHORT $LN6@conversion@22
$LN5@conversion@22:
	mov	edx, DWORD PTR _y$65115[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65115[ebp], edx
$LN6@conversion@22:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65115[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@22

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65119[ebp], 0
	jmp	SHORT $LN3@conversion@22
$LN2@conversion@22:
	mov	edx, DWORD PTR _x$65119[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65119[ebp], edx
$LN3@conversion@22:
	mov	eax, DWORD PTR _x$65119[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@22

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65119[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70817[ebp]
	push	edx
	call	?pixelConvert@R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ; `anonymous namespace'::R8G8B8toB8G8R8::pixelConvert
	add	esp, 8
	mov	ecx, DWORD PTR _x$65119[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	dx, WORD PTR [eax]
	mov	WORD PTR [ecx], dx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx+2], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@22
$LN1@conversion@22:

; 65   : 				srcptr += src.rowPitch;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 66   : 				dstptr += dst.rowPitch;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@22
$LN4@conversion@22:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	imul	eax, 3
	add	eax, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], eax

; 70   : 		}    

	jmp	$LN8@conversion@22
$LN10@conversion@22:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_inp$ = 12						; size = 4
?pixelConvert@R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z PROC ; `anonymous namespace'::R8G8B8toB8G8R8::pixelConvert, COMDAT

; 265  : 	{

	push	ebp
	mov	ebp, esp

; 266  : 		return Col3b(inp.z, inp.y, inp.x);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Col3b@?A0xbce8a349@@QAE@III@Z	; `anonymous namespace'::Col3b::Col3b
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 267  : 	}  

	pop	ebp
	ret	0
?pixelConvert@R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@ABU32@@Z ENDP ; `anonymous namespace'::R8G8B8toB8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0KAM@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2572,16,8,0,24>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65140 = -32						; size = 4
_y$65136 = -28						; size = 4
_z$65132 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65132[ebp], edx
	jmp	SHORT $LN9@conversion@23
$LN8@conversion@23:
	mov	eax, DWORD PTR _z$65132[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65132[ebp], eax
$LN9@conversion@23:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65132[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@23

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65136[ebp], ecx
	jmp	SHORT $LN6@conversion@23
$LN5@conversion@23:
	mov	edx, DWORD PTR _y$65136[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65136[ebp], edx
$LN6@conversion@23:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65136[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@23

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65140[ebp], 0
	jmp	SHORT $LN3@conversion@23
$LN2@conversion@23:
	mov	edx, DWORD PTR _x$65140[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65140[ebp], edx
$LN3@conversion@23:
	mov	eax, DWORD PTR _x$65140[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@23

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65140[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0KAM@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2572,16,8,0,24>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65140[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@23
$LN1@conversion@23:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@23
$LN4@conversion@23:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@23
$LN10@conversion@23:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8R8G8B8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0LAM@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2828,0,8,16,24>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65160 = -32						; size = 4
_y$65156 = -28						; size = 4
_z$65152 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65152[ebp], edx
	jmp	SHORT $LN9@conversion@24
$LN8@conversion@24:
	mov	eax, DWORD PTR _z$65152[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65152[ebp], eax
$LN9@conversion@24:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65152[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@24

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65156[ebp], ecx
	jmp	SHORT $LN6@conversion@24
$LN5@conversion@24:
	mov	edx, DWORD PTR _y$65156[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65156[ebp], edx
$LN6@conversion@24:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65156[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@24

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65160[ebp], 0
	jmp	SHORT $LN3@conversion@24
$LN2@conversion@24:
	mov	edx, DWORD PTR _x$65160[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65160[ebp], edx
$LN3@conversion@24:
	mov	eax, DWORD PTR _x$65160[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@24

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65160[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0LAM@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2828,0,8,16,24>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65160[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@24
$LN1@conversion@24:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@24
$LN4@conversion@24:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@24
$LN10@conversion@24:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8R8G8B8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0KAN@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2573,0,8,16,24>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65180 = -32						; size = 4
_y$65176 = -28						; size = 4
_z$65172 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65172[ebp], edx
	jmp	SHORT $LN9@conversion@25
$LN8@conversion@25:
	mov	eax, DWORD PTR _z$65172[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65172[ebp], eax
$LN9@conversion@25:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65172[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@25

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65176[ebp], ecx
	jmp	SHORT $LN6@conversion@25
$LN5@conversion@25:
	mov	edx, DWORD PTR _y$65176[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65176[ebp], edx
$LN6@conversion@25:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65176[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@25

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65180[ebp], 0
	jmp	SHORT $LN3@conversion@25
$LN2@conversion@25:
	mov	edx, DWORD PTR _x$65180[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65180[ebp], edx
$LN3@conversion@25:
	mov	eax, DWORD PTR _x$65180[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@25

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65180[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0KAN@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2573,0,8,16,24>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65180[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@25
$LN1@conversion@25:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@25
$LN4@conversion@25:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@25
$LN10@conversion@25:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toA8B8G8R8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0LAN@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2829,16,8,0,24>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65200 = -32						; size = 4
_y$65196 = -28						; size = 4
_z$65192 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65192[ebp], edx
	jmp	SHORT $LN9@conversion@26
$LN8@conversion@26:
	mov	eax, DWORD PTR _z$65192[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65192[ebp], eax
$LN9@conversion@26:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65192[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@26

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65196[ebp], ecx
	jmp	SHORT $LN6@conversion@26
$LN5@conversion@26:
	mov	edx, DWORD PTR _y$65196[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65196[ebp], edx
$LN6@conversion@26:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65196[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@26

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65200[ebp], 0
	jmp	SHORT $LN3@conversion@26
$LN2@conversion@26:
	mov	edx, DWORD PTR _x$65200[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65200[ebp], edx
$LN3@conversion@26:
	mov	eax, DWORD PTR _x$65200[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@26

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65200[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0LAN@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2829,16,8,0,24>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65200[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@26
$LN1@conversion@26:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@26
$LN4@conversion@26:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@26
$LN10@conversion@26:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toA8B8G8R8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0KAO@$07$0BA@$0BI@$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2574,8,16,24,0>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65220 = -32						; size = 4
_y$65216 = -28						; size = 4
_z$65212 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65212[ebp], edx
	jmp	SHORT $LN9@conversion@27
$LN8@conversion@27:
	mov	eax, DWORD PTR _z$65212[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65212[ebp], eax
$LN9@conversion@27:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65212[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@27

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65216[ebp], ecx
	jmp	SHORT $LN6@conversion@27
$LN5@conversion@27:
	mov	edx, DWORD PTR _y$65216[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65216[ebp], edx
$LN6@conversion@27:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65216[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@27

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65220[ebp], 0
	jmp	SHORT $LN3@conversion@27
$LN2@conversion@27:
	mov	edx, DWORD PTR _x$65220[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65220[ebp], edx
$LN3@conversion@27:
	mov	eax, DWORD PTR _x$65220[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@27

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65220[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0KAO@$07$0BA@$0BI@$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2574,8,16,24,0>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65220[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@27
$LN1@conversion@27:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@27
$LN4@conversion@27:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@27
$LN10@conversion@27:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UR8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::R8G8B8toB8G8R8A8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@?$Col3btoUint32swizzler@$0LAO@$0BI@$0BA@$07$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2830,24,16,8,0>::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65240 = -32						; size = 4
_y$65236 = -28						; size = 4
_z$65232 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65232[ebp], edx
	jmp	SHORT $LN9@conversion@28
$LN8@conversion@28:
	mov	eax, DWORD PTR _z$65232[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65232[ebp], eax
$LN9@conversion@28:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65232[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@28

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65236[ebp], ecx
	jmp	SHORT $LN6@conversion@28
$LN5@conversion@28:
	mov	edx, DWORD PTR _y$65236[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65236[ebp], edx
$LN6@conversion@28:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65236[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@28

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65240[ebp], 0
	jmp	SHORT $LN3@conversion@28
$LN2@conversion@28:
	mov	edx, DWORD PTR _x$65240[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65240[ebp], edx
$LN3@conversion@28:
	mov	eax, DWORD PTR _x$65240[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@28

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65240[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _srcptr$[ebp]
	push	ecx
	call	?pixelConvert@?$Col3btoUint32swizzler@$0LAO@$0BI@$0BA@$07$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ; `anonymous namespace'::Col3btoUint32swizzler<2830,24,16,8,0>::pixelConvert
	add	esp, 4
	mov	edx, DWORD PTR _x$65240[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@28
$LN1@conversion@28:

; 65   : 				srcptr += src.rowPitch;

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@28
$LN4@conversion@28:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _srcptr$[ebp]
	mov	DWORD PTR _srcptr$[ebp], edx

; 69   : 			dstptr += dstSliceSkip;

	mov	eax, DWORD PTR _dstSliceSkip$[ebp]
	mov	ecx, DWORD PTR _dstptr$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _dstptr$[ebp], edx

; 70   : 		}    

	jmp	$LN8@conversion@28
$LN10@conversion@28:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UB8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::B8G8R8toB8G8R8A8>::conversion
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ; `anonymous namespace'::A8R8G8B8toR8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
$T70834 = -35						; size = 3
_x$65260 = -32						; size = 4
_y$65256 = -28						; size = 4
_z$65252 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65252[ebp], edx
	jmp	SHORT $LN9@conversion@29
$LN8@conversion@29:
	mov	eax, DWORD PTR _z$65252[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65252[ebp], eax
$LN9@conversion@29:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65252[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@29

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65256[ebp], ecx
	jmp	SHORT $LN6@conversion@29
$LN5@conversion@29:
	mov	edx, DWORD PTR _y$65256[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65256[ebp], edx
$LN6@conversion@29:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65256[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@29

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65260[ebp], 0
	jmp	SHORT $LN3@conversion@29
$LN2@conversion@29:
	mov	edx, DWORD PTR _x$65260[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65260[ebp], edx
$LN3@conversion@29:
	mov	eax, DWORD PTR _x$65260[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@29

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65260[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR $T70834[ebp]
	push	ecx
	call	?pixelConvert@A8R8G8B8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ; `anonymous namespace'::A8R8G8B8toR8G8B8::pixelConvert
	add	esp, 8
	mov	edx, DWORD PTR _x$65260[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _dstptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@29
$LN1@conversion@29:

; 65   : 				srcptr += src.rowPitch;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], eax

; 67   : 			}

	jmp	SHORT $LN5@conversion@29
$LN4@conversion@29:

; 68   : 			srcptr += srcSliceSkip;

	mov	ecx, DWORD PTR _srcSliceSkip$[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@29
$LN10@conversion@29:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toR8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toR8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_inp$ = 12						; size = 4
?pixelConvert@A8R8G8B8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@I@Z PROC ; `anonymous namespace'::A8R8G8B8toR8G8B8::pixelConvert, COMDAT

; 302  : 	{

	push	ebp
	mov	ebp, esp

; 303  : 		return Col3b((Ogre::uint8)((inp>>16)&0xFF), (Ogre::uint8)((inp>>8)&0xFF), (Ogre::uint8)((inp>>0)&0xFF));

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _inp$[ebp]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _inp$[ebp]
	shr	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Col3b@?A0xbce8a349@@QAE@III@Z	; `anonymous namespace'::Col3b::Col3b
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 304  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toR8G8B8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ENDP ; `anonymous namespace'::A8R8G8B8toR8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@A8R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ; `anonymous namespace'::A8R8G8B8toB8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
$T70839 = -35						; size = 3
_x$65281 = -32						; size = 4
_y$65277 = -28						; size = 4
_z$65273 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65273[ebp], edx
	jmp	SHORT $LN9@conversion@30
$LN8@conversion@30:
	mov	eax, DWORD PTR _z$65273[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65273[ebp], eax
$LN9@conversion@30:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65273[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@30

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65277[ebp], ecx
	jmp	SHORT $LN6@conversion@30
$LN5@conversion@30:
	mov	edx, DWORD PTR _y$65277[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65277[ebp], edx
$LN6@conversion@30:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65277[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@30

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65281[ebp], 0
	jmp	SHORT $LN3@conversion@30
$LN2@conversion@30:
	mov	edx, DWORD PTR _x$65281[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65281[ebp], edx
$LN3@conversion@30:
	mov	eax, DWORD PTR _x$65281[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@30

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65281[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR $T70839[ebp]
	push	ecx
	call	?pixelConvert@A8R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ; `anonymous namespace'::A8R8G8B8toB8G8R8::pixelConvert
	add	esp, 8
	mov	edx, DWORD PTR _x$65281[ebp]
	imul	edx, 3
	add	edx, DWORD PTR _dstptr$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	al, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], al

; 64   : 				}

	jmp	SHORT $LN2@conversion@30
$LN1@conversion@30:

; 65   : 				srcptr += src.rowPitch;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 66   : 				dstptr += dst.rowPitch;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+32]
	imul	eax, 3
	add	eax, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], eax

; 67   : 			}

	jmp	SHORT $LN5@conversion@30
$LN4@conversion@30:

; 68   : 			srcptr += srcSliceSkip;

	mov	ecx, DWORD PTR _srcSliceSkip$[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 69   : 			dstptr += dstSliceSkip;

	mov	ecx, DWORD PTR _dstSliceSkip$[ebp]
	imul	ecx, 3
	add	ecx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@30
$LN10@conversion@30:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UA8R8G8B8toB8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::A8R8G8B8toB8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@A8R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_inp$ = 12						; size = 4
?pixelConvert@A8R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@I@Z PROC ; `anonymous namespace'::A8R8G8B8toB8G8R8::pixelConvert, COMDAT

; 309  : 	{

	push	ebp
	mov	ebp, esp

; 310  : 		return Col3b((Ogre::uint8)((inp>>0)&0xFF), (Ogre::uint8)((inp>>8)&0xFF), (Ogre::uint8)((inp>>16)&0xFF));

	mov	eax, DWORD PTR _inp$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _inp$[ebp]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Col3b@?A0xbce8a349@@QAE@III@Z	; `anonymous namespace'::Col3b::Col3b
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 311  : 	}

	pop	ebp
	ret	0
?pixelConvert@A8R8G8B8toB8G8R8@?A0xbce8a349@@SA?AUCol3b@2@I@Z ENDP ; `anonymous namespace'::A8R8G8B8toB8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8R8G8B8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65302 = -32						; size = 4
_y$65298 = -28						; size = 4
_z$65294 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65294[ebp], edx
	jmp	SHORT $LN9@conversion@31
$LN8@conversion@31:
	mov	eax, DWORD PTR _z$65294[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65294[ebp], eax
$LN9@conversion@31:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65294[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@31

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65298[ebp], ecx
	jmp	SHORT $LN6@conversion@31
$LN5@conversion@31:
	mov	edx, DWORD PTR _y$65298[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65298[ebp], edx
$LN6@conversion@31:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65298[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@31

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65302[ebp], 0
	jmp	SHORT $LN3@conversion@31
$LN2@conversion@31:
	mov	edx, DWORD PTR _x$65302[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65302[ebp], edx
$LN3@conversion@31:
	mov	eax, DWORD PTR _x$65302[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@31

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65302[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8R8G8B8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65302[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@31
$LN1@conversion@31:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@31
$LN4@conversion@31:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@31
$LN10@conversion@31:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8R8G8B8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8R8G8B8toA8R8G8B8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8R8G8B8toA8R8G8B8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8R8G8B8toA8R8G8B8::pixelConvert, COMDAT

; 319  : 	{

	push	ebp
	mov	ebp, esp

; 320  : 		return inp | 0xFF000000;

	mov	eax, DWORD PTR _inp$[ebp]
	or	eax, -16777216				; ff000000H

; 321  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8R8G8B8toA8R8G8B8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8R8G8B8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65322 = -32						; size = 4
_y$65318 = -28						; size = 4
_z$65314 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65314[ebp], edx
	jmp	SHORT $LN9@conversion@32
$LN8@conversion@32:
	mov	eax, DWORD PTR _z$65314[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65314[ebp], eax
$LN9@conversion@32:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65314[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@32

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65318[ebp], ecx
	jmp	SHORT $LN6@conversion@32
$LN5@conversion@32:
	mov	edx, DWORD PTR _y$65318[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65318[ebp], edx
$LN6@conversion@32:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65318[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@32

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65322[ebp], 0
	jmp	SHORT $LN3@conversion@32
$LN2@conversion@32:
	mov	edx, DWORD PTR _x$65322[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65322[ebp], edx
$LN3@conversion@32:
	mov	eax, DWORD PTR _x$65322[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@32

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65322[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65322[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@32
$LN1@conversion@32:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@32
$LN4@conversion@32:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@32
$LN10@conversion@32:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8R8G8B8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8R8G8B8toA8B8G8R8::pixelConvert, COMDAT

; 326  : 	{

	push	ebp
	mov	ebp, esp

; 327  : 		return ((inp&0x0000FF)<<16)|((inp&0xFF0000)>>16)|(inp&0x00FF00)|0xFF000000;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 65280				; 0000ff00H
	or	eax, edx
	or	eax, -16777216				; ff000000H

; 328  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8R8G8B8toA8B8G8R8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8R8G8B8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65342 = -32						; size = 4
_y$65338 = -28						; size = 4
_z$65334 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65334[ebp], edx
	jmp	SHORT $LN9@conversion@33
$LN8@conversion@33:
	mov	eax, DWORD PTR _z$65334[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65334[ebp], eax
$LN9@conversion@33:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65334[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@33

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65338[ebp], ecx
	jmp	SHORT $LN6@conversion@33
$LN5@conversion@33:
	mov	edx, DWORD PTR _y$65338[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65338[ebp], edx
$LN6@conversion@33:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65338[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@33

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65342[ebp], 0
	jmp	SHORT $LN3@conversion@33
$LN2@conversion@33:
	mov	edx, DWORD PTR _x$65342[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65342[ebp], edx
$LN3@conversion@33:
	mov	eax, DWORD PTR _x$65342[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@33

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65342[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65342[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@33
$LN1@conversion@33:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@33
$LN4@conversion@33:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@33
$LN10@conversion@33:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8R8G8B8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8R8G8B8toB8G8R8A8::pixelConvert, COMDAT

; 333  : 	{

	push	ebp
	mov	ebp, esp

; 334  : 		return ((inp&0x0000FF)<<24)|((inp&0xFF0000)>>8)|((inp&0x00FF00)<<8)|0x000000FF;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	eax, edx
	or	eax, 255				; 000000ffH

; 335  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8R8G8B8toB8G8R8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8R8G8B8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toR8G8B8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65362 = -32						; size = 4
_y$65358 = -28						; size = 4
_z$65354 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65354[ebp], edx
	jmp	SHORT $LN9@conversion@34
$LN8@conversion@34:
	mov	eax, DWORD PTR _z$65354[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65354[ebp], eax
$LN9@conversion@34:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65354[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@34

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65358[ebp], ecx
	jmp	SHORT $LN6@conversion@34
$LN5@conversion@34:
	mov	edx, DWORD PTR _y$65358[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65358[ebp], edx
$LN6@conversion@34:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65358[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@34

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65362[ebp], 0
	jmp	SHORT $LN3@conversion@34
$LN2@conversion@34:
	mov	edx, DWORD PTR _x$65362[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65362[ebp], edx
$LN3@conversion@34:
	mov	eax, DWORD PTR _x$65362[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@34

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65362[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8R8G8B8toR8G8B8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65362[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@34
$LN1@conversion@34:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@34
$LN4@conversion@34:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@34
$LN10@conversion@34:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8R8G8B8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8R8G8B8toR8G8B8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8R8G8B8toR8G8B8A8::pixelConvert, COMDAT

; 340  : 	{

	push	ebp
	mov	ebp, esp

; 341  : 		return ((inp&0xFFFFFF)<<8)|0x000000FF;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 16777215				; 00ffffffH
	shl	eax, 8
	or	eax, 255				; 000000ffH

; 342  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8R8G8B8toR8G8B8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8R8G8B8toR8G8B8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toA8R8G8B8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65382 = -32						; size = 4
_y$65378 = -28						; size = 4
_z$65374 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65374[ebp], edx
	jmp	SHORT $LN9@conversion@35
$LN8@conversion@35:
	mov	eax, DWORD PTR _z$65374[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65374[ebp], eax
$LN9@conversion@35:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65374[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@35

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65378[ebp], ecx
	jmp	SHORT $LN6@conversion@35
$LN5@conversion@35:
	mov	edx, DWORD PTR _y$65378[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65378[ebp], edx
$LN6@conversion@35:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65378[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@35

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65382[ebp], 0
	jmp	SHORT $LN3@conversion@35
$LN2@conversion@35:
	mov	edx, DWORD PTR _x$65382[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65382[ebp], edx
$LN3@conversion@35:
	mov	eax, DWORD PTR _x$65382[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@35

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65382[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toA8R8G8B8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65382[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@35
$LN1@conversion@35:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@35
$LN4@conversion@35:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@35
$LN10@conversion@35:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8B8G8R8toA8R8G8B8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8R8G8B8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8B8G8R8toA8R8G8B8::pixelConvert, COMDAT

; 349  : 	{

	push	ebp
	mov	ebp, esp

; 350  : 		return ((inp&0x0000FF)<<16)|((inp&0xFF0000)>>16)|(inp&0x00FF00)|0xFF000000;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 65280				; 0000ff00H
	or	eax, edx
	or	eax, -16777216				; ff000000H

; 351  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8B8G8R8toA8R8G8B8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8B8G8R8toA8R8G8B8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8B8G8R8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toA8B8G8R8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65402 = -32						; size = 4
_y$65398 = -28						; size = 4
_z$65394 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65394[ebp], edx
	jmp	SHORT $LN9@conversion@36
$LN8@conversion@36:
	mov	eax, DWORD PTR _z$65394[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65394[ebp], eax
$LN9@conversion@36:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65394[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@36

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65398[ebp], ecx
	jmp	SHORT $LN6@conversion@36
$LN5@conversion@36:
	mov	edx, DWORD PTR _y$65398[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65398[ebp], edx
$LN6@conversion@36:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65398[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@36

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65402[ebp], 0
	jmp	SHORT $LN3@conversion@36
$LN2@conversion@36:
	mov	edx, DWORD PTR _x$65402[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65402[ebp], edx
$LN3@conversion@36:
	mov	eax, DWORD PTR _x$65402[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@36

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65402[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8B8G8R8toA8B8G8R8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toA8B8G8R8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65402[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@36
$LN1@conversion@36:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@36
$LN4@conversion@36:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@36
$LN10@conversion@36:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8B8G8R8toA8B8G8R8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toA8B8G8R8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8B8G8R8toA8B8G8R8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8B8G8R8toA8B8G8R8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8B8G8R8toA8B8G8R8::pixelConvert, COMDAT

; 356  : 	{

	push	ebp
	mov	ebp, esp

; 357  : 		return inp | 0xFF000000;

	mov	eax, DWORD PTR _inp$[ebp]
	or	eax, -16777216				; ff000000H

; 358  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8B8G8R8toA8B8G8R8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8B8G8R8toA8B8G8R8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toB8G8R8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65422 = -32						; size = 4
_y$65418 = -28						; size = 4
_z$65414 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65414[ebp], edx
	jmp	SHORT $LN9@conversion@37
$LN8@conversion@37:
	mov	eax, DWORD PTR _z$65414[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65414[ebp], eax
$LN9@conversion@37:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65414[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@37

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65418[ebp], ecx
	jmp	SHORT $LN6@conversion@37
$LN5@conversion@37:
	mov	edx, DWORD PTR _y$65418[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65418[ebp], edx
$LN6@conversion@37:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65418[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@37

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65422[ebp], 0
	jmp	SHORT $LN3@conversion@37
$LN2@conversion@37:
	mov	edx, DWORD PTR _x$65422[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65422[ebp], edx
$LN3@conversion@37:
	mov	eax, DWORD PTR _x$65422[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@37

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65422[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toB8G8R8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65422[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@37
$LN1@conversion@37:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@37
$LN4@conversion@37:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@37
$LN10@conversion@37:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8B8G8R8toB8G8R8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toB8G8R8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8B8G8R8toB8G8R8A8::pixelConvert, COMDAT

; 363  : 	{

	push	ebp
	mov	ebp, esp

; 364  : 		return ((inp&0xFFFFFF)<<8)|0x000000FF;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 16777215				; 00ffffffH
	shl	eax, 8
	or	eax, 255				; 000000ffH

; 365  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8B8G8R8toB8G8R8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8B8G8R8toB8G8R8A8::pixelConvert
_TEXT	ENDS
PUBLIC	?pixelConvert@X8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toR8G8B8A8::pixelConvert
; Function compile flags: /Odtp
;	COMDAT ?conversion@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z
_TEXT	SEGMENT
_x$65442 = -32						; size = 4
_y$65438 = -28						; size = 4
_z$65434 = -24						; size = 4
_k$ = -20						; size = 4
_srcptr$ = -16						; size = 4
_srcSliceSkip$ = -12					; size = 4
_dstptr$ = -8						; size = 4
_dstSliceSkip$ = -4					; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?conversion@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z PROC ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::conversion, COMDAT

; 51   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 52   : 		typename U::SrcType *srcptr = static_cast<typename U::SrcType*>(src.data);

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 53   : 		typename U::DstType *dstptr = static_cast<typename U::DstType*>(dst.data);

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _dstptr$[ebp], eax

; 54   : 		const size_t srcSliceSkip = src.getSliceSkip();

	mov	ecx, DWORD PTR _src$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _srcSliceSkip$[ebp], eax

; 55   : 		const size_t dstSliceSkip = dst.getSliceSkip();

	mov	ecx, DWORD PTR _dst$[ebp]
	call	?getSliceSkip@PixelBox@Ogre@@QBEIXZ	; Ogre::PixelBox::getSliceSkip
	mov	DWORD PTR _dstSliceSkip$[ebp], eax

; 56   : 		const int k = src.m_Right - src.m_Left;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _k$[ebp], eax

; 57   : 		for(int z=src.m_Front; z<src.m_Back; z++) 

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _z$65434[ebp], edx
	jmp	SHORT $LN9@conversion@38
$LN8@conversion@38:
	mov	eax, DWORD PTR _z$65434[ebp]
	add	eax, 1
	mov	DWORD PTR _z$65434[ebp], eax
$LN9@conversion@38:
	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR _z$65434[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jge	$LN10@conversion@38

; 58   : 		{
; 59   : 			for(int y=src.m_Top; y<src.m_Bottom; y++)

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _y$65438[ebp], ecx
	jmp	SHORT $LN6@conversion@38
$LN5@conversion@38:
	mov	edx, DWORD PTR _y$65438[ebp]
	add	edx, 1
	mov	DWORD PTR _y$65438[ebp], edx
$LN6@conversion@38:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _y$65438[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN4@conversion@38

; 60   : 			{
; 61   : 				for(int x=0; x<k; x++)

	mov	DWORD PTR _x$65442[ebp], 0
	jmp	SHORT $LN3@conversion@38
$LN2@conversion@38:
	mov	edx, DWORD PTR _x$65442[ebp]
	add	edx, 1
	mov	DWORD PTR _x$65442[ebp], edx
$LN3@conversion@38:
	mov	eax, DWORD PTR _x$65442[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jge	SHORT $LN1@conversion@38

; 62   : 				{
; 63   : 					dstptr[x] = U::pixelConvert(srcptr[x]);

	mov	ecx, DWORD PTR _x$65442[ebp]
	mov	edx, DWORD PTR _srcptr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?pixelConvert@X8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ; `anonymous namespace'::X8B8G8R8toR8G8B8A8::pixelConvert
	add	esp, 4
	mov	ecx, DWORD PTR _x$65442[ebp]
	mov	edx, DWORD PTR _dstptr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 64   : 				}

	jmp	SHORT $LN2@conversion@38
$LN1@conversion@38:

; 65   : 				srcptr += src.rowPitch;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _srcptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _srcptr$[ebp], eax

; 66   : 				dstptr += dst.rowPitch;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 67   : 			}

	jmp	SHORT $LN5@conversion@38
$LN4@conversion@38:

; 68   : 			srcptr += srcSliceSkip;

	mov	edx, DWORD PTR _srcSliceSkip$[ebp]
	mov	eax, DWORD PTR _srcptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _srcptr$[ebp], ecx

; 69   : 			dstptr += dstSliceSkip;

	mov	edx, DWORD PTR _dstSliceSkip$[ebp]
	mov	eax, DWORD PTR _dstptr$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _dstptr$[ebp], ecx

; 70   : 		}    

	jmp	$LN8@conversion@38
$LN10@conversion@38:

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?conversion@?$PixelBoxConverter@UX8B8G8R8toR8G8B8A8@?A0xbce8a349@@@?A0xbce8a349@@SAXABVPixelBox@Ogre@@0@Z ENDP ; `anonymous namespace'::PixelBoxConverter<`anonymous namespace'::X8B8G8R8toR8G8B8A8>::conversion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@X8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@X8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z PROC ; `anonymous namespace'::X8B8G8R8toR8G8B8A8::pixelConvert, COMDAT

; 370  : 	{

	push	ebp
	mov	ebp, esp

; 371  : 		return ((inp&0x0000FF)<<24)|((inp&0xFF0000)>>8)|((inp&0x00FF00)<<8)|0x000000FF;

	mov	eax, DWORD PTR _inp$[ebp]
	and	eax, 255				; 000000ffH
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _inp$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 8
	or	eax, ecx
	mov	edx, DWORD PTR _inp$[ebp]
	and	edx, 65280				; 0000ff00H
	shl	edx, 8
	or	eax, edx
	or	eax, 255				; 000000ffH

; 372  : 	}

	pop	ebp
	ret	0
?pixelConvert@X8B8G8R8toR8G8B8A8@?A0xbce8a349@@SAII@Z ENDP ; `anonymous namespace'::X8B8G8R8toR8G8B8A8::pixelConvert
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T70877 = -14						; size = 1
$T70876 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 228  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T70876[ebp]
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	push	eax
	lea	eax, DWORD PTR $T70877[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 229  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
__ehhandler$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T70887 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::insert, COMDAT
; _this$ = ecx

; 270  : 		{	// insert a {key, mapped} value

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 271  : 		return (_Mybase::insert(_Val).first);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70887[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 272  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$multimap@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::multimap<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::insert
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tidy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end
; Function compile flags: /Odtp
;	COMDAT ?rbegin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T70899 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?rbegin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rbegin, COMDAT
; _this$ = ecx

; 580  : 		{	// return iterator for beginning of reversed mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 		return (reverse_iterator(end()));

	lea	eax, DWORD PTR $T70899[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 582  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?rbegin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rbegin
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
; Function compile flags: /Odtp
;	COMDAT ?rend@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T70902 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?rend@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rend, COMDAT
; _this$ = ecx

; 590  : 		{	// return iterator for end of reversed mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		return (reverse_iterator(begin()));

	lea	eax, DWORD PTR $T70902[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 592  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?rend@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::rend
_TEXT	ENDS
PUBLIC	??E?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAEAAV01@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator++
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??E?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::operator++, COMDAT
; _this$ = ecx

; 2176 : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2177 : 		++*((_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAEAAV01@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator++

; 2178 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 2179 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator*
; Function compile flags: /Odtp
;	COMDAT ??C?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEPAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEPAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator->, COMDAT
; _this$ = ecx

; 1940 : 		{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1941 : 		return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator*

; 1942 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??C?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEPAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator->
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::~_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
__ehhandler$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::~_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelconversions.h
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0KAM@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0KAM@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2572,16,8,0,24>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 16					; 00000010H
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0KAM@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2572,16,8,0,24>::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0LAM@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0LAM@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2828,0,8,16,24>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	shl	eax, 16					; 00000010H
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0LAM@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2828,0,8,16,24>::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0KAN@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0KAN@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2573,0,8,16,24>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	shl	eax, 16					; 00000010H
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0KAN@$0A@$07$0BA@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2573,0,8,16,24>::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0LAN@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0LAN@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2829,16,8,0,24>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	or	eax, -16777216				; ff000000H
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 8
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 16					; 00000010H
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0LAN@$0BA@$07$0A@$0BI@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2829,16,8,0,24>::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0KAO@$07$0BA@$0BI@$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0KAO@$07$0BA@$0BI@$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2574,8,16,24,0>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	shl	eax, 24					; 00000018H
	or	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 8
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0KAO@$07$0BA@$0BI@$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2574,8,16,24,0>::pixelConvert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pixelConvert@?$Col3btoUint32swizzler@$0LAO@$0BI@$0BA@$07$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z
_TEXT	SEGMENT
_inp$ = 8						; size = 4
?pixelConvert@?$Col3btoUint32swizzler@$0LAO@$0BI@$0BA@$07$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z PROC ; `anonymous namespace'::Col3btoUint32swizzler<2830,24,16,8,0>::pixelConvert, COMDAT

; 283  : 	{

	push	ebp
	mov	ebp, esp

; 284  : #if OGRE_ENDIAN == OGRE_ENDIAN_BIG
; 285  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<xshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<zshift);
; 286  : #else
; 287  : 		return (0xFF<<ashift) | (((unsigned int)inp.x)<<zshift) | (((unsigned int)inp.y)<<yshift) | (((unsigned int)inp.z)<<xshift);

	mov	eax, DWORD PTR _inp$[ebp]
	movzx	eax, BYTE PTR [eax]
	shl	eax, 8
	or	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _inp$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	shl	edx, 24					; 00000018H
	or	eax, edx

; 288  : #endif
; 289  : 	}

	pop	ebp
	ret	0
?pixelConvert@?$Col3btoUint32swizzler@$0LAO@$0BI@$0BA@$07$0A@@?A0xbce8a349@@SAIABUCol3b@2@@Z ENDP ; `anonymous namespace'::Col3btoUint32swizzler<2830,24,16,8,0>::pixelConvert
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T70957 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T70957[ebp], esp
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
; Function compile flags: /Odtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
PUBLIC	?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Key
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
tv90 = -76						; size = 4
_this$ = -72						; size = 4
$T70980 = -65						; size = 1
$T70979 = -64						; size = 8
$T70978 = -53						; size = 1
$T70977 = -52						; size = 8
$T70976 = -41						; size = 1
$T70975 = -40						; size = 8
$T70974 = -32						; size = 8
$T70973 = -21						; size = 1
__Where$66578 = -20					; size = 8
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Trynode$[ebp], eax

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1
$LN10@insert:

; 634  : 		while (!_Isnil(_Trynode))

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	mov	BYTE PTR __Addleft$[ebp], al

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	edx, DWORD PTR __Trynode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], eax
$LN14@insert:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], ecx

; 640  : 			}

	jmp	SHORT $LN10@insert
$LN9@insert:

; 641  : 
; 642  : 		if (this->_Multi)

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN8@insert

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T70973[ebp], 1
	lea	eax, DWORD PTR $T70973[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70974[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 644  : 		else

	jmp	$LN11@insert
$LN8@insert:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$66578[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator

; 647  : 			if (!_Addleft)

	movzx	ecx, BYTE PTR __Addleft$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@insert
	jmp	SHORT $LN5@insert
$LN6@insert:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	lea	edx, DWORD PTR $T70975[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$66578[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T70976[ebp], 1
	lea	ecx, DWORD PTR $T70976[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T70977[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 651  : 			else

	jmp	SHORT $LN5@insert
$LN4@insert:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$66578[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--
$LN5@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$66578[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T70978[ebp], 1
	lea	ecx, DWORD PTR $T70978[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Addleft$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T70979[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert

; 657  : 			else

	jmp	SHORT $LN11@insert
$LN2@insert:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T70980[ebp], 0
	lea	eax, DWORD PTR $T70980[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$66578[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T70987 = -40						; size = 8
$T70986 = -32						; size = 8
$T70985 = -24						; size = 8
$T70984 = -16						; size = 8
$T70983 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T70984[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T70983[ebp], ecx
	mov	DWORD PTR $T70983[ebp+4], edx
	lea	eax, DWORD PTR $T70986[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T70985[ebp], ecx
	mov	DWORD PTR $T70985[ebp+4], edx
	mov	eax, DWORD PTR $T70983[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T70983[ebp]
	push	ecx
	mov	edx, DWORD PTR $T70985[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T70985[ebp]
	push	eax
	lea	ecx, DWORD PTR $T70987[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tidy
_TEXT	ENDS
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??0?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 8
??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z PROC ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>, COMDAT
; _this$ = ecx

; 2145 : 		{	// construct wrapped iterator from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >

; 2146 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ENDP ; std::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>::reverse_iterator<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??D?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
??D?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator*, COMDAT
; _this$ = ecx

; 1934 : 		{	// return designated value

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1935 : 		_RanIt _Tmp = current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 1936 : 		return (*--_Tmp);

	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--
	mov	ecx, eax
	call	??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator*

; 1937 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@XZ ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAEAAV01@XZ PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator++, COMDAT
; _this$ = ecx

; 1945 : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1946 : 		--current;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--

; 1947 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 1948 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAEAAV01@XZ ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::operator++
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 45					; 0000002dH

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Myval
; Function compile flags: /Odtp
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Key, COMDAT

; 161  : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Myval
	add	esp, 4
	push	eax
	call	?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn
	add	esp, 4

; 163  : 		}

	pop	ebp
	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Key
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T71022 = -32						; size = 8
$T71021 = -24						; size = 8
$T71020 = -16						; size = 8
$T71019 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T71019[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T71020[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T71021[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T71022[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Init
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::max_size
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T71028 = -88						; size = 28
$T71027 = -60						; size = 40
__Pnode$66878 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::max_size
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+28]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T71028[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T71028[ebp]
	push	edx
	lea	ecx, DWORD PTR $T71027[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T71027[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T71028[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 1194 : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$66878[ebp], edx
$LN10@Insert:
	mov	eax, DWORD PTR __Pnode$66878[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	$LN9@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	eax, DWORD PTR __Pnode$66878[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66878[ebp], ecx

; 1222 : 					}
; 1223 : 				else

	jmp	$LN6@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66878[ebp], eax

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66878[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	$LN4@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66878[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$66878[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66878[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN10@Insert
$LN9@Insert:

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T71028[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Insert
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2logic_error@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T71096 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T71096[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn, COMDAT

; 64   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 66   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@SAABIABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Kfn
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 142  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator*, COMDAT
; _this$ = ecx

; 464  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator*

; 466  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator--
; Function compile flags: /Odtp
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator--

; 489  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 490  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator
$LN1@operator:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 8
??0?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >, COMDAT
; _this$ = ecx

; 1918 : 		{	// construct wrapped iterator from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Right$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 1919 : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QAE@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@@Z ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+8], al

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,bool>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 44					; 0000002cH

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T71149 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T71149[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::max_size, COMDAT
; _this$ = ecx

; 605  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::max_size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::destroy
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Min
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T71155 = -96						; size = 28
$T71154 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@2

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T71155[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T71155[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T71154[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T71154[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T71155[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@2:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@2

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@2
$LN39@erase@2:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@2

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@2
$LN37@erase@2:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@2:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@2

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@2

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@2:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@2

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@2
$LN33@erase@2:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@2

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@2
$LN31@erase@2:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@2:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@2

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@2
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@2
$LN43@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@2:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@2

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@2
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@2
$LN45@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@2:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@2
$LN35@erase@2:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@2

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@2
$LN26@erase@2:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@2

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@2:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@2:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@2

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@2
$LN23@erase@2:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@2

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@2
$LN21@erase@2:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@2:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@2:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@2

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@2
$LN17@erase@2:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@2
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@2

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@2

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@2

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@2:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@2

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@2
$LN13@erase@2:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@2
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@2

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@2
$LN11@erase@2:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@2

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@2:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@2
$LN12@erase@2:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@2
$LN15@erase@2:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@2

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@2:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@2

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@2
$LN6@erase@2:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@2
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@2

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@2
$LN4@erase@2:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@2

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@2:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@2
$LN8@erase@2:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@2
$LN16@erase@2:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@2:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@2

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@2:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@2:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T71155[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::erase
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1out_of_range@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1out_of_range@std@@UAE@XZ$0
__ehfuncinfo$??1out_of_range@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1out_of_range@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1out_of_range@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1out_of_range@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1out_of_range@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Rrotate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T71208 = -36						; size = 4
$T71207 = -32						; size = 4
$T71206 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T71206[ebp], 0
	lea	eax, DWORD PTR $T71206[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T71207[ebp], 0
	lea	eax, DWORD PTR $T71207[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T71208[ebp], 0
	lea	eax, DWORD PTR $T71208[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy
$LN2@Buynode:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::destroy
$LN1@Buynode:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::_Node
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T71225 = -28						; size = 4
$T71224 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	48					; 00000030H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T71225[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T71225[ebp], 0
	je	SHORT $LN4@Buynode@2
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T71225[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T71224[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T71225[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Buynode
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T71248 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T71248[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_ptr<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Bidit@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 249  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@2:

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Myval
	add	esp, 4

; 265  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBEABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Dec
; Function compile flags: /Odtp
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			_Dec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 289  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>::_Bidit<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67244 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$67244[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$67244[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$67244[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$67244[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$67244[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67244[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Min
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T71288 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T71288[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 134217727	; 07ffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67303 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@Dec
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN10@Dec:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 336  :    				if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@Dec:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}

	jmp	$LN11@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Max
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 352  : 			else

	jmp	SHORT $LN11@Dec
$LN4@Dec:

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67303[ebp], ecx
	mov	edx, DWORD PTR __Pnode$67303[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Dec
	mov	ecx, DWORD PTR __Pnode$67303[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$67303[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN11@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$67303[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN11@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0
__ehfuncinfo$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+44], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+45], 0

; 39   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z$0
__ehfuncinfo$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU01@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T71330 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T71330[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
__ehhandler$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67341 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67341[ebp], edx
	mov	eax, DWORD PTR __Pnode$67341[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$67341[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$67341[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$67341[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T71344 = -24						; size = 4
$T71343 = -20						; size = 4
$T71342 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T71344[ebp], eax
	mov	ecx, DWORD PTR $T71344[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T71343[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T71343[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T71343[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T71342[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T71342[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T71344[ebp]
	push	eax
	mov	ecx, DWORD PTR $T71343[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
_TEXT	ENDS
PUBLIC	??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__ehfuncinfo$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T71366 = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 28
??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::make_pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 133  : 	{	// return pair composed from arguments

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T71366[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 134  : 	return (pair<_Ty1, _Ty2>(_Val1, _Val2));

	lea	eax, DWORD PTR __Val2$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Val1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	edx, DWORD PTR $T71366[ebp]
	or	edx, 1
	mov	DWORD PTR $T71366[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Val2$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 135  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:
	lea	ecx, DWORD PTR __Val2$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$1:
	mov	eax, DWORD PTR $T71366[ebp]
	and	eax, 1
	je	$LN5@make_pair
	and	DWORD PTR $T71366[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
$LN5@make_pair:
	ret	0
__ehhandler$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$make_pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::make_pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0
__ehfuncinfo$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 57   : 		{	// construct from compatible pair

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 58   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABU?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > ><unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?8Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ; std::operator==<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$?9Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z PROC ; std::operator!=<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>, COMDAT

; 2256 : 	{	// test for reverse_iterator inequality

	push	ebp
	mov	ebp, esp

; 2257 : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ; std::operator==<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
	add	esp, 8
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 2258 : 	}

	pop	ebp
	ret	0
??$?9Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ENDP ; std::operator!=<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$67870 = -1					; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$67870[ebp], dl

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR __Tmp$67870[ebp]
	mov	BYTE PTR [eax], cl
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T71395 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T71395[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T71395[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 48					; 00000030H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@22
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@22:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEPAXI@Z

; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T71420 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T71420[ebp], eax
	cmp	DWORD PTR $T71420[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T71420[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T71420[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T71427 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T71427[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T71427[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::~_Node
; Function compile flags: /Odtp
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@23
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@23:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::_Node::~_Node
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR __Val2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 51   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::pair<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Equal@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE_NABV01@@Z ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Equal<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$?8Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z PROC ; std::operator==<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>, COMDAT

; 2248 : 	{	// test for reverse_iterator equality

	push	ebp
	mov	ebp, esp

; 2249 : 	return (_Left._Equal(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??$_Equal@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE_NABV01@@Z ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Equal<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >

; 2250 : 	}

	pop	ebp
	ret	0
??$?8Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@V012@@std@@YA_NABV?$reverse_iterator@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@@0@0@Z ENDP ; std::operator==<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator>
_TEXT	ENDS
PUBLIC	?base@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::base
; Function compile flags: /Odtp
;	COMDAT ??$_Equal@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T71461 = -8						; size = 8
__Right$ = 8						; size = 4
??$_Equal@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE_NABV01@@Z PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Equal<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >, COMDAT
; _this$ = ecx

; 1972 : 		bool __CLR_OR_THIS_CALL _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1973 : 		{	// test for iterator equality
; 1974 : 		return (current == _Right.base());

	lea	eax, DWORD PTR $T71461[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?base@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::base
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::const_iterator::operator==

; 1975 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$_Equal@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE_NABV01@@Z ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::_Equal<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?base@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?base@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ PROC ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::base, COMDAT
; _this$ = ecx

; 1929 : 		{	// return wrapped iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1930 : 		return (current);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1931 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?base@?$_Revranit@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@std@@U?$iterator@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@HPAU32@AAU32@@3@@std@@QBE?AViterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$00@std@@@2@XZ ENDP ; std::_Revranit<std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,1> >::iterator,std::iterator<std::bidirectional_iterator_tag,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,int,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > *,std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > &> >::base
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG7678	DB	'AABB', 00H
	ORG $+3
$SG7692	DB	'NPOL', 00H
	ORG $+3
$SG7693	DB	'NEDG', 00H
	ORG $+3
$SG7694	DB	'PNTS', 00H
	ORG $+3
$SG7698	DB	'NODS', 00H
	ORG $+3
$SG7717	DB	'LEFS', 00H
CONST	ENDS
PUBLIC	?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ; ozcollide::AABBTreePoly::loadBinary
PUBLIC	?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z ; ozcollide::AABBTreePoly::loadBinary
EXTRN	?close@DataIn@ozcollide@@QAE_NXZ:PROC		; ozcollide::DataIn::close
EXTRN	??1DataIn@ozcollide@@UAE@XZ:PROC		; ozcollide::DataIn::~DataIn
EXTRN	?open@DataIn@ozcollide@@QAE_NPBD@Z:PROC		; ozcollide::DataIn::open
EXTRN	??0DataIn@ozcollide@@QAE@XZ:PROC		; ozcollide::DataIn::DataIn
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z$0
__ehfuncinfo$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtreepoly_io.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T8424 = -56						; size = 4
$T8423 = -52						; size = 4
$T8422 = -48						; size = 4
_err$ = -44						; size = 4
_file$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
__filename$ = 8						; size = 4
__tree$ = 12						; size = 4
?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z PROC ; ozcollide::AABBTreePoly::loadBinary

; 6    : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 7    : 	DataIn file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0DataIn@ozcollide@@QAE@XZ		; ozcollide::DataIn::DataIn
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 8    : 	ERR err;
; 9    : 
; 10   : 	if (!file.open(_filename))

	mov	eax, DWORD PTR __filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?open@DataIn@ozcollide@@QAE_NPBD@Z	; ozcollide::DataIn::open
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@loadBinary

; 11   : 		return ERR_CANNOT_OPEN;

	mov	DWORD PTR $T8422[ebp], 17		; 00000011H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T8422[ebp]
	jmp	SHORT $LN3@loadBinary
$LN2@loadBinary:

; 12   : 
; 13   : 	err  = loadBinary(file, _tree);

	mov	edx, DWORD PTR __tree$[ebp]
	push	edx
	lea	eax, DWORD PTR _file$[ebp]
	push	eax
	call	?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ; ozcollide::AABBTreePoly::loadBinary
	add	esp, 8
	mov	DWORD PTR _err$[ebp], eax

; 14   : 	if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN1@loadBinary

; 15   : 		return err;

	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR $T8423[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T8423[ebp]
	jmp	SHORT $LN3@loadBinary
$LN1@loadBinary:

; 16   : 
; 17   : 	file.close();

	lea	ecx, DWORD PTR _file$[ebp]
	call	?close@DataIn@ozcollide@@QAE_NXZ	; ozcollide::DataIn::close

; 18   : 	return NOERR;

	mov	DWORD PTR $T8424[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
	mov	eax, DWORD PTR $T8424[ebp]
$LN3@loadBinary:

; 19   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1DataIn@ozcollide@@UAE@XZ		; ozcollide::DataIn::~DataIn
__ehhandler$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@PBDPAPAV12@@Z ENDP ; ozcollide::AABBTreePoly::loadBinary
PUBLIC	?final@AABBTreePoly@ozcollide@@AAEXXZ		; ozcollide::AABBTreePoly::final
PUBLIC	?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreePoly::readLEFSchunk
PUBLIC	?readNODSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreePoly::readNODSchunk
PUBLIC	?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z ; ozcollide::AABBTreePoly::readPNTSchunk
PUBLIC	??0AABBTreeNode@ozcollide@@QAE@XZ		; ozcollide::AABBTreeNode::AABBTreeNode
PUBLIC	??1AABBTreeNode@ozcollide@@QAE@XZ		; ozcollide::AABBTreeNode::~AABBTreeNode
PUBLIC	??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ	; ozcollide::AABBTreePolygonLeaf::AABBTreePolygonLeaf
PUBLIC	??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ	; ozcollide::AABBTreePolygonLeaf::~AABBTreePolygonLeaf
PUBLIC	??0AABBTreePoly@ozcollide@@AAE@H@Z		; ozcollide::AABBTreePoly::AABBTreePoly
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	?seek@DataIn@ozcollide@@QAE_NH@Z:PROC		; ozcollide::DataIn::seek
EXTRN	?advance@DataIn@ozcollide@@QAE_NH@Z:PROC	; ozcollide::DataIn::advance
EXTRN	??0Polygon@ozcollide@@QAE@XZ:PROC		; ozcollide::Polygon::Polygon
EXTRN	??1Polygon@ozcollide@@QAE@XZ:PROC		; ozcollide::Polygon::~Polygon
EXTRN	?tell@DataIn@ozcollide@@QBEHXZ:PROC		; ozcollide::DataIn::tell
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?readByte@DataIn@ozcollide@@QAEDXZ:PROC		; ozcollide::DataIn::readByte
EXTRN	?readDword@DataIn@ozcollide@@QAEHXZ:PROC	; ozcollide::DataIn::readDword
EXTRN	?read@DataIn@ozcollide@@QAEHPAXH@Z:PROC		; ozcollide::DataIn::read
xdata$x	SEGMENT
__unwindtable$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$3
__ehfuncinfo$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv251 = -128						; size = 4
tv204 = -124						; size = 4
tv172 = -120						; size = 4
tv130 = -116						; size = 4
$T8455 = -112						; size = 4
$T8452 = -108						; size = 4
$T8451 = -104						; size = 4
$T8450 = -100						; size = 4
$T8447 = -96						; size = 4
$T8446 = -92						; size = 4
$T8445 = -88						; size = 4
$T8442 = -84						; size = 4
$T8441 = -80						; size = 4
$T8440 = -76						; size = 4
$T8437 = -72						; size = 4
$T8436 = -68						; size = 4
_nbEdges$7547 = -64					; size = 4
_nbPols$7537 = -60					; size = 4
_sc$7533 = -56						; size = 4
_pos0$7535 = -52					; size = 4
_scSize$7534 = -48					; size = 4
_pos1$7557 = -44					; size = 4
_id$7532 = -40						; size = 4
_chunkSize$ = -36					; size = 4
_t$ = -32						; size = 4
_leafDepth$ = -25					; size = 1
_chunk$ = -24						; size = 4
_id$ = -20						; size = 4
_leafType$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
__file$ = 8						; size = 4
__tree$ = 12						; size = 4
?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z PROC ; ozcollide::AABBTreePoly::loadBinary

; 23   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 24   : 	int chunkSize;
; 25   : 
; 26   : 	char id[4];
; 27   : 	_file.read(id, 4);

	push	4
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read

; 28   : 	int chunk = MID(id[0], id[1], id[2], id[3]);

	movsx	ecx, BYTE PTR _id$[ebp+3]
	shl	ecx, 24					; 00000018H
	movsx	edx, BYTE PTR _id$[ebp+2]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	movsx	eax, BYTE PTR _id$[ebp+1]
	shl	eax, 8
	add	ecx, eax
	movsx	edx, BYTE PTR _id$[ebp]
	add	ecx, edx
	mov	DWORD PTR _chunk$[ebp], ecx

; 29   : 	if (chunk != MID('A', 'A', 'B', 'B'))

	cmp	DWORD PTR _chunk$[ebp], 1111638337	; 42424141H
	je	SHORT $LN15@loadBinary@2

; 30   : 		return ERR_INVALID_FORMAT;

	mov	eax, 18					; 00000012H
	jmp	$LN16@loadBinary@2
$LN15@loadBinary@2:

; 31   : 	
; 32   : 	chunkSize = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _chunkSize$[ebp], eax

; 33   : 
; 34   : 	char leafType = _file.readByte();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readByte@DataIn@ozcollide@@QAEDXZ	; ozcollide::DataIn::readByte
	mov	BYTE PTR _leafType$[ebp], al

; 35   : 
; 36   : 	if (leafType != 0)

	movsx	eax, BYTE PTR _leafType$[ebp]
	test	eax, eax
	je	SHORT $LN14@loadBinary@2

; 37   : 		return ERR_INVALID_FORMAT;

	mov	eax, 18					; 00000012H
	jmp	$LN16@loadBinary@2
$LN14@loadBinary@2:

; 38   : 
; 39   : 	AABBTreePoly *t;
; 40   : 	char leafDepth = _file.readByte();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readByte@DataIn@ozcollide@@QAEDXZ	; ozcollide::DataIn::readByte
	mov	BYTE PTR _leafDepth$[ebp], al

; 41   : 	t = new AABBTreePoly(leafDepth);

	push	256					; 00000100H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8437[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8437[ebp], 0
	je	SHORT $LN18@loadBinary@2
	movsx	ecx, BYTE PTR _leafDepth$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T8437[ebp]
	call	??0AABBTreePoly@ozcollide@@AAE@H@Z	; ozcollide::AABBTreePoly::AABBTreePoly
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN19@loadBinary@2
$LN18@loadBinary@2:
	mov	DWORD PTR tv130[ebp], 0
$LN19@loadBinary@2:
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR $T8436[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T8436[ebp]
	mov	DWORD PTR _t$[ebp], eax

; 42   : 	t->nbNodes_ = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 43   : 	t->nbLeafs_ = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	edx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx+12], eax

; 44   : 
; 45   : 	t->leafs_ = new AABBTreePolygonLeaf[t->nbLeafs_];

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T8440[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8440[ebp]
	mov	edx, 44					; 0000002cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8442[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T8442[ebp], 0
	je	SHORT $LN20@loadBinary@2
	mov	ecx, DWORD PTR $T8442[ebp]
	mov	edx, DWORD PTR $T8440[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	push	OFFSET ??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ ; ozcollide::AABBTreePolygonLeaf::AABBTreePolygonLeaf
	mov	eax, DWORD PTR $T8440[ebp]
	push	eax
	push	44					; 0000002cH
	mov	ecx, DWORD PTR $T8442[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T8442[ebp]
	add	edx, 4
	mov	DWORD PTR tv172[ebp], edx
	jmp	SHORT $LN21@loadBinary@2
$LN20@loadBinary@2:
	mov	DWORD PTR tv172[ebp], 0
$LN21@loadBinary@2:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR $T8441[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR $T8441[ebp]
	mov	DWORD PTR [ecx+36], edx

; 46   : 	t->root_ = new AABBTreeNode[t->nbNodes_];

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T8445[ebp], ecx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8445[ebp]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8447[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T8447[ebp], 0
	je	SHORT $LN22@loadBinary@2
	mov	ecx, DWORD PTR $T8447[ebp]
	mov	edx, DWORD PTR $T8445[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1AABBTreeNode@ozcollide@@QAE@XZ
	push	OFFSET ??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR $T8445[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T8447[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T8447[ebp]
	add	edx, 4
	mov	DWORD PTR tv204[ebp], edx
	jmp	SHORT $LN23@loadBinary@2
$LN22@loadBinary@2:
	mov	DWORD PTR tv204[ebp], 0
$LN23@loadBinary@2:
	mov	eax, DWORD PTR tv204[ebp]
	mov	DWORD PTR $T8446[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR $T8446[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN13@loadBinary@2:

; 47   : 
; 48   : 	while(chunkSize > 10) {

	cmp	DWORD PTR _chunkSize$[ebp], 10		; 0000000aH
	jle	$LN12@loadBinary@2

; 49   : 		char id[4];
; 50   : 		_file.read(id, 4);

	push	4
	lea	eax, DWORD PTR _id$7532[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?read@DataIn@ozcollide@@QAEHPAXH@Z	; ozcollide::DataIn::read

; 51   : 		int sc = MID(id[0], id[1], id[2], id[3]);

	movsx	ecx, BYTE PTR _id$7532[ebp+3]
	shl	ecx, 24					; 00000018H
	movsx	edx, BYTE PTR _id$7532[ebp+2]
	shl	edx, 16					; 00000010H
	add	ecx, edx
	movsx	eax, BYTE PTR _id$7532[ebp+1]
	shl	eax, 8
	add	ecx, eax
	movsx	edx, BYTE PTR _id$7532[ebp]
	add	ecx, edx
	mov	DWORD PTR _sc$7533[ebp], ecx

; 52   : 
; 53   : 		int scSize = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _scSize$7534[ebp], eax

; 54   : 		int pos0 = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataIn@ozcollide@@QBEHXZ		; ozcollide::DataIn::tell
	mov	DWORD PTR _pos0$7535[ebp], eax

; 55   : 
; 56   : 		if (sc == MID('N','P','O','L')) {

	cmp	DWORD PTR _sc$7533[ebp], 1280266318	; 4c4f504eH
	jne	$LN11@loadBinary@2

; 57   : 			int nbPols = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbPols$7537[ebp], eax

; 58   : 			t->bufPols_ = new Polygon[nbPols];

	mov	eax, DWORD PTR _nbPols$7537[ebp]
	mov	DWORD PTR $T8450[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8450[ebp]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8452[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	cmp	DWORD PTR $T8452[ebp], 0
	je	SHORT $LN24@loadBinary@2
	mov	ecx, DWORD PTR $T8452[ebp]
	mov	edx, DWORD PTR $T8450[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1Polygon@ozcollide@@QAE@XZ	; ozcollide::Polygon::~Polygon
	push	OFFSET ??0Polygon@ozcollide@@QAE@XZ	; ozcollide::Polygon::Polygon
	mov	eax, DWORD PTR $T8450[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T8452[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T8452[ebp]
	add	edx, 4
	mov	DWORD PTR tv251[ebp], edx
	jmp	SHORT $LN25@loadBinary@2
$LN24@loadBinary@2:
	mov	DWORD PTR tv251[ebp], 0
$LN25@loadBinary@2:
	mov	eax, DWORD PTR tv251[ebp]
	mov	DWORD PTR $T8451[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR $T8451[ebp]
	mov	DWORD PTR [ecx+248], edx
	jmp	$LN10@loadBinary@2
$LN11@loadBinary@2:

; 59   : 		}
; 60   : 		else if (sc == MID('N','E','D','G')) {

	cmp	DWORD PTR _sc$7533[ebp], 1195656526	; 4744454eH
	jne	SHORT $LN9@loadBinary@2

; 61   : 			int nbEdges = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbEdges$7547[ebp], eax

; 62   : 			t->bufEdges_ = new int[nbEdges];

	xor	ecx, ecx
	mov	eax, DWORD PTR _nbEdges$7547[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8455[ebp], eax
	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR $T8455[ebp]
	mov	DWORD PTR [eax+240], ecx
	jmp	SHORT $LN10@loadBinary@2
$LN9@loadBinary@2:

; 63   : 		}
; 64   : 		else if (sc == MID('P','N','T','S'))

	cmp	DWORD PTR _sc$7533[ebp], 1398034000	; 53544e50H
	jne	SHORT $LN7@loadBinary@2

; 65   : 			t->readPNTSchunk(_file, scSize);

	mov	edx, DWORD PTR _scSize$7534[ebp]
	push	edx
	mov	eax, DWORD PTR __file$[ebp]
	push	eax
	mov	ecx, DWORD PTR _t$[ebp]
	call	?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z ; ozcollide::AABBTreePoly::readPNTSchunk
	jmp	SHORT $LN10@loadBinary@2
$LN7@loadBinary@2:

; 66   : 		else if (sc == MID('N','O','D','S'))

	cmp	DWORD PTR _sc$7533[ebp], 1396985678	; 53444f4eH
	jne	SHORT $LN5@loadBinary@2

; 67   : 			t->readNODSchunk(_file, scSize, t->nbNodes_);

	mov	ecx, DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _scSize$7534[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _t$[ebp]
	call	?readNODSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreePoly::readNODSchunk
	jmp	SHORT $LN10@loadBinary@2
$LN5@loadBinary@2:

; 68   : 		else if (sc == MID('L','E','F','S'))

	cmp	DWORD PTR _sc$7533[ebp], 1397114188	; 5346454cH
	jne	SHORT $LN3@loadBinary@2

; 69   : 			t->readLEFSchunk(_file, scSize, t->nbLeafs_);

	mov	edx, DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _scSize$7534[ebp]
	push	ecx
	mov	edx, DWORD PTR __file$[ebp]
	push	edx
	mov	ecx, DWORD PTR _t$[ebp]
	call	?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ; ozcollide::AABBTreePoly::readLEFSchunk

; 70   : 		else

	jmp	SHORT $LN10@loadBinary@2
$LN3@loadBinary@2:

; 71   : 			_file.advance(scSize);

	mov	eax, DWORD PTR _scSize$7534[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataIn@ozcollide@@QAE_NH@Z	; ozcollide::DataIn::advance
$LN10@loadBinary@2:

; 72   : 
; 73   : 		int pos1 = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataIn@ozcollide@@QBEHXZ		; ozcollide::DataIn::tell
	mov	DWORD PTR _pos1$7557[ebp], eax

; 74   : 		if (pos1 - pos0 != scSize)

	mov	ecx, DWORD PTR _pos1$7557[ebp]
	sub	ecx, DWORD PTR _pos0$7535[ebp]
	cmp	ecx, DWORD PTR _scSize$7534[ebp]
	je	SHORT $LN1@loadBinary@2

; 75   : 			_file.seek(pos0 + scSize);

	mov	edx, DWORD PTR _pos0$7535[ebp]
	add	edx, DWORD PTR _scSize$7534[ebp]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataIn@ozcollide@@QAE_NH@Z	; ozcollide::DataIn::seek
$LN1@loadBinary@2:

; 76   : 		chunkSize -= scSize + 8;

	mov	eax, DWORD PTR _scSize$7534[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _chunkSize$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _chunkSize$[ebp], ecx

; 77   : 	}

	jmp	$LN13@loadBinary@2
$LN12@loadBinary@2:

; 78   : 
; 79   : 	*_tree = t;

	mov	edx, DWORD PTR __tree$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [edx], eax

; 80   : 
; 81   : 	t->final();

	mov	ecx, DWORD PTR _t$[ebp]
	call	?final@AABBTreePoly@ozcollide@@AAEXXZ	; ozcollide::AABBTreePoly::final

; 82   : 
; 83   : 	return NOERR;

	xor	eax, eax
$LN16@loadBinary@2:

; 84   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$0:
	mov	eax, DWORD PTR $T8437[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$1:
	mov	eax, DWORD PTR $T8442[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$2:
	mov	eax, DWORD PTR $T8447[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z$3:
	mov	eax, DWORD PTR $T8452[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?loadBinary@AABBTreePoly@ozcollide@@SA?AW4ERR@2@AAVDataIn@2@PAPAV12@@Z ENDP ; ozcollide::AABBTreePoly::loadBinary
;	COMDAT xdata$x
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.h
xdata$x	SEGMENT
__unwindtable$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ$0
__ehfuncinfo$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ PROC		; ozcollide::AABBTreePolygonLeaf::AABBTreePolygonLeaf, COMDAT
; _this$ = ecx

; 48   : 	AABBTreePolygonLeaf() : nbPolys (0), polys (NULL), users (NULL) { };

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTreeNode@ozcollide@@QAE@XZ
__ehhandler$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreePolygonLeaf@ozcollide@@QAE@XZ ENDP		; ozcollide::AABBTreePolygonLeaf::AABBTreePolygonLeaf
PUBLIC	??1Box@ozcollide@@QAE@XZ			; ozcollide::Box::~Box
PUBLIC	??0Box@ozcollide@@QAE@XZ			; ozcollide::Box::Box
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AABBTreeNode@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreeNode@ozcollide@@QAE@XZ$0
__ehfuncinfo$??0AABBTreeNode@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AABBTreeNode@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0AABBTreeNode@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0AABBTreeNode@ozcollide@@QAE@XZ PROC			; ozcollide::AABBTreeNode::AABBTreeNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AABBTreeNode@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??0AABBTreeNode@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreeNode@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreeNode@ozcollide@@QAE@XZ ENDP			; ozcollide::AABBTreeNode::AABBTreeNode
PUBLIC	??0Vec3f@ozcollide@@QAE@XZ			; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
;	COMDAT ??0Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::Box, COMDAT
; _this$ = ecx

; 44   : 	ozinline Box()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f

; 45   : 	{
; 46   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::Box
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??0Vec3f@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vec3f@ozcollide@@QAE@XZ PROC				; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 37   : 	ozinline Vec3f()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	{
; 39   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vec3f@ozcollide@@QAE@XZ ENDP				; ozcollide::Vec3f::Vec3f
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ??1Box@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Box@ozcollide@@QAE@XZ PROC				; ozcollide::Box::~Box, COMDAT
; _this$ = ecx

; 53   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Box@ozcollide@@QAE@XZ ENDP				; ozcollide::Box::~Box
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AABBTreeNode@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreeNode@ozcollide@@QAE@XZ$0
__ehfuncinfo$??1AABBTreeNode@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AABBTreeNode@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1AABBTreeNode@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreeNode@ozcollide@@QAE@XZ PROC			; ozcollide::AABBTreeNode::~AABBTreeNode, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AABBTreeNode@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??1AABBTreeNode@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreeNode@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreeNode@ozcollide@@QAE@XZ ENDP			; ozcollide::AABBTreeNode::~AABBTreeNode
PUBLIC	??_EAABBTreePolygonLeaf@ozcollide@@QAEPAXI@Z	; ozcollide::AABBTreePolygonLeaf::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EAABBTreePolygonLeaf@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAABBTreePolygonLeaf@ozcollide@@QAEPAXI@Z PROC	; ozcollide::AABBTreePolygonLeaf::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAABBTreePolygonLeaf@ozcollide@@QAEPAXI@Z ENDP	; ozcollide::AABBTreePolygonLeaf::`vector deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ$0
__ehfuncinfo$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ PROC		; ozcollide::AABBTreePolygonLeaf::~AABBTreePolygonLeaf, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTreeNode@ozcollide@@QAE@XZ
__ehhandler$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreePolygonLeaf@ozcollide@@QAE@XZ ENDP		; ozcollide::AABBTreePolygonLeaf::~AABBTreePolygonLeaf
PUBLIC	??_EAABBTreeNode@ozcollide@@QAEPAXI@Z		; ozcollide::AABBTreeNode::`vector deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_EAABBTreeNode@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EAABBTreeNode@ozcollide@@QAEPAXI@Z PROC		; ozcollide::AABBTreeNode::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreeNode@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EAABBTreeNode@ozcollide@@QAEPAXI@Z ENDP		; ozcollide::AABBTreeNode::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_EPolygon@ozcollide@@QAEPAXI@Z		; ozcollide::Polygon::`vector deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_EPolygon@ozcollide@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EPolygon@ozcollide@@QAEPAXI@Z PROC			; ozcollide::Polygon::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1Polygon@ozcollide@@QAE@XZ	; ozcollide::Polygon::~Polygon
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Polygon@ozcollide@@QAE@XZ		; ozcollide::Polygon::~Polygon
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EPolygon@ozcollide@@QAEPAXI@Z ENDP			; ozcollide::Polygon::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
EXTRN	?readFloat@DataIn@ozcollide@@QAEMXZ:PROC	; ozcollide::DataIn::readFloat
EXTRN	__imp__free:PROC
EXTRN	__fltused:DWORD
xdata$x	SEGMENT
__unwindtable$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z$0
__ehfuncinfo$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtreepoly_io.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv87 = -40						; size = 4
_this$ = -36						; size = 4
$T8515 = -32						; size = 4
$T8514 = -28						; size = 4
$T8513 = -24						; size = 4
_pt$7598 = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__file$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z PROC ; ozcollide::AABBTreePoly::readPNTSchunk
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	int i;
; 89   : 
; 90   : 	nbPoints_ = _chunkSize / 12;

	mov	eax, DWORD PTR __chunkSize$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], eax

; 91   : 	SAFE_FREE(points_);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@readPNTSch
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0
$LN4@readPNTSch:

; 92   : 	points_ = new Vec3f[nbPoints_];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T8513[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8513[ebp]
	mov	edx, 12					; 0000000cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8515[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8515[ebp], 0
	je	SHORT $LN7@readPNTSch
	push	OFFSET ??0Vec3f@ozcollide@@QAE@XZ	; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR $T8513[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T8515[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	mov	edx, DWORD PTR $T8515[ebp]
	mov	DWORD PTR tv87[ebp], edx
	jmp	SHORT $LN8@readPNTSch
$LN7@readPNTSch:
	mov	DWORD PTR tv87[ebp], 0
$LN8@readPNTSch:
	mov	eax, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T8514[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T8514[ebp]
	mov	DWORD PTR [ecx+44], edx

; 93   : 	for (i = 0; i < nbPoints_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@readPNTSch
$LN2@readPNTSch:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@readPNTSch:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+40]
	jge	SHORT $LN1@readPNTSch

; 94   : 		Vec3f &pt = points_[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR _pt$7598[ebp], eax

; 95   : 		pt.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _pt$7598[ebp]
	fstp	DWORD PTR [edx]

; 96   : 		pt.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _pt$7598[ebp]
	fstp	DWORD PTR [eax+4]

; 97   : 		pt.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _pt$7598[ebp]
	fstp	DWORD PTR [ecx+8]
	jmp	SHORT $LN2@readPNTSch
$LN1@readPNTSch:

; 98   : 	}
; 99   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z$0:
	mov	eax, DWORD PTR $T8515[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readPNTSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@H@Z ENDP ; ozcollide::AABBTreePoly::readPNTSchunk
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -36						; size = 4
_index$7621 = -32					; size = 4
_isLeaf$7620 = -28					; size = 4
_index$7615 = -24					; size = 4
_isLeaf$7614 = -20					; size = 4
_node$7609 = -16					; size = 4
_leftID$7610 = -12					; size = 4
_rightID$7611 = -8					; size = 4
_i$ = -4						; size = 4
__file$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
__nbNodes$ = 16						; size = 4
?readNODSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z PROC ; ozcollide::AABBTreePoly::readNODSchunk
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	int i;
; 106  : 
; 107  : 	for (i = 0; i < _nbNodes; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@readNODSch
$LN10@readNODSch:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN11@readNODSch:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR __nbNodes$[ebp]
	jge	$LN9@readNODSch

; 108  : 		AABBTreeNode &node = root_[i];

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _node$7609[ebp], edx

; 109  : 
; 110  : 		node.aabb.center.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [ecx]

; 111  : 		node.aabb.center.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [edx+4]

; 112  : 		node.aabb.center.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [eax+8]

; 113  : 		node.aabb.extent.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [ecx+12]

; 114  : 		node.aabb.extent.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [edx+16]

; 115  : 		node.aabb.extent.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _node$7609[ebp]
	fstp	DWORD PTR [eax+20]

; 116  : 
; 117  : 		int leftID = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _leftID$7610[ebp], eax

; 118  : 		int rightID = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _rightID$7611[ebp], eax

; 119  : 
; 120  : 		if (leftID == -1)

	cmp	DWORD PTR _leftID$7610[ebp], -1
	jne	SHORT $LN8@readNODSch

; 121  : 			node.left = NULL;

	mov	ecx, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [ecx+24], 0

; 122  : 		else {

	jmp	SHORT $LN5@readNODSch
$LN8@readNODSch:

; 123  : 			int isLeaf = leftID >> 31;

	mov	edx, DWORD PTR _leftID$7610[ebp]
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _isLeaf$7614[ebp], edx

; 124  : 			int index = leftID & 0x7fffffff;

	mov	eax, DWORD PTR _leftID$7610[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _index$7615[ebp], eax

; 125  : 			if (isLeaf)

	cmp	DWORD PTR _isLeaf$7614[ebp], 0
	je	SHORT $LN6@readNODSch

; 126  : 				node.left = &leafs_[index];

	mov	ecx, DWORD PTR _index$7615[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [eax+24], ecx

; 127  : 			else

	jmp	SHORT $LN5@readNODSch
$LN6@readNODSch:

; 128  : 				node.left = &root_[index];

	mov	ecx, DWORD PTR _index$7615[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN5@readNODSch:

; 129  : 		}
; 130  : 
; 131  : 		if (rightID == -1)

	cmp	DWORD PTR _rightID$7611[ebp], -1
	jne	SHORT $LN4@readNODSch

; 132  : 			node.right = NULL;

	mov	ecx, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [ecx+28], 0

; 133  : 		else {

	jmp	SHORT $LN1@readNODSch
$LN4@readNODSch:

; 134  : 			int isLeaf = rightID >> 31;

	mov	edx, DWORD PTR _rightID$7611[ebp]
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _isLeaf$7620[ebp], edx

; 135  : 			int index = rightID & 0x7fffffff;

	mov	eax, DWORD PTR _rightID$7611[ebp]
	and	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _index$7621[ebp], eax

; 136  : 			if (isLeaf)

	cmp	DWORD PTR _isLeaf$7620[ebp], 0
	je	SHORT $LN2@readNODSch

; 137  : 					node.right = &leafs_[index];

	mov	ecx, DWORD PTR _index$7621[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	eax, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [eax+28], ecx

; 138  : 			else

	jmp	SHORT $LN1@readNODSch
$LN2@readNODSch:

; 139  : 				node.right = &root_[index];

	mov	ecx, DWORD PTR _index$7621[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _node$7609[ebp]
	mov	DWORD PTR [eax+28], ecx
$LN1@readNODSch:

; 140  : 		}

	jmp	$LN10@readNODSch
$LN9@readNODSch:

; 141  : 	}
; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?readNODSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ENDP ; ozcollide::AABBTreePoly::readNODSchunk
_TEXT	ENDS
PUBLIC	?setIndex@Polygon@ozcollide@@QAEXHH@Z		; ozcollide::Polygon::setIndex
PUBLIC	?setIndicesMemory@Polygon@ozcollide@@QAEXHPAH@Z	; ozcollide::Polygon::setIndicesMemory
EXTRN	?setNbIndices@Polygon@ozcollide@@QAEXH@Z:PROC	; ozcollide::Polygon::setNbIndices
xdata$x	SEGMENT
__unwindtable$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z$0
__ehfuncinfo$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv189 = -64						; size = 4
_this$ = -60						; size = 4
$T8528 = -56						; size = 4
$T8527 = -52						; size = 4
$T8526 = -48						; size = 4
_vert$7658 = -44					; size = 4
_nbVerts$7650 = -40					; size = 4
_pol$7651 = -36						; size = 4
_leaf$7636 = -32					; size = 4
_nbPols$7637 = -28					; size = 4
_j$ = -24						; size = 4
_k$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__file$ = 8						; size = 4
__chunkSize$ = 12					; size = 4
__nbLeafs$ = 16						; size = 4
?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z PROC ; ozcollide::AABBTreePoly::readLEFSchunk
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	int i, j, k;
; 149  : 
; 150  : 	for (i = 0; i < _nbLeafs; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN13@readLEFSch
$LN12@readLEFSch:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN13@readLEFSch:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR __nbLeafs$[ebp]
	jge	$LN11@readLEFSch

; 151  : 		AABBTreePolygonLeaf &leaf = leafs_[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _leaf$7636[ebp], edx

; 152  : 
; 153  : 		leaf.aabb.center.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [ecx]

; 154  : 		leaf.aabb.center.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [edx+4]

; 155  : 		leaf.aabb.center.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [eax+8]

; 156  : 		leaf.aabb.extent.x = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	ecx, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [ecx+12]

; 157  : 		leaf.aabb.extent.y = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	edx, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [edx+16]

; 158  : 		leaf.aabb.extent.z = _file.readFloat();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readFloat@DataIn@ozcollide@@QAEMXZ	; ozcollide::DataIn::readFloat
	mov	eax, DWORD PTR _leaf$7636[ebp]
	fstp	DWORD PTR [eax+20]

; 159  : 
; 160  : 		leaf.left = NULL;

	mov	ecx, DWORD PTR _leaf$7636[ebp]
	mov	DWORD PTR [ecx+24], 0

; 161  : 		leaf.right = NULL;

	mov	edx, DWORD PTR _leaf$7636[ebp]
	mov	DWORD PTR [edx+28], 0

; 162  : 
; 163  : 		int nbPols = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbPols$7637[ebp], eax

; 164  : 		leaf.nbPolys = nbPols;

	mov	eax, DWORD PTR _leaf$7636[ebp]
	mov	ecx, DWORD PTR _nbPols$7637[ebp]
	mov	DWORD PTR [eax+32], ecx

; 165  : 		if (!bufPols_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+248], 0
	jne	$LN10@readLEFSch

; 166  : 			leaf.polys = new Polygon[nbPols];

	mov	eax, DWORD PTR _nbPols$7637[ebp]
	mov	DWORD PTR $T8526[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T8526[ebp]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8528[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T8528[ebp], 0
	je	SHORT $LN16@readLEFSch
	mov	ecx, DWORD PTR $T8528[ebp]
	mov	edx, DWORD PTR $T8526[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1Polygon@ozcollide@@QAE@XZ	; ozcollide::Polygon::~Polygon
	push	OFFSET ??0Polygon@ozcollide@@QAE@XZ	; ozcollide::Polygon::Polygon
	mov	eax, DWORD PTR $T8526[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR $T8528[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T8528[ebp]
	add	edx, 4
	mov	DWORD PTR tv189[ebp], edx
	jmp	SHORT $LN17@readLEFSch
$LN16@readLEFSch:
	mov	DWORD PTR tv189[ebp], 0
$LN17@readLEFSch:
	mov	eax, DWORD PTR tv189[ebp]
	mov	DWORD PTR $T8527[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _leaf$7636[ebp]
	mov	edx, DWORD PTR $T8527[ebp]
	mov	DWORD PTR [ecx+36], edx

; 167  : 		else {

	jmp	SHORT $LN9@readLEFSch
$LN10@readLEFSch:

; 168  : 			leaf.polys = &bufPols_[offBufPols_];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+252]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+248]
	mov	eax, DWORD PTR _leaf$7636[ebp]
	mov	DWORD PTR [eax+36], ecx

; 169  : 			offBufPols_ += nbPols;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+252]
	add	edx, DWORD PTR _nbPols$7637[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+252], edx
$LN9@readLEFSch:

; 170  : 		}
; 171  : 		for (j = 0; j < nbPols; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN8@readLEFSch
$LN7@readLEFSch:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN8@readLEFSch:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nbPols$7637[ebp]
	jge	$LN6@readLEFSch

; 172  : 			int nbVerts = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _nbVerts$7650[ebp], eax

; 173  : 			Polygon *pol = (Polygon*) &leaf.polys[j];

	mov	eax, DWORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _leaf$7636[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _pol$7651[ebp], eax

; 174  : 			if (!bufEdges_)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+240], 0
	jne	SHORT $LN5@readLEFSch

; 175  : 				pol->setNbIndices(nbVerts);

	mov	eax, DWORD PTR _nbVerts$7650[ebp]
	push	eax
	mov	ecx, DWORD PTR _pol$7651[ebp]
	call	?setNbIndices@Polygon@ozcollide@@QAEXH@Z ; ozcollide::Polygon::setNbIndices

; 176  : 			else {

	jmp	SHORT $LN4@readLEFSch
$LN5@readLEFSch:

; 177  : 				pol->setIndicesMemory(nbVerts, bufEdges_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	push	edx
	mov	eax, DWORD PTR _nbVerts$7650[ebp]
	push	eax
	mov	ecx, DWORD PTR _pol$7651[ebp]
	call	?setIndicesMemory@Polygon@ozcollide@@QAEXHPAH@Z ; ozcollide::Polygon::setIndicesMemory

; 178  : 				bufEdges_ += nbVerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	mov	eax, DWORD PTR _nbVerts$7650[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+240], ecx
$LN4@readLEFSch:

; 179  : 			}
; 180  : 			for (k = 0; k < nbVerts; k++) {

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN3@readLEFSch
$LN2@readLEFSch:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN3@readLEFSch:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _nbVerts$7650[ebp]
	jge	SHORT $LN1@readLEFSch

; 181  : 				int vert = _file.readDword();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?readDword@DataIn@ozcollide@@QAEHXZ	; ozcollide::DataIn::readDword
	mov	DWORD PTR _vert$7658[ebp], eax

; 182  : 				pol->setIndex(k, vert);

	mov	edx, DWORD PTR _vert$7658[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pol$7651[ebp]
	call	?setIndex@Polygon@ozcollide@@QAEXHH@Z	; ozcollide::Polygon::setIndex

; 183  : 			}

	jmp	SHORT $LN2@readLEFSch
$LN1@readLEFSch:

; 184  : 		}

	jmp	$LN7@readLEFSch
$LN6@readLEFSch:

; 185  : 	}

	jmp	$LN12@readLEFSch
$LN11@readLEFSch:

; 186  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z$0:
	mov	eax, DWORD PTR $T8528[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readLEFSchunk@AABBTreePoly@ozcollide@@AAEXAAVDataIn@2@HH@Z ENDP ; ozcollide::AABBTreePoly::readLEFSchunk
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\polygon.h
;	COMDAT ?setIndicesMemory@Polygon@ozcollide@@QAEXHPAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__nbIndices$ = 8					; size = 4
__indices$ = 12						; size = 4
?setIndicesMemory@Polygon@ozcollide@@QAEXHPAH@Z PROC	; ozcollide::Polygon::setIndicesMemory, COMDAT
; _this$ = ecx

; 50   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		//nbIndices_ = _nbIndices | 0x100;
; 52   : 		nbIndices_ = _nbIndices;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __nbIndices$[ebp]
	mov	DWORD PTR [eax], ecx

; 53   : 		memcpy(indices_, _indices, sizeof(int) * nbIndices_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __indices$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 54   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setIndicesMemory@Polygon@ozcollide@@QAEXHPAH@Z ENDP	; ozcollide::Polygon::setIndicesMemory
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setIndex@Polygon@ozcollide@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_index$ = 12						; size = 4
?setIndex@Polygon@ozcollide@@QAEXHH@Z PROC		; ozcollide::Polygon::setIndex, COMDAT
; _this$ = ecx

; 59   : 	ozinline void setIndex(int i, int index) { indices_[i] = index; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [ecx+eax*4+4], edx
	mov	esp, ebp
	pop	ebp
	ret	8
?setIndex@Polygon@ozcollide@@QAEXHH@Z ENDP		; ozcollide::Polygon::setIndex
_TEXT	ENDS
PUBLIC	?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z ; ozcollide::AABBTreePoly::saveBinary
EXTRN	?close@DataOut@ozcollide@@QAE_NXZ:PROC		; ozcollide::DataOut::close
EXTRN	??1DataOut@ozcollide@@UAE@XZ:PROC		; ozcollide::DataOut::~DataOut
EXTRN	?open@DataOut@ozcollide@@QAE_NPBD@Z:PROC	; ozcollide::DataOut::open
EXTRN	??0DataOut@ozcollide@@QAE@XZ:PROC		; ozcollide::DataOut::DataOut
xdata$x	SEGMENT
__unwindtable$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z$0
__ehfuncinfo$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtreepoly_io.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T8543 = -44						; size = 4
$T8542 = -40						; size = 4
$T8541 = -36						; size = 4
_err$ = -32						; size = 4
_file$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
__filename$ = 8						; size = 4
?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z PROC ; ozcollide::AABBTreePoly::saveBinary
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 	DataOut file;

	lea	ecx, DWORD PTR _file$[ebp]
	call	??0DataOut@ozcollide@@QAE@XZ		; ozcollide::DataOut::DataOut
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 191  : 	ERR err;
; 192  : 
; 193  : 	if (!file.open(_filename))

	mov	eax, DWORD PTR __filename$[ebp]
	push	eax
	lea	ecx, DWORD PTR _file$[ebp]
	call	?open@DataOut@ozcollide@@QAE_NPBD@Z	; ozcollide::DataOut::open
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@saveBinary

; 194  : 		return ERR_CANNOT_OPEN;

	mov	DWORD PTR $T8541[ebp], 17		; 00000011H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T8541[ebp]
	jmp	SHORT $LN3@saveBinary
$LN2@saveBinary:

; 195  : 
; 196  : 	err = saveBinary(file);

	lea	edx, DWORD PTR _file$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _err$[ebp], eax

; 197  : 	if (err)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $LN1@saveBinary

; 198  : 		return err;

	mov	ecx, DWORD PTR _err$[ebp]
	mov	DWORD PTR $T8542[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T8542[ebp]
	jmp	SHORT $LN3@saveBinary
$LN1@saveBinary:

; 199  : 
; 200  : 	file.close();

	lea	ecx, DWORD PTR _file$[ebp]
	call	?close@DataOut@ozcollide@@QAE_NXZ	; ozcollide::DataOut::close

; 201  : 	return NOERR;

	mov	DWORD PTR $T8543[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _file$[ebp]
	call	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
	mov	eax, DWORD PTR $T8543[ebp]
$LN3@saveBinary:

; 202  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z$0:
	lea	ecx, DWORD PTR _file$[ebp]
	jmp	??1DataOut@ozcollide@@UAE@XZ		; ozcollide::DataOut::~DataOut
__ehhandler$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z ENDP ; ozcollide::AABBTreePoly::saveBinary
PUBLIC	?getIndex@Polygon@ozcollide@@QBEHH@Z		; ozcollide::Polygon::getIndex
PUBLIC	?getNbIndices@Polygon@ozcollide@@QBEHXZ		; ozcollide::Polygon::getNbIndices
PUBLIC	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ		; ozcollide::AABBTree::getNbLeafs
PUBLIC	?getNbNodes@AABBTree@ozcollide@@QBEHXZ		; ozcollide::AABBTree::getNbNodes
PUBLIC	?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z ; ozcollide::AABBTreePoly::saveBinary
EXTRN	?seek@DataOut@ozcollide@@QAE_NH@Z:PROC		; ozcollide::DataOut::seek
EXTRN	?writeFloat@DataOut@ozcollide@@QAEHM@Z:PROC	; ozcollide::DataOut::writeFloat
EXTRN	?writeDword@DataOut@ozcollide@@QAEHH@Z:PROC	; ozcollide::DataOut::writeDword
EXTRN	?writeByte@DataOut@ozcollide@@QAEHD@Z:PROC	; ozcollide::DataOut::writeByte
EXTRN	?advance@DataOut@ozcollide@@QAE_NH@Z:PROC	; ozcollide::DataOut::advance
EXTRN	?tell@DataOut@ozcollide@@QBEHXZ:PROC		; ozcollide::DataOut::tell
EXTRN	?writeStr@DataOut@ozcollide@@QAEHPBD@Z:PROC	; ozcollide::DataOut::writeStr
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -84						; size = 4
_nbVerts$7727 = -80					; size = 4
_pol$7726 = -76						; size = 4
_leaf$7722 = -72					; size = 4
_diff$7712 = -68					; size = 4
_diff$7706 = -64					; size = 4
_node$7702 = -60					; size = 4
_right$7704 = -56					; size = 4
_left$7703 = -52					; size = 4
_pol$7691 = -48						; size = 4
_nb$7687 = -44						; size = 4
_j$ = -40						; size = 4
_pos$ = -36						; size = 4
_k$ = -32						; size = 4
_nbNodes$ = -28						; size = 4
_nbPolys$ = -24						; size = 4
_nbEdges$ = -20						; size = 4
_i$ = -16						; size = 4
_posLEFS$ = -12						; size = 4
_posBBT$ = -8						; size = 4
_nbLeafs$ = -4						; size = 4
__file$ = 8						; size = 4
?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z PROC ; ozcollide::AABBTreePoly::saveBinary
; _this$ = ecx

; 205  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 	int i, j, k;
; 207  : 	int pos;
; 208  : 
; 209  : 	_file.writeStr("AABB");

	push	OFFSET $SG7678
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 210  : 	int posBBT = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _posBBT$[ebp], eax

; 211  : 	_file.advance(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::advance

; 212  : 
; 213  : 	_file.writeByte(0);

	push	0
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeByte@DataOut@ozcollide@@QAEHD@Z	; ozcollide::DataOut::writeByte

; 214  : 
; 215  : 	int nbNodes = getNbNodes();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbNodes@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbNodes
	mov	DWORD PTR _nbNodes$[ebp], eax

; 216  : 	int nbLeafs = getNbLeafs();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbLeafs
	mov	DWORD PTR _nbLeafs$[ebp], eax

; 217  : 
; 218  : 	_file.writeByte(leafDepth_);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeByte@DataOut@ozcollide@@QAEHD@Z	; ozcollide::DataOut::writeByte

; 219  : 	_file.writeDword(nbNodes);

	mov	edx, DWORD PTR _nbNodes$[ebp]
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 220  : 	_file.writeDword(nbLeafs);

	mov	eax, DWORD PTR _nbLeafs$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 221  : 
; 222  : 	int nbPolys = 0;

	mov	DWORD PTR _nbPolys$[ebp], 0

; 223  : 	int nbEdges = 0;

	mov	DWORD PTR _nbEdges$[ebp], 0

; 224  : 	for (i = 0; i < nbLeafs; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN29@saveBinary@2
$LN28@saveBinary@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN29@saveBinary@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _nbLeafs$[ebp]
	jge	SHORT $LN27@saveBinary@2

; 225  : 		int nb = leafs_[i].nbPolys;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [edx+eax+32]
	mov	DWORD PTR _nb$7687[ebp], eax

; 226  : 		nbPolys += nb;

	mov	ecx, DWORD PTR _nbPolys$[ebp]
	add	ecx, DWORD PTR _nb$7687[ebp]
	mov	DWORD PTR _nbPolys$[ebp], ecx

; 227  : 		for (j = 0; j < nb; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN26@saveBinary@2
$LN25@saveBinary@2:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN26@saveBinary@2:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _nb$7687[ebp]
	jge	SHORT $LN24@saveBinary@2

; 228  : 			const Polygon *pol = &leafs_[i].polys[j];

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR [eax+ecx+36]
	mov	DWORD PTR _pol$7691[ebp], edx

; 229  : 			nbEdges += pol->getNbIndices();

	mov	ecx, DWORD PTR _pol$7691[ebp]
	call	?getNbIndices@Polygon@ozcollide@@QBEHXZ	; ozcollide::Polygon::getNbIndices
	add	eax, DWORD PTR _nbEdges$[ebp]
	mov	DWORD PTR _nbEdges$[ebp], eax

; 230  : 		}

	jmp	SHORT $LN25@saveBinary@2
$LN24@saveBinary@2:

; 231  : 	}

	jmp	SHORT $LN28@saveBinary@2
$LN27@saveBinary@2:

; 232  : 
; 233  : 	_file.writeStr("NPOL");

	push	OFFSET $SG7692
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 234  : 	_file.writeDword(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 235  : 	_file.writeDword(nbPolys);

	mov	eax, DWORD PTR _nbPolys$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 236  : 
; 237  : 	_file.writeStr("NEDG");

	push	OFFSET $SG7693
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 238  : 	_file.writeDword(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 239  : 	_file.writeDword(nbEdges);

	mov	ecx, DWORD PTR _nbEdges$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 240  : 
; 241  : 	_file.writeStr("PNTS");

	push	OFFSET $SG7694
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 242  : 	_file.writeDword(nbPoints_ * 12);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 243  : 	for (i = 0; i < nbPoints_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN23@saveBinary@2
$LN22@saveBinary@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN23@saveBinary@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	SHORT $LN21@saveBinary@2

; 244  : 		_file.writeFloat(points_[i].x);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	fld	DWORD PTR [eax+ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 245  : 		_file.writeFloat(points_[i].y);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	fld	DWORD PTR [eax+ecx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 246  : 		_file.writeFloat(points_[i].z);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	ecx
	fld	DWORD PTR [eax+ecx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 247  : 	}

	jmp	SHORT $LN22@saveBinary@2
$LN21@saveBinary@2:

; 248  : 
; 249  : 	_file.writeStr("NODS");

	push	OFFSET $SG7698
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 250  : 	_file.writeDword((24 + 8) * nbNodes);

	mov	ecx, DWORD PTR _nbNodes$[ebp]
	shl	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 251  : 	for (i = 0; i < nbNodes; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN20@saveBinary@2
$LN19@saveBinary@2:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN20@saveBinary@2:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nbNodes$[ebp]
	jge	$LN18@saveBinary@2

; 252  : 		AABBTreeNode *node = &root_[i];

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR _node$7702[ebp], ecx

; 253  : 		_file.writeFloat(node->aabb.center.x);

	mov	eax, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 254  : 		_file.writeFloat(node->aabb.center.y);

	mov	ecx, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 255  : 		_file.writeFloat(node->aabb.center.z);

	mov	edx, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 256  : 		_file.writeFloat(node->aabb.extent.x);

	mov	eax, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [eax+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 257  : 		_file.writeFloat(node->aabb.extent.y);

	mov	ecx, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 258  : 		_file.writeFloat(node->aabb.extent.z);

	mov	edx, DWORD PTR _node$7702[ebp]
	push	ecx
	fld	DWORD PTR [edx+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 259  : 
; 260  : 		const AABBTreeNode *left = node->left;

	mov	eax, DWORD PTR _node$7702[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _left$7703[ebp], ecx

; 261  : 		const AABBTreeNode *right = node->right;

	mov	edx, DWORD PTR _node$7702[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _right$7704[ebp], eax

; 262  : 
; 263  : 		if (left) {

	cmp	DWORD PTR _left$7703[ebp], 0
	je	SHORT $LN17@saveBinary@2

; 264  : 			int diff = left - root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _left$7703[ebp]
	sub	edx, DWORD PTR [ecx+8]
	sar	edx, 5
	mov	DWORD PTR _diff$7706[ebp], edx

; 265  : 			if (diff < 0 || diff >= nbNodes) {

	cmp	DWORD PTR _diff$7706[ebp], 0
	jl	SHORT $LN15@saveBinary@2
	mov	eax, DWORD PTR _diff$7706[ebp]
	cmp	eax, DWORD PTR _nbNodes$[ebp]
	jl	SHORT $LN16@saveBinary@2
$LN15@saveBinary@2:

; 266  : 				diff = ((AABBTreePolygonLeaf*) left) - leafs_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _left$7703[ebp]
	sub	eax, DWORD PTR [ecx+36]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	mov	DWORD PTR _diff$7706[ebp], eax

; 267  : 				diff |= 0x80000000;

	mov	edx, DWORD PTR _diff$7706[ebp]
	or	edx, -2147483648			; 80000000H
	mov	DWORD PTR _diff$7706[ebp], edx
$LN16@saveBinary@2:

; 268  : 			}
; 269  : 			_file.writeDword(diff);

	mov	eax, DWORD PTR _diff$7706[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 270  : 		}
; 271  : 		else

	jmp	SHORT $LN14@saveBinary@2
$LN17@saveBinary@2:

; 272  : 			_file.writeDword(-1);

	push	-1
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
$LN14@saveBinary@2:

; 273  : 
; 274  : 		if (right) {

	cmp	DWORD PTR _right$7704[ebp], 0
	je	SHORT $LN13@saveBinary@2

; 275  : 			int diff = right - root_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _right$7704[ebp]
	sub	edx, DWORD PTR [ecx+8]
	sar	edx, 5
	mov	DWORD PTR _diff$7712[ebp], edx

; 276  : 			if (diff < 0 || diff >= nbNodes) {

	cmp	DWORD PTR _diff$7712[ebp], 0
	jl	SHORT $LN11@saveBinary@2
	mov	eax, DWORD PTR _diff$7712[ebp]
	cmp	eax, DWORD PTR _nbNodes$[ebp]
	jl	SHORT $LN12@saveBinary@2
$LN11@saveBinary@2:

; 277  : 				diff = ((AABBTreePolygonLeaf*) right) - leafs_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _right$7704[ebp]
	sub	eax, DWORD PTR [ecx+36]
	cdq
	mov	ecx, 44					; 0000002cH
	idiv	ecx
	mov	DWORD PTR _diff$7712[ebp], eax

; 278  : 				diff |= 0x80000000;

	mov	edx, DWORD PTR _diff$7712[ebp]
	or	edx, -2147483648			; 80000000H
	mov	DWORD PTR _diff$7712[ebp], edx
$LN12@saveBinary@2:

; 279  : 			}
; 280  : 			_file.writeDword(diff);

	mov	eax, DWORD PTR _diff$7712[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 281  : 		}
; 282  : 		else

	jmp	SHORT $LN10@saveBinary@2
$LN13@saveBinary@2:

; 283  : 			_file.writeDword(-1);

	push	-1
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
$LN10@saveBinary@2:

; 284  : 	}

	jmp	$LN19@saveBinary@2
$LN18@saveBinary@2:

; 285  : 
; 286  : 	_file.writeStr("LEFS");

	push	OFFSET $SG7717
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeStr@DataOut@ozcollide@@QAEHPBD@Z	; ozcollide::DataOut::writeStr

; 287  : 	int posLEFS = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _posLEFS$[ebp], eax

; 288  : 	_file.advance(4);

	push	4
	mov	ecx, DWORD PTR __file$[ebp]
	call	?advance@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::advance

; 289  : 	for (i = 0; i < nbLeafs; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@saveBinary@2
$LN8@saveBinary@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN9@saveBinary@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _nbLeafs$[ebp]
	jge	$LN7@saveBinary@2

; 290  : 		AABBTreePolygonLeaf *leaf = &leafs_[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _leaf$7722[ebp], eax

; 291  : 
; 292  : 		_file.writeFloat(leaf->aabb.center.x);

	mov	edx, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 293  : 		_file.writeFloat(leaf->aabb.center.y);

	mov	eax, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 294  : 		_file.writeFloat(leaf->aabb.center.z);

	mov	ecx, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 295  : 		_file.writeFloat(leaf->aabb.extent.x);

	mov	edx, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 296  : 		_file.writeFloat(leaf->aabb.extent.y);

	mov	eax, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [eax+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 297  : 		_file.writeFloat(leaf->aabb.extent.z);

	mov	ecx, DWORD PTR _leaf$7722[ebp]
	push	ecx
	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeFloat@DataOut@ozcollide@@QAEHM@Z	; ozcollide::DataOut::writeFloat

; 298  : 
; 299  : 		_file.writeDword(leaf->nbPolys);

	mov	edx, DWORD PTR _leaf$7722[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 300  : 
; 301  : 		for (j = 0; j < leaf->nbPolys; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN6@saveBinary@2
$LN5@saveBinary@2:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN6@saveBinary@2:
	mov	edx, DWORD PTR _leaf$7722[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN4@saveBinary@2

; 302  : 			const Polygon &pol = leaf->polys[j];

	mov	ecx, DWORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _leaf$7722[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$7726[ebp], ecx

; 303  : 			int nbVerts = pol.getNbIndices();

	mov	ecx, DWORD PTR _pol$7726[ebp]
	call	?getNbIndices@Polygon@ozcollide@@QBEHXZ	; ozcollide::Polygon::getNbIndices
	mov	DWORD PTR _nbVerts$7727[ebp], eax

; 304  : 			_file.writeDword(nbVerts);

	mov	eax, DWORD PTR _nbVerts$7727[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 305  : 			for (k = 0; k < nbVerts; k++)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN3@saveBinary@2
$LN2@saveBinary@2:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN3@saveBinary@2:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _nbVerts$7727[ebp]
	jge	SHORT $LN1@saveBinary@2

; 306  : 				_file.writeDword(pol.getIndex(k));

	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pol$7726[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword
	jmp	SHORT $LN2@saveBinary@2
$LN1@saveBinary@2:

; 307  : 		}

	jmp	SHORT $LN5@saveBinary@2
$LN4@saveBinary@2:

; 308  : 	}

	jmp	$LN8@saveBinary@2
$LN7@saveBinary@2:

; 309  : 	pos = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _pos$[ebp], eax

; 310  : 	_file.seek(posLEFS);

	mov	ecx, DWORD PTR _posLEFS$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 311  : 	_file.writeDword(pos - posLEFS - 4);

	mov	edx, DWORD PTR _pos$[ebp]
	sub	edx, DWORD PTR _posLEFS$[ebp]
	sub	edx, 4
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 312  : 	_file.seek(pos);

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 313  : 
; 314  : 	pos = _file.tell();

	mov	ecx, DWORD PTR __file$[ebp]
	call	?tell@DataOut@ozcollide@@QBEHXZ		; ozcollide::DataOut::tell
	mov	DWORD PTR _pos$[ebp], eax

; 315  : 	_file.seek(posBBT);

	mov	ecx, DWORD PTR _posBBT$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 316  : 	_file.writeDword(pos - posBBT - 4);

	mov	edx, DWORD PTR _pos$[ebp]
	sub	edx, DWORD PTR _posBBT$[ebp]
	sub	edx, 4
	push	edx
	mov	ecx, DWORD PTR __file$[ebp]
	call	?writeDword@DataOut@ozcollide@@QAEHH@Z	; ozcollide::DataOut::writeDword

; 317  : 	_file.seek(pos);

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	mov	ecx, DWORD PTR __file$[ebp]
	call	?seek@DataOut@ozcollide@@QAE_NH@Z	; ozcollide::DataOut::seek

; 318  : 
; 319  : 	return NOERR;

	xor	eax, eax

; 320  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z ENDP ; ozcollide::AABBTreePoly::saveBinary
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree.h
_TEXT	ENDS
;	COMDAT ?getNbNodes@AABBTree@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbNodes@AABBTree@ozcollide@@QBEHXZ PROC		; ozcollide::AABBTree::getNbNodes, COMDAT
; _this$ = ecx

; 80   : 	ozinline int getNbNodes() const { return nbNodes_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbNodes@AABBTree@ozcollide@@QBEHXZ ENDP		; ozcollide::AABBTree::getNbNodes
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getNbLeafs@AABBTree@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbLeafs@AABBTree@ozcollide@@QBEHXZ PROC		; ozcollide::AABBTree::getNbLeafs, COMDAT
; _this$ = ecx

; 81   : 	ozinline int getNbLeafs() const { return nbLeafs_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbLeafs@AABBTree@ozcollide@@QBEHXZ ENDP		; ozcollide::AABBTree::getNbLeafs
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\polygon.h
_TEXT	ENDS
;	COMDAT ?getNbIndices@Polygon@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbIndices@Polygon@ozcollide@@QBEHXZ PROC		; ozcollide::Polygon::getNbIndices, COMDAT
; _this$ = ecx

; 56   : 	ozinline int getNbIndices() const { return nbIndices_ & 0xff; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	and	eax, 255				; 000000ffH
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbIndices@Polygon@ozcollide@@QBEHXZ ENDP		; ozcollide::Polygon::getNbIndices
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getIndex@Polygon@ozcollide@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getIndex@Polygon@ozcollide@@QBEHH@Z PROC		; ozcollide::Polygon::getIndex, COMDAT
; _this$ = ecx

; 58   : 	ozinline int getIndex(int i) const { return indices_[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+4]
	mov	esp, ebp
	pop	ebp
	ret	4
?getIndex@Polygon@ozcollide@@QBEHH@Z ENDP		; ozcollide::Polygon::getIndex
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector@4:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector@4
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector@4
$LN3@vector@4:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??1OBB@ozcollide@@QAE@XZ			; ozcollide::OBB::~OBB
PUBLIC	??0OBB@ozcollide@@QAE@XZ			; ozcollide::OBB::OBB
PUBLIC	??0Ellipsoid@ozcollide@@QAE@XZ			; ozcollide::Ellipsoid::Ellipsoid
PUBLIC	??0Sphere@ozcollide@@QAE@XZ			; ozcollide::Sphere::Sphere
PUBLIC	??_7AABBTreePoly@ozcollide@@6B@			; ozcollide::AABBTreePoly::`vftable'
PUBLIC	??_R4AABBTreePoly@ozcollide@@6B@		; ozcollide::AABBTreePoly::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAABBTreePoly@ozcollide@@@8		; ozcollide::AABBTreePoly `RTTI Type Descriptor'
PUBLIC	??_R3AABBTreePoly@ozcollide@@8			; ozcollide::AABBTreePoly::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AABBTreePoly@ozcollide@@8			; ozcollide::AABBTreePoly::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AABBTreePoly@ozcollide@@8		; ozcollide::AABBTreePoly::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@AABBTree@ozcollide@@8		; ozcollide::AABBTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAABBTree@ozcollide@@@8			; ozcollide::AABBTree `RTTI Type Descriptor'
PUBLIC	??_R3AABBTree@ozcollide@@8			; ozcollide::AABBTree::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AABBTree@ozcollide@@8			; ozcollide::AABBTree::`RTTI Base Class Array'
PUBLIC	?scale@AABBTreePoly@ozcollide@@UAEXM@Z		; ozcollide::AABBTreePoly::scale
PUBLIC	?getMemoryConsumption@AABBTreePoly@ozcollide@@UBEHXZ ; ozcollide::AABBTreePoly::getMemoryConsumption
EXTRN	??1AABBTree@ozcollide@@EAE@XZ:PROC		; ozcollide::AABBTree::~AABBTree
EXTRN	??0AABBTree@ozcollide@@AAE@W4AABBTREE_LEAFTYPE@1@H@Z:PROC ; ozcollide::AABBTree::AABBTree
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EAABBTreePoly@ozcollide@@EAEPAXI@Z:PROC	; ozcollide::AABBTreePoly::`vector deleting destructor'
;	COMDAT ??_R2AABBTree@ozcollide@@8
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
rdata$r	SEGMENT
??_R2AABBTree@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@AABBTree@ozcollide@@8 ; ozcollide::AABBTree::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AABBTree@ozcollide@@8
rdata$r	SEGMENT
??_R3AABBTree@ozcollide@@8 DD 00H			; ozcollide::AABBTree::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTree@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVAABBTree@ozcollide@@@8 DD FLAT:??_7type_info@@6B@ ; ozcollide::AABBTree `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAABBTree@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTree@ozcollide@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTree@ozcollide@@8 DD FLAT:??_R0?AVAABBTree@ozcollide@@@8 ; ozcollide::AABBTree::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTreePoly@ozcollide@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTreePoly@ozcollide@@8 DD FLAT:??_R0?AVAABBTreePoly@ozcollide@@@8 ; ozcollide::AABBTreePoly::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AABBTreePoly@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R2AABBTreePoly@ozcollide@@8
rdata$r	SEGMENT
??_R2AABBTreePoly@ozcollide@@8 DD FLAT:??_R1A@?0A@EA@AABBTreePoly@ozcollide@@8 ; ozcollide::AABBTreePoly::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AABBTree@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R3AABBTreePoly@ozcollide@@8
rdata$r	SEGMENT
??_R3AABBTreePoly@ozcollide@@8 DD 00H			; ozcollide::AABBTreePoly::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2AABBTreePoly@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTreePoly@ozcollide@@@8
_DATA	SEGMENT
??_R0?AVAABBTreePoly@ozcollide@@@8 DD FLAT:??_7type_info@@6B@ ; ozcollide::AABBTreePoly `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAABBTreePoly@ozcollide@@', 00H
_DATA	ENDS
;	COMDAT ??_R4AABBTreePoly@ozcollide@@6B@
rdata$r	SEGMENT
??_R4AABBTreePoly@ozcollide@@6B@ DD 00H			; ozcollide::AABBTreePoly::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAABBTreePoly@ozcollide@@@8
	DD	FLAT:??_R3AABBTreePoly@ozcollide@@8
rdata$r	ENDS
;	COMDAT ??_7AABBTreePoly@ozcollide@@6B@
CONST	SEGMENT
??_7AABBTreePoly@ozcollide@@6B@ DD FLAT:??_R4AABBTreePoly@ozcollide@@6B@ ; ozcollide::AABBTreePoly::`vftable'
	DD	FLAT:??_EAABBTreePoly@ozcollide@@EAEPAXI@Z
	DD	FLAT:?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@AAVDataOut@2@@Z
	DD	FLAT:?saveBinary@AABBTreePoly@ozcollide@@UAE?AW4ERR@2@PBD@Z
	DD	FLAT:?scale@AABBTreePoly@ozcollide@@UAEXM@Z
	DD	FLAT:?getMemoryConsumption@AABBTreePoly@ozcollide@@UBEHXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0AABBTreePoly@ozcollide@@AAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$2
__ehfuncinfo$??0AABBTreePoly@ozcollide@@AAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0AABBTreePoly@ozcollide@@AAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__leafDepth$ = 8					; size = 4
??0AABBTreePoly@ozcollide@@AAE@H@Z PROC			; ozcollide::AABBTreePoly::AABBTreePoly
; _this$ = ecx

; 41   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AABBTreePoly@ozcollide@@AAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __leafDepth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0AABBTree@ozcollide@@AAE@W4AABBTREE_LEAFTYPE@1@H@Z ; ozcollide::AABBTree::AABBTree
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7AABBTreePoly@ozcollide@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Sphere@ozcollide@@QAE@XZ		; ozcollide::Sphere::Sphere
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??0Ellipsoid@ozcollide@@QAE@XZ		; ozcollide::Ellipsoid::Ellipsoid
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??0OBB@ozcollide@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 42   : 	points_ = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 43   : 	leafs_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 44   : 	bufEdges_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], 0

; 45   : 	offBufEdges_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+244], 0

; 46   : 	bufPols_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+248], 0

; 47   : 	offBufPols_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+252], 0

; 48   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__unwindfunclet$??0AABBTreePoly@ozcollide@@AAE@H@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1OBB@ozcollide@@QAE@XZ
__ehhandler$??0AABBTreePoly@ozcollide@@AAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AABBTreePoly@ozcollide@@AAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AABBTreePoly@ozcollide@@AAE@H@Z ENDP			; ozcollide::AABBTreePoly::AABBTreePoly
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\sphere.h
;	COMDAT ??0Sphere@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Sphere@ozcollide@@QAE@XZ PROC			; ozcollide::Sphere::Sphere, COMDAT
; _this$ = ecx

; 36   : 	Sphere() { };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Sphere@ozcollide@@QAE@XZ ENDP			; ozcollide::Sphere::Sphere
_TEXT	ENDS
PUBLIC	??0Vec3f@ozcollide@@QAE@MMM@Z			; ozcollide::Vec3f::Vec3f
PUBLIC	__real@00000000
;	COMDAT __real@00000000
; File i:\svnroot\client\sdk\ozcollide\ellipsoid.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Ellipsoid@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Ellipsoid@ozcollide@@QAE@XZ PROC			; ozcollide::Ellipsoid::Ellipsoid, COMDAT
; _this$ = ecx

; 35   : 	ozinline Ellipsoid() : center_(Vec3f(0, 0, 0)), radii_(Vec3f(0, 0, 0)) { };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vec3f@ozcollide@@QAE@XZ		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Ellipsoid@ozcollide@@QAE@XZ ENDP			; ozcollide::Ellipsoid::Ellipsoid
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??0Vec3f@ozcollide@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0Vec3f@ozcollide@@QAE@MMM@Z PROC			; ozcollide::Vec3f::Vec3f, COMDAT
; _this$ = ecx

; 42   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR __x$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __y$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR __z$[ebp]
	fstp	DWORD PTR [edx+8]

; 43   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vec3f@ozcollide@@QAE@MMM@Z ENDP			; ozcollide::Vec3f::Vec3f
_TEXT	ENDS
PUBLIC	??1AABBTreePoly@ozcollide@@EAE@XZ		; ozcollide::AABBTreePoly::~AABBTreePoly
; Function compile flags: /Odtp
;	COMDAT ??_GAABBTreePoly@ozcollide@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAABBTreePoly@ozcollide@@EAEPAXI@Z PROC		; ozcollide::AABBTreePoly::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTreePoly@ozcollide@@EAE@XZ	; ozcollide::AABBTreePoly::~AABBTreePoly
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GAABBTreePoly@ozcollide@@EAEPAXI@Z ENDP		; ozcollide::AABBTreePoly::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0OBB@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0OBB@ozcollide@@QAE@XZ$0
__ehfuncinfo$??0OBB@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0OBB@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0OBB@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0OBB@ozcollide@@QAE@XZ PROC				; ozcollide::OBB::OBB, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0OBB@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Box@ozcollide@@QAE@XZ		; ozcollide::Box::Box
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0OBB@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??0OBB@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0OBB@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0OBB@ozcollide@@QAE@XZ ENDP				; ozcollide::OBB::OBB
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBB@ozcollide@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBB@ozcollide@@QAE@XZ$0
__ehfuncinfo$??1OBB@ozcollide@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBB@ozcollide@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1OBB@ozcollide@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBB@ozcollide@@QAE@XZ PROC				; ozcollide::OBB::~OBB, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1OBB@ozcollide@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBB@ozcollide@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__ehhandler$??1OBB@ozcollide@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1OBB@ozcollide@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1OBB@ozcollide@@QAE@XZ ENDP				; ozcollide::OBB::~OBB
xdata$x	SEGMENT
__unwindtable$??1AABBTreePoly@ozcollide@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$2
__ehfuncinfo$??1AABBTreePoly@ozcollide@@EAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1AABBTreePoly@ozcollide@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -32						; size = 4
_this$ = -28						; size = 4
$T8599 = -24						; size = 4
$T8598 = -20						; size = 4
$T8597 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1AABBTreePoly@ozcollide@@EAE@XZ PROC			; ozcollide::AABBTreePoly::~AABBTreePoly
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1AABBTreePoly@ozcollide@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7AABBTreePoly@ozcollide@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 52   : 	SAFE_ARRAYDELETE(points_);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN2@AABBTreePo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T8597[ebp], eax
	mov	ecx, DWORD PTR $T8597[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
$LN2@AABBTreePo:

; 53   : 	SAFE_ARRAYDELETE(leafs_);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN3@AABBTreePo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR $T8599[ebp], edx
	mov	eax, DWORD PTR $T8599[ebp]
	mov	DWORD PTR $T8598[ebp], eax
	cmp	DWORD PTR $T8598[ebp], 0
	je	SHORT $LN5@AABBTreePo
	push	3
	mov	ecx, DWORD PTR $T8598[ebp]
	call	??_EAABBTreePolygonLeaf@ozcollide@@QAEPAXI@Z
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN6@AABBTreePo
$LN5@AABBTreePo:
	mov	DWORD PTR tv90[ebp], 0
$LN6@AABBTreePo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
$LN3@AABBTreePo:

; 54   : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	??1OBB@ozcollide@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1AABBTree@ozcollide@@EAE@XZ		; ozcollide::AABBTree::~AABBTree
__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1Box@ozcollide@@QAE@XZ		; ozcollide::Box::~Box
__unwindfunclet$??1AABBTreePoly@ozcollide@@EAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1OBB@ozcollide@@QAE@XZ
__ehhandler$??1AABBTreePoly@ozcollide@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1AABBTreePoly@ozcollide@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AABBTreePoly@ozcollide@@EAE@XZ ENDP			; ozcollide::AABBTreePoly::~AABBTreePoly
PUBLIC	?setNormal@Polygon@ozcollide@@QAEXABVVec3f@2@@Z	; ozcollide::Polygon::setNormal
PUBLIC	?normalize@Vec3f@ozcollide@@QAEXXZ		; ozcollide::Vec3f::normalize
PUBLIC	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator|
PUBLIC	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator-
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -68						; size = 4
_rel2$7777 = -64					; size = 4
_rel1$7776 = -60					; size = 4
_normal$7783 = -56					; size = 12
_vec1$7779 = -44					; size = 12
_rel3$7778 = -32					; size = 4
_vec2$7781 = -28					; size = 12
_pol$7774 = -16						; size = 4
_leaf$7770 = -12					; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
?final@AABBTreePoly@ozcollide@@AAEXXZ PROC		; ozcollide::AABBTreePoly::final
; _this$ = ecx

; 57   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 	int i, j;
; 59   : 
; 60   : 	for (i = 0; i < nbLeafs_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@final
$LN5@final:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@final:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jge	$LN7@final

; 61   : 		AABBTreePolygonLeaf *leaf = &leafs_[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _leaf$7770[ebp], eax

; 62   : 		for (j = 0; j < leaf->nbPolys; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN3@final
$LN2@final:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN3@final:
	mov	eax, DWORD PTR _leaf$7770[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	$LN1@final

; 63   : 			Polygon &pol = (Polygon&) leaf->polys[j];

	mov	edx, DWORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _leaf$7770[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _pol$7774[ebp], edx

; 64   : 
; 65   : 			int rel1 = pol.getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$7774[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _rel1$7776[ebp], eax

; 66   : 			int rel2 = pol.getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$7774[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _rel2$7777[ebp], eax

; 67   : 			int rel3 = pol.getIndex(pol.getNbIndices() - 1);

	mov	ecx, DWORD PTR _pol$7774[ebp]
	call	?getNbIndices@Polygon@ozcollide@@QBEHXZ	; ozcollide::Polygon::getNbIndices
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pol$7774[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _rel3$7778[ebp], eax

; 68   : 
; 69   : 			Vec3f vec1 = points_[rel2] - points_[rel1];

	mov	ecx, DWORD PTR _rel1$7776[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	lea	eax, DWORD PTR _vec1$7779[ebp]
	push	eax
	mov	ecx, DWORD PTR _rel2$7777[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 70   : 			Vec3f vec2 = points_[rel3] - points_[rel1];

	mov	eax, DWORD PTR _rel1$7776[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	push	eax
	lea	edx, DWORD PTR _vec2$7781[ebp]
	push	edx
	mov	ecx, DWORD PTR _rel3$7778[ebp]
	imul	ecx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+44]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 71   : 			Vec3f normal = vec2 | vec1;

	lea	ecx, DWORD PTR _vec1$7779[ebp]
	push	ecx
	lea	edx, DWORD PTR _normal$7783[ebp]
	push	edx
	lea	ecx, DWORD PTR _vec2$7781[ebp]
	call	??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator|

; 72   : 			normal.normalize();

	lea	ecx, DWORD PTR _normal$7783[ebp]
	call	?normalize@Vec3f@ozcollide@@QAEXXZ	; ozcollide::Vec3f::normalize

; 73   : 			pol.setNormal(normal);

	lea	eax, DWORD PTR _normal$7783[ebp]
	push	eax
	mov	ecx, DWORD PTR _pol$7774[ebp]
	call	?setNormal@Polygon@ozcollide@@QAEXABVVec3f@2@@Z ; ozcollide::Polygon::setNormal

; 74   : 		}

	jmp	$LN2@final
$LN1@final:

; 75   : 	}

	jmp	$LN5@final
$LN7@final:

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?final@AABBTreePoly@ozcollide@@AAEXXZ ENDP		; ozcollide::AABBTreePoly::final
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator-, COMDAT
; _this$ = ecx

; 94   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		return Vec3f(x - _v.x, y - _v.y, z - _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv146 = -16						; size = 4
tv141 = -12						; size = 4
tv136 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__d$ = 12						; size = 4
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator|, COMDAT
; _this$ = ecx

; 125  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 		return Vec3f(y * _d.z - z * _d.y,
; 127  : 			z * _d.x - x * _d.z,
; 128  : 			x * _d.y - y * _d.x);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv136[ebp]
	fld	DWORD PTR tv136[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv141[ebp]
	fld	DWORD PTR tv141[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __d$[ebp]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv146[ebp]
	fld	DWORD PTR tv146[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 129  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??UVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator|
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	?len@Vec3f@ozcollide@@QBEMXZ			; ozcollide::Vec3f::len
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?normalize@Vec3f@ozcollide@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_ln$ = -8						; size = 4
_div$ = -4						; size = 4
?normalize@Vec3f@ozcollide@@QAEXXZ PROC			; ozcollide::Vec3f::normalize, COMDAT
; _this$ = ecx

; 168  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		float ln = len();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?len@Vec3f@ozcollide@@QBEMXZ		; ozcollide::Vec3f::len
	fstp	DWORD PTR _ln$[ebp]

; 170  : 		if (!ln)

	fld	DWORD PTR _ln$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@normalize

; 171  : 			return;

	jmp	SHORT $LN2@normalize
$LN1@normalize:

; 172  : 		float div = 1.0f / ln;

	fld	DWORD PTR _ln$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _div$[ebp]

; 173  : 		x *= div;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _div$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 174  : 		y *= div;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _div$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 175  : 		z *= div;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _div$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]
$LN2@normalize:

; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?normalize@Vec3f@ozcollide@@QAEXXZ ENDP			; ozcollide::Vec3f::normalize
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
;	COMDAT ?len@Vec3f@ozcollide@@QBEMXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_len$ = -4						; size = 4
?len@Vec3f@ozcollide@@QBEMXZ PROC			; ozcollide::Vec3f::len, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		float len = x * x + y * y + z * z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _len$[ebp]

; 154  : 		return (float) sqrt(len);

	push	ecx
	fld	DWORD PTR _len$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 155  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?len@Vec3f@ozcollide@@QBEMXZ ENDP			; ozcollide::Vec3f::len
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\polygon.h
_TEXT	ENDS
;	COMDAT ?setNormal@Polygon@ozcollide@@QAEXABVVec3f@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
?setNormal@Polygon@ozcollide@@QAEXABVVec3f@2@@Z PROC	; ozcollide::Polygon::setNormal, COMDAT
; _this$ = ecx

; 63   : 	ozinline void setNormal(const Vec3f &normal) { normal_ = normal; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _normal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	4
?setNormal@Polygon@ozcollide@@QAEXABVVec3f@2@@Z ENDP	; ozcollide::Polygon::setNormal
_TEXT	ENDS
PUBLIC	?getNbPoints@AABBTreePoly@ozcollide@@QBEHXZ	; ozcollide::AABBTreePoly::getNbPoints
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbPoints@AABBTreePoly@ozcollide@@QBEHXZ PROC	; ozcollide::AABBTreePoly::getNbPoints
; _this$ = ecx

; 79   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 	return nbPoints_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNbPoints@AABBTreePoly@ozcollide@@QBEHXZ ENDP	; ozcollide::AABBTreePoly::getNbPoints
_TEXT	ENDS
PUBLIC	?getPointsList@AABBTreePoly@ozcollide@@QBEPBVVec3f@2@XZ ; ozcollide::AABBTreePoly::getPointsList
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPointsList@AABBTreePoly@ozcollide@@QBEPBVVec3f@2@XZ PROC ; ozcollide::AABBTreePoly::getPointsList
; _this$ = ecx

; 84   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 	return points_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getPointsList@AABBTreePoly@ozcollide@@QBEPBVVec3f@2@XZ ENDP ; ozcollide::AABBTreePoly::getPointsList
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_size$ = -4						; size = 4
?getMemoryConsumption@AABBTreePoly@ozcollide@@UBEHXZ PROC ; ozcollide::AABBTreePoly::getMemoryConsumption
; _this$ = ecx

; 89   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 	int size = 0;

	mov	DWORD PTR _size$[ebp], 0

; 91   : 	size += getNbNodes() * sizeof(AABBTreeNode);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbNodes@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbNodes
	shl	eax, 5
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 92   : 	size += getNbLeafs() * sizeof(AABBTreePolygonLeaf);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNbLeafs@AABBTree@ozcollide@@QBEHXZ	; ozcollide::AABBTree::getNbLeafs
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], eax

; 93   : 
; 94   : 	int t = sizeof *points_;

	mov	DWORD PTR _t$[ebp], 12			; 0000000cH

; 95   : 	size += nbPoints_ * t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	imul	ecx, DWORD PTR _t$[ebp]
	add	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR _size$[ebp], ecx

; 96   : 
; 97   : 	size += sizeof *this;

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 256				; 00000100H
	mov	DWORD PTR _size$[ebp], edx

; 98   : 
; 99   : 	return size;

	mov	eax, DWORD PTR _size$[ebp]

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryConsumption@AABBTreePoly@ozcollide@@UBEHXZ ENDP ; ozcollide::AABBTreePoly::getMemoryConsumption
_TEXT	ENDS
PUBLIC	?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
PUBLIC	?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithBox
; _this$ = ecx

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 107  : 	box_ = _box;

	mov	ecx, DWORD PTR __box$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx

; 108  : 	boxColRes_ = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 109  : 	return isCollideWithBox(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithBox
_TEXT	ENDS
PUBLIC	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize
PUBLIC	??A?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEAAPBVPolygon@1@H@Z ; ozcollide::Vector<ozcollide::Polygon const *>::operator[]
PUBLIC	?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Polygon const *>::size
PUBLIC	?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
EXTRN	?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z:PROC ; ozcollide::testIntersectionTriBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_res$7808 = -1						; size = 1
__box$ = 8						; size = 4
__cr$ = 12						; size = 4
?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithBox
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	if (bUseTemporalCoherence_ && _cr.polys_.size() != 0) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	SHORT $LN2@isCollideW
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Polygon const *>::size
	test	eax, eax
	je	SHORT $LN2@isCollideW

; 115  : 		bool res = testIntersectionTriBox(*_cr.polys_[0], points_, _box);

	mov	edx, DWORD PTR __box$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	??A?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEAAPBVPolygon@1@H@Z ; ozcollide::Vector<ozcollide::Polygon const *>::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _res$7808[ebp], al

; 116  : 		if (res == true) {

	movzx	eax, BYTE PTR _res$7808[ebp]
	cmp	eax, 1
	jne	SHORT $LN2@isCollideW

; 117  : 			nbColls_ = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 1

; 118  : 			return true;

	mov	al, 1
	jmp	$LN3@isCollideW
$LN2@isCollideW:

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 123  : 	box_ = _box;

	mov	eax, DWORD PTR __box$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 124  : 
; 125  : 	boxColRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+56], edx

; 126  : 	boxColRes_->boxQuery_ = _box;

	mov	eax, DWORD PTR __box$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], eax

; 127  : 	boxColRes_->polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 128  : 	return isCollideWithBox(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
$LN3@isCollideW:

; 129  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isCollideWithBox@AABBTreePoly@ozcollide@@QAE_NABVBox@2@AAVBoxColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithBox
_TEXT	ENDS
PUBLIC	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
PUBLIC	??XVec3f@ozcollide@@QAEXM@Z			; ozcollide::Vec3f::operator*=
PUBLIC	?isInside@Box@ozcollide@@QBE_NABV12@@Z		; ozcollide::Box::isInside
PUBLIC	?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z ; ozcollide::AABBTreePoly::collideWithBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
__cr$ = 12						; size = 4
?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z PROC ; ozcollide::AABBTreePoly::collideWithBox
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 	if (bUseTemporalCoherence_ == true) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	cmp	ecx, 1
	jne	SHORT $LN3@collideWit

; 134  : 		if (_box.isInside(_cr.boxQuery_)) {

	mov	edx, DWORD PTR __cr$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR __box$[ebp]
	call	?isInside@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isInside
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@collideWit

; 135  : 			nbColls_ = _cr.polys_.size();

	mov	ecx, DWORD PTR __cr$[ebp]
	call	?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Polygon const *>::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], eax

; 136  : 			return;

	jmp	$LN4@collideWit
$LN2@collideWit:

; 137  : 		}
; 138  : 
; 139  : 		// Too bad, will do normal query with an inflated volume
; 140  : 		box_ = _box;

	mov	edx, DWORD PTR __box$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx

; 141  : 		box_.extent *= coefVolInflater_;

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+28]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 142  : 	}
; 143  : 	else {

	jmp	SHORT $LN1@collideWit
$LN3@collideWit:

; 144  : 		box_ = _box;

	mov	ecx, DWORD PTR __box$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
$LN1@collideWit:

; 145  : 	}
; 146  : 
; 147  : 	_cr.boxQuery_ = box_;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	mov	eax, DWORD PTR __cr$[ebp]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx

; 148  : 	callback_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 149  : 	boxColRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+56], edx

; 150  : 	_cr.polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 151  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 152  : 
; 153  : 	collideWithBox(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
$LN4@collideWit:

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@AAVBoxColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::collideWithBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??XVec3f@ozcollide@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__mul$ = 8						; size = 4
??XVec3f@ozcollide@@QAEXM@Z PROC			; ozcollide::Vec3f::operator*=, COMDAT
; _this$ = ecx

; 72   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 		x *= _mul;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR __mul$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 74   : 		y *= _mul;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR __mul$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 75   : 		z *= _mul;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR __mul$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 76   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVec3f@ozcollide@@QAEXM@Z ENDP			; ozcollide::Vec3f::operator*=
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
_TEXT	ENDS
;	COMDAT ?isInside@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isInside@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isInside, COMDAT
; _this$ = ecx

; 132  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		if (center.x - extent.x > _box.center.x - _box.extent.x &&
; 134  : 			center.x + extent.x < _box.center.x + _box.extent.x &&
; 135  : 			center.y - extent.y > _box.center.y - _box.extent.y &&
; 136  : 			center.y + extent.y < _box.center.y + _box.extent.z &&
; 137  : 			center.z - extent.z > _box.center.z - _box.extent.z &&
; 138  : 			center.z + extent.z < _box.center.z + _box.extent.z)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN1@isInside
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+12]
	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN1@isInside
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@isInside
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@isInside
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [edx+20]
	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __box$[ebp]
	fsub	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@isInside
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	mov	ecx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __box$[ebp]
	fadd	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@isInside

; 139  : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isInside
$LN1@isInside:

; 140  : 		
; 141  : 		return false;

	xor	al, al
$LN2@isInside:

; 142  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isInside@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isInside
_TEXT	ENDS
PUBLIC	?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@P6AXABV12@ABVPolygon@2@H0PAX@Z3@Z ; ozcollide::AABBTreePoly::collideWithBox
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
__callback$ = 12					; size = 4
__userCallback$ = 16					; size = 4
?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@P6AXABV12@ABVPolygon@2@H0PAX@Z3@Z PROC ; ozcollide::AABBTreePoly::collideWithBox
; _this$ = ecx

; 159  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 	if (!_callback)

	cmp	DWORD PTR __callback$[ebp], 0
	jne	SHORT $LN1@collideWit@2

; 161  : 		return;

	jmp	SHORT $LN2@collideWit@2
$LN1@collideWit@2:

; 162  : 	callback_ = _callback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __callback$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 163  : 	userCallback_ = _userCallback;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __userCallback$[ebp]
	mov	DWORD PTR [edx+52], eax

; 164  : 	boxColRes_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 165  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 166  : 	box_ = _box;

	mov	eax, DWORD PTR __box$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax

; 167  : 	collideWithBox(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
$LN2@collideWit@2:

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithBox@AABBTreePoly@ozcollide@@QAEXABVBox@2@P6AXABV12@ABVPolygon@2@H0PAX@Z3@Z ENDP ; ozcollide::AABBTreePoly::collideWithBox
_TEXT	ENDS
PUBLIC	?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB
PUBLIC	?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__obb$ = 8						; size = 4
?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithOBB
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 176  : 	obb_ = _obb;

	mov	esi, DWORD PTR __obb$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 176				; 000000b0H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 177  : 	obbColRes_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 178  : 	return isCollideWithOBB(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB

; 179  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithOBB
_TEXT	ENDS
PUBLIC	?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@AAVOBBColResult@12@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__obb$ = 8						; size = 4
__cr$ = 12						; size = 4
?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@AAVOBBColResult@12@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithOBB
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	/*
; 184  : 	if (bUseTemporalCoherence_ && cr.polys_.size() != 0) {
; 185  : 		ozbool res = testIntersectionTriBox(*cr.polys_[0], points_, box);
; 186  : 		if (res == OZTRUE) {
; 187  : 			nbColls_ = 1;
; 188  : 			return OZTRUE;
; 189  : 		}
; 190  : 	}
; 191  : */
; 192  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 193  : 	obb_ = _obb;

	mov	esi, DWORD PTR __obb$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 176				; 000000b0H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 194  : 
; 195  : 	obbColRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 196  : 	obbColRes_->obbQuery_ = _obb;

	mov	esi, DWORD PTR __obb$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [eax+60]
	add	edi, 24					; 00000018H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 197  : 	obbColRes_->polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 198  : 	return isCollideWithOBB(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB

; 199  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?isCollideWithOBB@AABBTreePoly@ozcollide@@QAE_NABVOBB@2@AAVOBBColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithOBB
_TEXT	ENDS
PUBLIC	?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithOBB
PUBLIC	?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@AAVOBBColResult@12@@Z ; ozcollide::AABBTreePoly::collideWithOBB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__obb$ = 8						; size = 4
__cr$ = 12						; size = 4
?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@AAVOBBColResult@12@@Z PROC ; ozcollide::AABBTreePoly::collideWithOBB
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	/*
; 204  : 	if (bUseTemporalCoherence_ == OZTRUE) {
; 205  : 		if (box.isInside(cr.boxQuery_)) {
; 206  : 			nbColls_ = cr.polys_.size();
; 207  : 			return;
; 208  : 		}
; 209  : 
; 210  : 		// Too bad, will do normal query with an inflated volume
; 211  : 		box_ = box;
; 212  : 		box_.extent *= coefVolInflater_;
; 213  : 	}
; 214  : 	else {
; 215  : 	*/
; 216  : 		obb_ = _obb;

	mov	esi, DWORD PTR __obb$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 176				; 000000b0H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 217  : //	}
; 218  : 
; 219  : 	_cr.obbQuery_ = obb_;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 176				; 000000b0H
	mov	edi, DWORD PTR __cr$[ebp]
	add	edi, 24					; 00000018H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 220  : 	callback_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 221  : 	obbColRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 222  : 	_cr.polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 223  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 224  : 
; 225  : 	collideWithOBB(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithOBB

; 226  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@AAVOBBColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::collideWithOBB
_TEXT	ENDS
PUBLIC	?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ; ozcollide::AABBTreePoly::collideWithOBB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__obb$ = 8						; size = 4
__callback$ = 12					; size = 4
__userCallback$ = 16					; size = 4
?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z PROC ; ozcollide::AABBTreePoly::collideWithOBB
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 	if (!_callback)

	cmp	DWORD PTR __callback$[ebp], 0
	jne	SHORT $LN1@collideWit@3

; 233  : 		return;

	jmp	SHORT $LN2@collideWit@3
$LN1@collideWit@3:

; 234  : 	callback_ = _callback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __callback$[ebp]
	mov	DWORD PTR [eax+48], ecx

; 235  : 	userCallback_ = _userCallback;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __userCallback$[ebp]
	mov	DWORD PTR [edx+52], eax

; 236  : 	obbColRes_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 237  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 238  : 	obb_ = _obb;

	mov	esi, DWORD PTR __obb$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 176				; 000000b0H
	mov	ecx, 15					; 0000000fH
	rep movsd

; 239  : 	collideWithBox(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
$LN2@collideWit@3:

; 240  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithOBB@AABBTreePoly@ozcollide@@QAEXABVOBB@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ENDP ; ozcollide::AABBTreePoly::collideWithOBB
_TEXT	ENDS
PUBLIC	?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSphere
PUBLIC	?isCollideWithSphere@AABBTreePoly@ozcollide@@QAE_NABVSphere@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSphere
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__sphere$ = 8						; size = 4
?isCollideWithSphere@AABBTreePoly@ozcollide@@QAE_NABVSphere@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithSphere
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	sphereColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 249  : 	nbColls_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0

; 250  : 	sphere_ = _sphere;

	mov	edx, DWORD PTR __sphere$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 251  : 	return isCollideWithSphere(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSphere

; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithSphere@AABBTreePoly@ozcollide@@QAE_NABVSphere@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithSphere
_TEXT	ENDS
PUBLIC	?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSphere
PUBLIC	?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ; ozcollide::AABBTreePoly::collideWithSphere
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__sphere$ = 8						; size = 4
__callback$ = 12					; size = 4
__userCallback$ = 16					; size = 4
?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z PROC ; ozcollide::AABBTreePoly::collideWithSphere
; _this$ = ecx

; 257  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 258  : 	if (!_callback)

	cmp	DWORD PTR __callback$[ebp], 0
	jne	SHORT $LN1@collideWit@4

; 259  : 		return;

	jmp	SHORT $LN2@collideWit@4
$LN1@collideWit@4:

; 260  : 	sphereColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 261  : 	callback_ = _callback;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __callback$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 262  : 	userCallback_ = _userCallback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __userCallback$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 263  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 264  : 	sphere_ = _sphere;

	mov	eax, DWORD PTR __sphere$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 265  : 	collideWithSphere(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSphere
$LN2@collideWit@4:

; 266  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ENDP ; ozcollide::AABBTreePoly::collideWithSphere
_TEXT	ENDS
PUBLIC	?isCollide@Sphere@ozcollide@@QBE_NABV12@@Z	; ozcollide::Sphere::isCollide
PUBLIC	?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@AAVSphereColResult@12@@Z ; ozcollide::AABBTreePoly::collideWithSphere
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__sphere$ = 8						; size = 4
__cr$ = 12						; size = 4
?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@AAVSphereColResult@12@@Z PROC ; ozcollide::AABBTreePoly::collideWithSphere
; _this$ = ecx

; 269  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 	if (bUseTemporalCoherence_ == true) {

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	cmp	ecx, 1
	jne	SHORT $LN3@collideWit@5

; 271  : 		if (_sphere.isCollide(_cr.sphereQuery_)) {

	mov	edx, DWORD PTR __cr$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR __sphere$[ebp]
	call	?isCollide@Sphere@ozcollide@@QBE_NABV12@@Z ; ozcollide::Sphere::isCollide
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@collideWit@5

; 272  : 			nbColls_ = _cr.polys_.size();

	mov	ecx, DWORD PTR __cr$[ebp]
	call	?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ ; ozcollide::Vector<ozcollide::Polygon const *>::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], eax

; 273  : 			return;

	jmp	$LN4@collideWit@5
$LN2@collideWit@5:

; 274  : 		}
; 275  : 
; 276  : 		// Too bad, will do normal query with an inflated volume
; 277  : 		sphere_ = _sphere;

	mov	edx, DWORD PTR __sphere$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 278  : 		sphere_.radius *= coefVolInflater_;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+136]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+136]

; 279  : 	}
; 280  : 	else {

	jmp	SHORT $LN1@collideWit@5
$LN3@collideWit@5:

; 281  : 		sphere_ = _sphere;

	mov	eax, DWORD PTR __sphere$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
$LN1@collideWit@5:

; 282  : 	}
; 283  : 
; 284  : 	_cr.sphereQuery_ = sphere_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR __cr$[ebp]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx

; 285  : 	callback_ = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 286  : 	sphereColRes_ = &_cr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 287  : 	_cr.polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 288  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 289  : 
; 290  : 	collideWithSphere(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSphere
$LN4@collideWit@5:

; 291  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?collideWithSphere@AABBTreePoly@ozcollide@@QAEXABVSphere@2@AAVSphereColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::collideWithSphere
_TEXT	ENDS
PUBLIC	?lenSq@Vec3f@ozcollide@@QBEMXZ			; ozcollide::Vec3f::lenSq
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\sphere.h
;	COMDAT ?isCollide@Sphere@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_diff$ = -20						; size = 12
_r$ = -8						; size = 4
_sqDist$ = -4						; size = 4
__s$ = 8						; size = 4
?isCollide@Sphere@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Sphere::isCollide, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 		Vec3f diff = _s.center - center;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _diff$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __s$[ebp]
	call	??GVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator-

; 42   : 		float sqDist = diff.lenSq();

	lea	ecx, DWORD PTR _diff$[ebp]
	call	?lenSq@Vec3f@ozcollide@@QBEMXZ		; ozcollide::Vec3f::lenSq
	fstp	DWORD PTR _sqDist$[ebp]

; 43   : 		float r = _s.radius + radius;

	mov	edx, DWORD PTR __s$[ebp]
	fld	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _r$[ebp]

; 44   : 		if (sqDist <= r * r)

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _sqDist$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN1@isCollide

; 45   : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isCollide
$LN1@isCollide:

; 46   : 		return false;

	xor	al, al
$LN2@isCollide:

; 47   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollide@Sphere@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Sphere::isCollide
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ?lenSq@Vec3f@ozcollide@@QBEMXZ
_TEXT	SEGMENT
tv86 = -8						; size = 4
_this$ = -4						; size = 4
?lenSq@Vec3f@ozcollide@@QBEMXZ PROC			; ozcollide::Vec3f::lenSq, COMDAT
; _this$ = ecx

; 158  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 		return x * x + y * y + z * z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]

; 160  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?lenSq@Vec3f@ozcollide@@QBEMXZ ENDP			; ozcollide::Vec3f::lenSq
_TEXT	ENDS
PUBLIC	?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
PUBLIC	?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@QAE_NABVEllipsoid@2@@Z ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__ellip$ = 8						; size = 4
?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@QAE_NABVEllipsoid@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	ellipColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 299  : 	nbColls_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0

; 300  : 	ellip_ = _ellip;

	mov	esi, DWORD PTR __ellip$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 140				; 0000008cH
	mov	ecx, 9
	rep movsd

; 301  : 	return isCollideWithEllipsoid(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithEllipsoid

; 302  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@QAE_NABVEllipsoid@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
_TEXT	ENDS
PUBLIC	?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
PUBLIC	?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__ellip$ = 8						; size = 4
__callback$ = 12					; size = 4
__userCallback$ = 16					; size = 4
?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z PROC ; ozcollide::AABBTreePoly::collideWithEllipsoid
; _this$ = ecx

; 307  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 	if (!_callback)

	cmp	DWORD PTR __callback$[ebp], 0
	jne	SHORT $LN1@collideWit@6

; 309  : 		return;

	jmp	SHORT $LN2@collideWit@6
$LN1@collideWit@6:

; 310  : 	ellipColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 311  : 	callback_ = _callback;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __callback$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 312  : 	userCallback_ = _userCallback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __userCallback$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 313  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 314  : 	ellip_ = _ellip;

	mov	esi, DWORD PTR __ellip$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 140				; 0000008cH
	mov	ecx, 9
	rep movsd

; 315  : 	collideWithEllipsoid(*root_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
$LN2@collideWit@6:

; 316  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ENDP ; ozcollide::AABBTreePoly::collideWithEllipsoid
_TEXT	ENDS
PUBLIC	?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@AAVEllipsoidColResult@12@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__ellip$ = 8						; size = 4
__cr$ = 12						; size = 4
?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@AAVEllipsoidColResult@12@@Z PROC ; ozcollide::AABBTreePoly::collideWithEllipsoid
; _this$ = ecx

; 319  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 320  : //	if (bUseTemporalCoherence_ == OZTRUE) {
; 321  : //		if (sphere.isCollide(cr.sphereQuery_)) {
; 322  : //			nbColls_ = cr.polys_.size();
; 323  : //			return;
; 324  : //		}
; 325  : 
; 326  : 		// Too bad, will do normal query with an inflated volume
; 327  : //		sphere_ = sphere;
; 328  : //		sphere_.radius *= coefVolInflater_;
; 329  : //	}
; 330  : //	else {
; 331  : 		ellip_ = _ellip;

	mov	esi, DWORD PTR __ellip$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 140				; 0000008cH
	mov	ecx, 9
	rep movsd

; 332  : //		sphere_.center = ellip.pos;
; 333  : //		sphere_.radius = ellip.radii.x;
; 334  : //	}
; 335  : 
; 336  : //	invRadii_.x = 1.0f / ellip.radii.x;
; 337  : //	invRadii_.y = 1.0f / ellip.radii.y;
; 338  : //	invRadii_.z = 1.0f / ellip.radii.z;
; 339  : 
; 340  : 	_cr.ellipsoidQuery_ = ellip_;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 140				; 0000008cH
	mov	edi, DWORD PTR __cr$[ebp]
	add	edi, 24					; 00000018H
	mov	ecx, 9
	rep movsd

; 341  : 	callback_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 342  : 	ellipColRes_ = &_cr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [ecx+68], edx

; 343  : 	_cr.polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR __cr$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 344  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 345  : 
; 346  : 	collideWithEllipsoid(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid

; 347  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?collideWithEllipsoid@AABBTreePoly@ozcollide@@QAEXABVEllipsoid@2@AAVEllipsoidColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::collideWithEllipsoid
_TEXT	ENDS
PUBLIC	?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment
PUBLIC	?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0@Z ; ozcollide::AABBTreePoly::isCollideWithSegment
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__seg_pt0$ = 8						; size = 4
__seg_pt1$ = 12						; size = 4
?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0@Z PROC ; ozcollide::AABBTreePoly::isCollideWithSegment
; _this$ = ecx

; 354  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 356  : 	seg_pt0_ = _seg_pt0;

	mov	ecx, DWORD PTR __seg_pt0$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 357  : 	seg_pt1_ = _seg_pt1;

	mov	edx, DWORD PTR __seg_pt1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 358  : 	segmentColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 359  : 	return isCollideWithSegment(*root_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment

; 360  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithSegment
_TEXT	ENDS
PUBLIC	?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0AAVSegmentColResult@12@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
__seg_pt0$ = 8						; size = 4
__seg_pt1$ = 12						; size = 4
__cr$ = 16						; size = 4
?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0AAVSegmentColResult@12@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithSegment
; _this$ = ecx

; 364  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 	nbColls_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], 0

; 366  : 	seg_pt0_ = _seg_pt0;

	mov	ecx, DWORD PTR __seg_pt0$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 367  : 	seg_pt1_ = _seg_pt1;

	mov	edx, DWORD PTR __seg_pt1$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 368  : 
; 369  : 	segmentColRes_ = &_cr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __cr$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 370  : 	segmentColRes_->segmentPt0_ = _seg_pt0;

	mov	edx, DWORD PTR __seg_pt0$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	add	ecx, 24					; 00000018H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 371  : 	segmentColRes_->segmentPt1_ = _seg_pt1;

	mov	eax, DWORD PTR __seg_pt1$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	add	edx, 36					; 00000024H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 372  : 	segmentColRes_->polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 373  : 	return isCollideWithSegment(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment

; 374  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?isCollideWithSegment@AABBTreePoly@ozcollide@@QAE_NABVVec3f@2@0AAVSegmentColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithSegment
_TEXT	ENDS
PUBLIC	?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSegment
PUBLIC	?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ; ozcollide::AABBTreePoly::collideWithSegment
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seg_pt0$ = 8						; size = 4
_seg_pt1$ = 12						; size = 4
_callback$ = 16						; size = 4
_userCallback$ = 20					; size = 4
?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z PROC ; ozcollide::AABBTreePoly::collideWithSegment
; _this$ = ecx

; 380  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 	if (!callback)

	cmp	DWORD PTR _callback$[ebp], 0
	jne	SHORT $LN1@collideWit@7

; 382  : 		return;

	jmp	SHORT $LN2@collideWit@7
$LN1@collideWit@7:

; 383  : 	segmentColRes_ = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 384  : 	callback_ = callback;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _callback$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 385  : 	userCallback_ = userCallback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _userCallback$[ebp]
	mov	DWORD PTR [eax+52], ecx

; 386  : 	nbColls_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], 0

; 387  : 	seg_pt0_ = seg_pt0;

	mov	eax, DWORD PTR _seg_pt0$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 388  : 	seg_pt1_ = seg_pt1;

	mov	ecx, DWORD PTR _seg_pt1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 389  : 	collideWithSegment(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSegment
$LN2@collideWit@7:

; 390  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0P6AXABV12@ABVPolygon@2@HABVBox@2@PAX@Z4@Z ENDP ; ozcollide::AABBTreePoly::collideWithSegment
_TEXT	ENDS
PUBLIC	?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0AAVSegmentColResult@12@@Z ; ozcollide::AABBTreePoly::collideWithSegment
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seg_pt0$ = 8						; size = 4
_seg_pt1$ = 12						; size = 4
_cr$ = 16						; size = 4
?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0AAVSegmentColResult@12@@Z PROC ; ozcollide::AABBTreePoly::collideWithSegment
; _this$ = ecx

; 395  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	cr.segmentPt0_ = seg_pt0;

	mov	eax, DWORD PTR _seg_pt0$[ebp]
	mov	ecx, DWORD PTR _cr$[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 397  : 	cr.segmentPt1_ = seg_pt1;

	mov	ecx, DWORD PTR _seg_pt1$[ebp]
	mov	edx, DWORD PTR _cr$[ebp]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 398  : 	seg_pt0_ = seg_pt0;

	mov	edx, DWORD PTR _seg_pt0$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 399  : 	seg_pt1_ = seg_pt1;

	mov	eax, DWORD PTR _seg_pt1$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 400  : 	callback_ = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 401  : 	segmentColRes_ = &cr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _cr$[ebp]
	mov	DWORD PTR [edx+72], eax

; 402  : 	cr.polys_.resize(0);

	push	0
	mov	ecx, DWORD PTR _cr$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 403  : 	nbColls_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], 0

; 404  : 	collideWithSegment(*root_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSegment

; 405  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?collideWithSegment@AABBTreePoly@ozcollide@@QAEXABVVec3f@2@0AAVSegmentColResult@12@@Z ENDP ; ozcollide::AABBTreePoly::collideWithSegment
_TEXT	ENDS
PUBLIC	?getNbCollidedPrimitives@AABBTreePoly@ozcollide@@QBEHXZ ; ozcollide::AABBTreePoly::getNbCollidedPrimitives
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNbCollidedPrimitives@AABBTreePoly@ozcollide@@QBEHXZ PROC ; ozcollide::AABBTreePoly::getNbCollidedPrimitives
; _this$ = ecx

; 410  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 411  : 	return nbColls_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+236]

; 412  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNbCollidedPrimitives@AABBTreePoly@ozcollide@@QBEHXZ ENDP ; ozcollide::AABBTreePoly::getNbCollidedPrimitives
_TEXT	ENDS
PUBLIC	?add@?$Vector@H@ozcollide@@QAEXABH@Z		; ozcollide::Vector<int>::add
PUBLIC	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add
PUBLIC	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z		; ozcollide::Box::isOverlap
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_user$7926 = -24					; size = 4
_pol$7922 = -20						; size = 4
_res$7923 = -13						; size = 1
_i$7918 = -12						; size = 4
_pl$7915 = -8						; size = 4
_nbPols$7917 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithBox
; _this$ = ecx

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 420  : 	if (_node.aabb.isOverlap(box_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN13@isCollideW@2

; 421  : 		if (!_node.left && !_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN12@isCollideW@2
	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	$LN12@isCollideW@2

; 422  : 			// reach a leaf
; 423  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	ecx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$7915[ebp], ecx

; 424  : 			int nbPols = pl.nbPolys;

	mov	edx, DWORD PTR _pl$7915[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _nbPols$7917[ebp], eax

; 425  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$7918[ebp], 0
	jmp	SHORT $LN11@isCollideW@2
$LN10@isCollideW@2:
	mov	ecx, DWORD PTR _i$7918[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7918[ebp], ecx
$LN11@isCollideW@2:
	mov	edx, DWORD PTR _i$7918[ebp]
	cmp	edx, DWORD PTR _nbPols$7917[ebp]
	jge	$LN9@isCollideW@2

; 426  : 				const Polygon *pol = &pl.polys[i];

	mov	eax, DWORD PTR _i$7918[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pl$7915[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _pol$7922[ebp], eax

; 427  : 				bool res = testIntersectionTriBox(*pol, points_, box_);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	mov	edx, DWORD PTR _pol$7922[ebp]
	push	edx
	call	?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _res$7923[ebp], al

; 428  : 				if (res) {

	movzx	eax, BYTE PTR _res$7923[ebp]
	test	eax, eax
	je	SHORT $LN8@isCollideW@2

; 429  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], edx

; 430  : 					if (boxColRes_) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN7@isCollideW@2

; 431  : 						int user = 0;

	mov	DWORD PTR _user$7926[ebp], 0

; 432  : 						if (pl.users)

	mov	edx, DWORD PTR _pl$7915[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN6@isCollideW@2

; 433  : 							user = pl.users[i];

	mov	eax, DWORD PTR _pl$7915[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$7918[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$7926[ebp], eax
$LN6@isCollideW@2:

; 434  : 						boxColRes_->polys_.add( pol );

	lea	ecx, DWORD PTR _pol$7922[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 435  : 						boxColRes_->users_.add( user );

	lea	eax, DWORD PTR _user$7926[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN7@isCollideW@2:

; 436  : 					}
; 437  : 					return res;

	mov	al, BYTE PTR _res$7923[ebp]
	jmp	SHORT $LN14@isCollideW@2
$LN8@isCollideW@2:

; 438  : 				}
; 439  : 			}

	jmp	$LN10@isCollideW@2
$LN9@isCollideW@2:

; 440  : 		}
; 441  : 		else {

	jmp	SHORT $LN13@isCollideW@2
$LN12@isCollideW@2:

; 442  : 			if (_node.left) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@isCollideW@2

; 443  : 				if (isCollideWithBox(*_node.left) == true)

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN4@isCollideW@2

; 444  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@2
$LN4@isCollideW@2:

; 445  : 			}
; 446  : 			if (_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN13@isCollideW@2

; 447  : 				if (isCollideWithBox(*_node.right) == true)

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithBox
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN13@isCollideW@2

; 448  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@2
$LN13@isCollideW@2:

; 449  : 			}
; 450  : 		}
; 451  : 	}
; 452  : 	return false;

	xor	al, al
$LN14@isCollideW@2:

; 453  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithBox@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithBox
_TEXT	ENDS
PUBLIC	?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnZ
PUBLIC	?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnY
PUBLIC	?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlapOnX
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\box.h
;	COMDAT ?isOverlap@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlap@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlap, COMDAT
; _this$ = ecx

; 85   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 		if (isOverlapOnX(_box) &&
; 87   : 			isOverlapOnY(_box) &&
; 88   : 			isOverlapOnZ(_box))

	mov	eax, DWORD PTR __box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnX
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isOverlap
	mov	edx, DWORD PTR __box$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnY
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@isOverlap
	mov	ecx, DWORD PTR __box$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z ; ozcollide::Box::isOverlapOnZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@isOverlap

; 89   : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isOverlap
$LN1@isOverlap:

; 90   : 
; 91   : 		return false;

	xor	al, al
$LN2@isOverlap:

; 92   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlap@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnX, COMDAT
; _this$ = ecx

; 96   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 		float t = _box.center.x - center.x;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _t$[ebp]

; 98   : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO:

; 99   : 
; 100  : 		float ext = _box.extent.x + extent.x;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fstp	DWORD PTR _ext$[ebp]

; 101  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO

; 102  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO
$LN1@isOverlapO:

; 103  : 		return false;

	xor	al, al
$LN3@isOverlapO:

; 104  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnX@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnX
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnY, COMDAT
; _this$ = ecx

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 		float t = _box.center.y - center.y;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+4]
	fstp	DWORD PTR _t$[ebp]

; 110  : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO@2
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO@2:

; 111  : 
; 112  : 		float ext = _box.extent.y + extent.y;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+16]
	fstp	DWORD PTR _ext$[ebp]

; 113  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO@2

; 114  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO@2
$LN1@isOverlapO@2:

; 115  : 		return false;

	xor	al, al
$LN3@isOverlapO@2:

; 116  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnY@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_t$ = -8						; size = 4
_ext$ = -4						; size = 4
__box$ = 8						; size = 4
?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z PROC		; ozcollide::Box::isOverlapOnZ, COMDAT
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		float t = _box.center.z - center.z;

	mov	eax, DWORD PTR __box$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR _t$[ebp]

; 122  : 		if (t < 0) t = -t;

	fld	DWORD PTR _t$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isOverlapO@3
	fld	DWORD PTR _t$[ebp]
	fchs
	fstp	DWORD PTR _t$[ebp]
$LN2@isOverlapO@3:

; 123  : 
; 124  : 		float ext = _box.extent.z + extent.z;

	mov	edx, DWORD PTR __box$[ebp]
	fld	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+20]
	fstp	DWORD PTR _ext$[ebp]

; 125  : 		if (t <= ext)

	fld	DWORD PTR _t$[ebp]
	fld	DWORD PTR _ext$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@isOverlapO@3

; 126  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isOverlapO@3
$LN1@isOverlapO@3:

; 127  : 		return false;

	xor	al, al
$LN3@isOverlapO@3:

; 128  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isOverlapOnZ@Box@ozcollide@@QBE_NABV12@@Z ENDP		; ozcollide::Box::isOverlapOnZ
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -28						; size = 4
_user$7947 = -24					; size = 4
_pol$7946 = -20						; size = 4
_res$7949 = -13						; size = 1
_i$7942 = -12						; size = 4
_pl$7939 = -8						; size = 4
_nbPols$7941 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::collideWithBox
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 	if (_node.aabb.isOverlap(box_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	call	?isOverlap@Box@ozcollide@@QBE_NABV12@@Z	; ozcollide::Box::isOverlap
	movzx	ecx, al
	cmp	ecx, 1
	jne	$LN13@collideWit@8

; 458  : 		if (!_node.left && !_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$LN11@collideWit@8
	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	$LN11@collideWit@8

; 459  : 			// reach a leaf
; 460  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	ecx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$7939[ebp], ecx

; 461  : 			int nbPols = pl.nbPolys;

	mov	edx, DWORD PTR _pl$7939[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _nbPols$7941[ebp], eax

; 462  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$7942[ebp], 0
	jmp	SHORT $LN10@collideWit@8
$LN9@collideWit@8:
	mov	ecx, DWORD PTR _i$7942[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7942[ebp], ecx
$LN10@collideWit@8:
	mov	edx, DWORD PTR _i$7942[ebp]
	cmp	edx, DWORD PTR _nbPols$7941[ebp]
	jge	$LN8@collideWit@8

; 463  : 				const Polygon *pol = &pl.polys[i];

	mov	eax, DWORD PTR _i$7942[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _pl$7939[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _pol$7946[ebp], eax

; 464  : 				int user = 0;

	mov	DWORD PTR _user$7947[ebp], 0

; 465  : 				if (pl.users)

	mov	edx, DWORD PTR _pl$7939[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN7@collideWit@8

; 466  : 					user = pl.users[i];

	mov	eax, DWORD PTR _pl$7939[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$7942[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$7947[ebp], eax
$LN7@collideWit@8:

; 467  : 				bool res = testIntersectionTriBox(*pol, points_, box_);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _pol$7946[ebp]
	push	ecx
	call	?testIntersectionTriBox@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVBox@1@@Z ; ozcollide::testIntersectionTriBox
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _res$7949[ebp], al

; 468  : 				if (res == true) {

	movzx	edx, BYTE PTR _res$7949[ebp]
	cmp	edx, 1
	jne	SHORT $LN6@collideWit@8

; 469  : 					nbColls_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], ecx

; 470  : 					if (callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@collideWit@8

; 471  : 						callback_(*this, *pol, user, _node.aabb, userCallback_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$7947[ebp]
	push	ecx
	mov	edx, DWORD PTR _pol$7946[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 20					; 00000014H

; 472  : 					else {

	jmp	SHORT $LN6@collideWit@8
$LN5@collideWit@8:

; 473  : 						boxColRes_->polys_.add(pol);

	lea	eax, DWORD PTR _pol$7946[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 474  : 						boxColRes_->users_.add(user);

	lea	edx, DWORD PTR _user$7947[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN6@collideWit@8:

; 475  : 					}
; 476  : 				}
; 477  : 			}

	jmp	$LN9@collideWit@8
$LN8@collideWit@8:

; 478  : 		}
; 479  : 		else {

	jmp	SHORT $LN13@collideWit@8
$LN11@collideWit@8:

; 480  : 			if (_node.left)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN2@collideWit@8

; 481  : 				collideWithBox(*_node.left);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
$LN2@collideWit@8:

; 482  : 			if (_node.right)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN13@collideWit@8

; 483  : 				collideWithBox(*_node.right);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithBox
$LN13@collideWit@8:

; 484  : 		}
; 485  : 	}
; 486  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithBox@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::collideWithBox
_TEXT	ENDS
EXTRN	?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z:PROC ; ozcollide::testIntersectionTriOBB
EXTRN	?testIntersectionAABB_OBB@ozcollide@@YA_NABVBox@1@ABVOBB@1@@Z:PROC ; ozcollide::testIntersectionAABB_OBB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_user$7973 = -24					; size = 4
_pol$7969 = -20						; size = 4
_res$7970 = -13						; size = 1
_i$7965 = -12						; size = 4
_pl$7962 = -8						; size = 4
_nbPols$7964 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithOBB
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 	if (testIntersectionAABB_OBB(_node.aabb, obb_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	push	ecx
	call	?testIntersectionAABB_OBB@ozcollide@@YA_NABVBox@1@ABVOBB@1@@Z ; ozcollide::testIntersectionAABB_OBB
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN13@isCollideW@3

; 497  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN12@isCollideW@3
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN12@isCollideW@3

; 498  : 			// reach a leaf
; 499  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$7962[ebp], edx

; 500  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$7962[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$7964[ebp], ecx

; 501  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$7965[ebp], 0
	jmp	SHORT $LN11@isCollideW@3
$LN10@isCollideW@3:
	mov	edx, DWORD PTR _i$7965[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7965[ebp], edx
$LN11@isCollideW@3:
	mov	eax, DWORD PTR _i$7965[ebp]
	cmp	eax, DWORD PTR _nbPols$7964[ebp]
	jge	$LN9@isCollideW@3

; 502  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$7965[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$7962[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$7969[ebp], ecx

; 503  : 				bool res = testIntersectionTriOBB(*pol, points_, obb_);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	mov	eax, DWORD PTR _pol$7969[ebp]
	push	eax
	call	?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z ; ozcollide::testIntersectionTriOBB
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _res$7970[ebp], al

; 504  : 				if (res) {

	movzx	ecx, BYTE PTR _res$7970[ebp]
	test	ecx, ecx
	je	SHORT $LN8@isCollideW@3

; 505  : 					nbColls_++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+236]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+236], eax

; 506  : 
; 507  : 					if (obbColRes_) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN7@isCollideW@3

; 508  : 						int user = 0;

	mov	DWORD PTR _user$7973[ebp], 0

; 509  : 						if (pl.users)

	mov	eax, DWORD PTR _pl$7962[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN6@isCollideW@3

; 510  : 							user = pl.users[i];

	mov	ecx, DWORD PTR _pl$7962[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR _i$7965[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _user$7973[ebp], ecx
$LN6@isCollideW@3:

; 511  : 
; 512  : 						obbColRes_->polys_.add( pol );

	lea	edx, DWORD PTR _pol$7969[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 513  : 						obbColRes_->users_.add( user );

	lea	ecx, DWORD PTR _user$7973[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN7@isCollideW@3:

; 514  : 					}
; 515  : 					return res;

	mov	al, BYTE PTR _res$7970[ebp]
	jmp	SHORT $LN14@isCollideW@3
$LN8@isCollideW@3:

; 516  : 				}
; 517  : 			}

	jmp	$LN10@isCollideW@3
$LN9@isCollideW@3:

; 518  : 		}
; 519  : 		else {

	jmp	SHORT $LN13@isCollideW@3
$LN12@isCollideW@3:

; 520  : 			if (_node.left) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN4@isCollideW@3

; 521  : 				if (isCollideWithOBB(*_node.left) == true)

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN4@isCollideW@3

; 522  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@3
$LN4@isCollideW@3:

; 523  : 			}
; 524  : 			if (_node.right) {

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN13@isCollideW@3

; 525  : 				if (isCollideWithOBB(*_node.right) == true)

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithOBB
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN13@isCollideW@3

; 526  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@3
$LN13@isCollideW@3:

; 527  : 			}
; 528  : 		}
; 529  : 	}
; 530  : 	return false;

	xor	al, al
$LN14@isCollideW@3:

; 531  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithOBB@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithOBB
; Function compile flags: /Odtp
_this$ = -28						; size = 4
_user$7994 = -24					; size = 4
_pol$7993 = -20						; size = 4
_res$7996 = -13						; size = 1
_i$7989 = -12						; size = 4
_pl$7986 = -8						; size = 4
_nbPols$7988 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::collideWithOBB
; _this$ = ecx

; 534  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 	if (testIntersectionAABB_OBB(_node.aabb, obb_) == true) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 176				; 000000b0H
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	push	ecx
	call	?testIntersectionAABB_OBB@ozcollide@@YA_NABVBox@1@ABVOBB@1@@Z ; ozcollide::testIntersectionAABB_OBB
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN13@collideWit@9

; 536  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN11@collideWit@9
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN11@collideWit@9

; 537  : 			// reach a leaf
; 538  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$7986[ebp], edx

; 539  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$7986[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$7988[ebp], ecx

; 540  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$7989[ebp], 0
	jmp	SHORT $LN10@collideWit@9
$LN9@collideWit@9:
	mov	edx, DWORD PTR _i$7989[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7989[ebp], edx
$LN10@collideWit@9:
	mov	eax, DWORD PTR _i$7989[ebp]
	cmp	eax, DWORD PTR _nbPols$7988[ebp]
	jge	$LN8@collideWit@9

; 541  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$7989[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$7986[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$7993[ebp], ecx

; 542  : 				int user = 0;

	mov	DWORD PTR _user$7994[ebp], 0

; 543  : 				if (user)

	cmp	DWORD PTR _user$7994[ebp], 0
	je	SHORT $LN7@collideWit@9

; 544  : 					user = pl.users[i];

	mov	eax, DWORD PTR _pl$7986[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$7989[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$7994[ebp], eax
$LN7@collideWit@9:

; 545  : 				bool res = testIntersectionTriOBB(*pol, points_, obb_);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _pol$7993[ebp]
	push	ecx
	call	?testIntersectionTriOBB@ozcollide@@YA_NABVPolygon@1@PBVVec3f@1@ABVOBB@1@@Z ; ozcollide::testIntersectionTriOBB
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _res$7996[ebp], al

; 546  : 				if (res == true) {

	movzx	edx, BYTE PTR _res$7996[ebp]
	cmp	edx, 1
	jne	SHORT $LN6@collideWit@9

; 547  : 					nbColls_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], ecx

; 548  : 					if (callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@collideWit@9

; 549  : 						callback_(*this, *pol, user, _node.aabb, userCallback_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$7994[ebp]
	push	ecx
	mov	edx, DWORD PTR _pol$7993[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 20					; 00000014H

; 550  : 					else {

	jmp	SHORT $LN6@collideWit@9
$LN5@collideWit@9:

; 551  : 						obbColRes_->polys_.add(pol);

	lea	eax, DWORD PTR _pol$7993[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 552  : 						obbColRes_->users_.add(user);

	lea	edx, DWORD PTR _user$7994[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN6@collideWit@9:

; 553  : 					}
; 554  : 				}
; 555  : 			}

	jmp	$LN9@collideWit@9
$LN8@collideWit@9:

; 556  : 		}
; 557  : 		else {

	jmp	SHORT $LN13@collideWit@9
$LN11@collideWit@9:

; 558  : 			if (_node.left)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN2@collideWit@9

; 559  : 				collideWithOBB(*_node.left);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithOBB
$LN2@collideWit@9:

; 560  : 			if (_node.right)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN13@collideWit@9

; 561  : 				collideWithOBB(*_node.right);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithOBB
$LN13@collideWit@9:

; 562  : 		}
; 563  : 	}
; 564  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithOBB@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::collideWithOBB
_TEXT	ENDS
EXTRN	?magic_testIntersectionSphereTriangle@ozcollide@@YA_NABVVec3f@1@M000PAM@Z:PROC ; ozcollide::magic_testIntersectionSphereTriangle
EXTRN	?testIntersectionSphereBox@ozcollide@@YA_NABVSphere@1@ABVBox@1@@Z:PROC ; ozcollide::testIntersectionSphereBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_user$8023 = -36					; size = 4
_i2$8019 = -32						; size = 4
_i0$8017 = -28						; size = 4
_i1$8018 = -24						; size = 4
_pol$8016 = -20						; size = 4
_res$8020 = -13						; size = 1
_i$8012 = -12						; size = 4
_pl$8009 = -8						; size = 4
_nbPols$8011 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithSphere
; _this$ = ecx

; 569  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 570  : 	if (testIntersectionSphereBox(sphere_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	call	?testIntersectionSphereBox@ozcollide@@YA_NABVSphere@1@ABVBox@1@@Z ; ozcollide::testIntersectionSphereBox
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN1@isCollideW@4

; 571  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN12@isCollideW@4
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN12@isCollideW@4

; 572  : 			// reach a leaf
; 573  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8009[ebp], edx

; 574  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$8009[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$8011[ebp], ecx

; 575  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8012[ebp], 0
	jmp	SHORT $LN11@isCollideW@4
$LN10@isCollideW@4:
	mov	edx, DWORD PTR _i$8012[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8012[ebp], edx
$LN11@isCollideW@4:
	mov	eax, DWORD PTR _i$8012[ebp]
	cmp	eax, DWORD PTR _nbPols$8011[ebp]
	jge	$LN9@isCollideW@4

; 576  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$8012[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$8009[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$8016[ebp], ecx

; 577  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8016[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8017[ebp], eax

; 578  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8016[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8018[ebp], eax

; 579  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8016[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8019[ebp], eax

; 580  : 				bool res = magic_testIntersectionSphereTriangle(sphere_.center, sphere_.radius,
; 581  : 															points_[i0], points_[i1], points_[i2]);

	push	0
	mov	eax, DWORD PTR _i2$8019[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	push	eax
	mov	edx, DWORD PTR _i1$8018[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+44]
	push	edx
	mov	ecx, DWORD PTR _i0$8017[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+136]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	call	?magic_testIntersectionSphereTriangle@ozcollide@@YA_NABVVec3f@1@M000PAM@Z ; ozcollide::magic_testIntersectionSphereTriangle
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8020[ebp], al

; 582  : 				if (res) {

	movzx	edx, BYTE PTR _res$8020[ebp]
	test	edx, edx
	je	SHORT $LN8@isCollideW@4

; 583  : 					if (sphereColRes_) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $LN7@isCollideW@4

; 584  : 						int user = 0;

	mov	DWORD PTR _user$8023[ebp], 0

; 585  : 						if (pl.users)

	mov	ecx, DWORD PTR _pl$8009[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN6@isCollideW@4

; 586  : 							user = pl.users[i];

	mov	edx, DWORD PTR _pl$8009[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$8012[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _user$8023[ebp], edx
$LN6@isCollideW@4:

; 587  : 
; 588  : 						sphereColRes_->polys_.add( pol );

	lea	eax, DWORD PTR _pol$8016[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+64]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 589  : 						sphereColRes_->users_.add( user );

	lea	edx, DWORD PTR _user$8023[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN7@isCollideW@4:

; 590  : 					}
; 591  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], edx

; 592  : 					return res;

	mov	al, BYTE PTR _res$8020[ebp]
	jmp	SHORT $LN14@isCollideW@4
$LN8@isCollideW@4:

; 593  : 				}
; 594  : 			}

	jmp	$LN10@isCollideW@4
$LN9@isCollideW@4:

; 595  : 		}
; 596  : 		else {

	jmp	SHORT $LN1@isCollideW@4
$LN12@isCollideW@4:

; 597  : 			if (_node.left) {

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN3@isCollideW@4

; 598  : 				if (isCollideWithSphere(*_node.left) == true)

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSphere
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN3@isCollideW@4

; 599  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@4
$LN3@isCollideW@4:

; 600  : 			}
; 601  : 			if (_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN1@isCollideW@4

; 602  : 				if (isCollideWithSphere(*_node.right) == true)

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSphere
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN1@isCollideW@4

; 603  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@4
$LN1@isCollideW@4:

; 604  : 			}
; 605  : 		}
; 606  : 	}
; 607  : 	return false;

	xor	al, al
$LN14@isCollideW@4:

; 608  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithSphere@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithSphere
; Function compile flags: /Odtp
_this$ = -40						; size = 4
_i2$8048 = -36						; size = 4
_user$8044 = -32					; size = 4
_i0$8046 = -28						; size = 4
_i1$8047 = -24						; size = 4
_pol$8043 = -20						; size = 4
_res$8049 = -13						; size = 1
_i$8039 = -12						; size = 4
_pl$8036 = -8						; size = 4
_nbPols$8038 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::collideWithSphere
; _this$ = ecx

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 	if (testIntersectionSphereBox(sphere_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	call	?testIntersectionSphereBox@ozcollide@@YA_NABVSphere@1@ABVBox@1@@Z ; ozcollide::testIntersectionSphereBox
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN1@collideWit@10

; 613  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN11@collideWit@10
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN11@collideWit@10

; 614  : 			// reach a leaf
; 615  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8036[ebp], edx

; 616  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$8036[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$8038[ebp], ecx

; 617  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8039[ebp], 0
	jmp	SHORT $LN10@collideWit@10
$LN9@collideWit@10:
	mov	edx, DWORD PTR _i$8039[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8039[ebp], edx
$LN10@collideWit@10:
	mov	eax, DWORD PTR _i$8039[ebp]
	cmp	eax, DWORD PTR _nbPols$8038[ebp]
	jge	$LN8@collideWit@10

; 618  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$8039[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$8036[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$8043[ebp], ecx

; 619  : 				int user = 0;

	mov	DWORD PTR _user$8044[ebp], 0

; 620  : 				if (user)

	cmp	DWORD PTR _user$8044[ebp], 0
	je	SHORT $LN7@collideWit@10

; 621  : 					user = pl.users[i];

	mov	eax, DWORD PTR _pl$8036[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$8039[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$8044[ebp], eax
$LN7@collideWit@10:

; 622  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8043[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8046[ebp], eax

; 623  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8043[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8047[ebp], eax

; 624  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8043[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8048[ebp], eax

; 625  : 				bool res = magic_testIntersectionSphereTriangle(	sphere_.center, sphere_.radius,
; 626  : 																	points_[i0], points_[i1], points_[i2]);

	push	0
	mov	ecx, DWORD PTR _i2$8048[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	mov	eax, DWORD PTR _i1$8047[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	push	eax
	mov	edx, DWORD PTR _i0$8046[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+44]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+136]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 124				; 0000007cH
	push	edx
	call	?magic_testIntersectionSphereTriangle@ozcollide@@YA_NABVVec3f@1@M000PAM@Z ; ozcollide::magic_testIntersectionSphereTriangle
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8049[ebp], al

; 627  : 				if (res) {

	movzx	eax, BYTE PTR _res$8049[ebp]
	test	eax, eax
	je	SHORT $LN4@collideWit@10

; 628  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], edx

; 629  : 					if (callback_)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN5@collideWit@10

; 630  : 						callback_(*this, *pol, user, _node.aabb, userCallback_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	mov	ecx, DWORD PTR __node$[ebp]
	push	ecx
	mov	edx, DWORD PTR _user$8044[ebp]
	push	edx
	mov	eax, DWORD PTR _pol$8043[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	add	esp, 20					; 00000014H

; 631  : 					else {

	jmp	SHORT $LN4@collideWit@10
$LN5@collideWit@10:

; 632  : 						sphereColRes_->polys_.add(pol);

	lea	ecx, DWORD PTR _pol$8043[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+64]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 633  : 						sphereColRes_->users_.add(user);

	lea	eax, DWORD PTR _user$8044[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+64]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN4@collideWit@10:

; 634  : 					}
; 635  : 				}
; 636  : 			}

	jmp	$LN9@collideWit@10
$LN8@collideWit@10:

; 637  : 		}
; 638  : 		else {

	jmp	SHORT $LN1@collideWit@10
$LN11@collideWit@10:

; 639  : 			if (_node.left)

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN2@collideWit@10

; 640  : 				collideWithSphere(*_node.left);

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSphere
$LN2@collideWit@10:

; 641  : 			if (_node.right)

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN1@collideWit@10

; 642  : 				collideWithSphere(*_node.right);

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSphere
$LN1@collideWit@10:

; 643  : 		}
; 644  : 	}
; 645  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithSphere@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::collideWithSphere
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getCenter
PUBLIC	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z		; ozcollide::Vec3f::operator*
PUBLIC	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
EXTRN	?testIntersectionEllipsoidBox@ozcollide@@YA_NABVEllipsoid@1@ABVBox@1@@Z:PROC ; ozcollide::testIntersectionEllipsoidBox
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_this$ = -88						; size = 4
_user$8084 = -84					; size = 4
_i2$8072 = -80						; size = 4
_pt1$8073 = -76						; size = 12
_pt3$8077 = -64						; size = 12
_i0$8070 = -52						; size = 4
_pt2$8075 = -48						; size = 12
_i1$8071 = -36						; size = 4
_pol$8069 = -32						; size = 4
_res$8081 = -25						; size = 1
_center$8079 = -24					; size = 12
_i$8065 = -12						; size = 4
_pl$8062 = -8						; size = 4
_nbPols$8064 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
; _this$ = ecx

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 652  : 	if (testIntersectionEllipsoidBox(ellip_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	call	?testIntersectionEllipsoidBox@ozcollide@@YA_NABVEllipsoid@1@ABVBox@1@@Z ; ozcollide::testIntersectionEllipsoidBox
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN1@isCollideW@5

; 653  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN12@isCollideW@5
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN12@isCollideW@5

; 654  : 			// reach a leaf
; 655  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8062[ebp], edx

; 656  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$8062[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$8064[ebp], ecx

; 657  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8065[ebp], 0
	jmp	SHORT $LN11@isCollideW@5
$LN10@isCollideW@5:
	mov	edx, DWORD PTR _i$8065[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8065[ebp], edx
$LN11@isCollideW@5:
	mov	eax, DWORD PTR _i$8065[ebp]
	cmp	eax, DWORD PTR _nbPols$8064[ebp]
	jge	$LN9@isCollideW@5

; 658  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$8065[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$8062[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$8069[ebp], ecx

; 659  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8069[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8070[ebp], eax

; 660  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8069[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8071[ebp], eax

; 661  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8069[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8072[ebp], eax

; 662  : 				Vec3f pt1 = points_[i0] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _pt1$8073[ebp]
	push	eax
	mov	ecx, DWORD PTR _i0$8070[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 663  : 				Vec3f pt2 = points_[i1] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _pt2$8075[ebp]
	push	eax
	mov	ecx, DWORD PTR _i1$8071[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 664  : 				Vec3f pt3 = points_[i2] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _pt3$8077[ebp]
	push	eax
	mov	ecx, DWORD PTR _i2$8072[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 665  : 				Vec3f center = ellip_.getCenter() * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _center$8079[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getCenter
	mov	ecx, eax
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 666  : 				bool res = magic_testIntersectionSphereTriangle(center, 1, pt1, pt2, pt3);

	push	0
	lea	ecx, DWORD PTR _pt3$8077[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt2$8075[ebp]
	push	edx
	lea	eax, DWORD PTR _pt1$8073[ebp]
	push	eax
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _center$8079[ebp]
	push	ecx
	call	?magic_testIntersectionSphereTriangle@ozcollide@@YA_NABVVec3f@1@M000PAM@Z ; ozcollide::magic_testIntersectionSphereTriangle
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8081[ebp], al

; 667  : 				if (res) {

	movzx	edx, BYTE PTR _res$8081[ebp]
	test	edx, edx
	je	SHORT $LN8@isCollideW@5

; 668  : 					if (ellipColRes_) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $LN7@isCollideW@5

; 669  : 						int user = 0;

	mov	DWORD PTR _user$8084[ebp], 0

; 670  : 						if (pl.users)

	mov	ecx, DWORD PTR _pl$8062[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN6@isCollideW@5

; 671  : 							user = pl.users[i];

	mov	edx, DWORD PTR _pl$8062[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$8065[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _user$8084[ebp], edx
$LN6@isCollideW@5:

; 672  : 
; 673  : 						ellipColRes_->polys_.add( pol );

	lea	eax, DWORD PTR _pol$8069[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+68]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 674  : 						ellipColRes_->users_.add( user );

	lea	edx, DWORD PTR _user$8084[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN7@isCollideW@5:

; 675  : 					}
; 676  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], edx

; 677  : 					return res;

	mov	al, BYTE PTR _res$8081[ebp]
	jmp	SHORT $LN14@isCollideW@5
$LN8@isCollideW@5:

; 678  : 				}
; 679  : 			}

	jmp	$LN10@isCollideW@5
$LN9@isCollideW@5:

; 680  : 		}
; 681  : 		else {

	jmp	SHORT $LN1@isCollideW@5
$LN12@isCollideW@5:

; 682  : 			if (_node.left) {

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN3@isCollideW@5

; 683  : 				if (isCollideWithEllipsoid(*_node.left) == true)

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
	movzx	ecx, al
	cmp	ecx, 1
	jne	SHORT $LN3@isCollideW@5

; 684  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@5
$LN3@isCollideW@5:

; 685  : 			}
; 686  : 			if (_node.right) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN1@isCollideW@5

; 687  : 				if (isCollideWithEllipsoid(*_node.right) == true)

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN1@isCollideW@5

; 688  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@5
$LN1@isCollideW@5:

; 689  : 			}
; 690  : 		}
; 691  : 	}
; 692  : 	return false;

	xor	al, al
$LN14@isCollideW@5:

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithEllipsoid@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithEllipsoid
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vec3f.h
_TEXT	ENDS
;	COMDAT ??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
tv92 = -16						; size = 4
tv89 = -12						; size = 4
tv86 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__v$ = 12						; size = 4
??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z PROC		; ozcollide::Vec3f::operator*, COMDAT
; _this$ = ecx

; 104  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		return Vec3f(x * _v.x, y * _v.y, z * _v.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR __v$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vec3f@ozcollide@@QAE@MMM@Z		; ozcollide::Vec3f::Vec3f
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 106  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z ENDP		; ozcollide::Vec3f::operator*
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\ellipsoid.h
_TEXT	ENDS
;	COMDAT ?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ PROC	; ozcollide::Ellipsoid::getCenter, COMDAT
; _this$ = ecx

; 38   : 	ozinline const Vec3f& getCenter() const { return center_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ENDP	; ozcollide::Ellipsoid::getCenter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ PROC	; ozcollide::Ellipsoid::getInvRadii, COMDAT
; _this$ = ecx

; 51   : 	ozinline const Vec3f& getInvRadii() const { return invRadii_; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	esp, ebp
	pop	ebp
	ret	0
?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ENDP	; ozcollide::Ellipsoid::getInvRadii
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\aabbtree_poly.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -88						; size = 4
_i2$8109 = -84						; size = 4
_pt1$8110 = -80						; size = 12
_pt3$8114 = -68						; size = 12
_user$8105 = -56					; size = 4
_i0$8107 = -52						; size = 4
_pt2$8112 = -48						; size = 12
_i1$8108 = -36						; size = 4
_pol$8104 = -32						; size = 4
_res$8118 = -25						; size = 1
_center$8116 = -24					; size = 12
_i$8100 = -12						; size = 4
_pl$8097 = -8						; size = 4
_nbPols$8099 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::collideWithEllipsoid
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 697  : 	if (testIntersectionEllipsoidBox(ellip_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	call	?testIntersectionEllipsoidBox@ozcollide@@YA_NABVEllipsoid@1@ABVBox@1@@Z ; ozcollide::testIntersectionEllipsoidBox
	add	esp, 8
	movzx	edx, al
	cmp	edx, 1
	jne	$LN1@collideWit@11

; 698  : 		if (!_node.left && !_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$LN11@collideWit@11
	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	$LN11@collideWit@11

; 699  : 			// reach a leaf
; 700  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	edx, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8097[ebp], edx

; 701  : 			int nbPols = pl.nbPolys;

	mov	eax, DWORD PTR _pl$8097[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _nbPols$8099[ebp], ecx

; 702  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8100[ebp], 0
	jmp	SHORT $LN10@collideWit@11
$LN9@collideWit@11:
	mov	edx, DWORD PTR _i$8100[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8100[ebp], edx
$LN10@collideWit@11:
	mov	eax, DWORD PTR _i$8100[ebp]
	cmp	eax, DWORD PTR _nbPols$8099[ebp]
	jge	$LN8@collideWit@11

; 703  : 				const Polygon *pol = &pl.polys[i];

	mov	ecx, DWORD PTR _i$8100[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _pl$8097[ebp]
	add	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR _pol$8104[ebp], ecx

; 704  : 				int user = 0;

	mov	DWORD PTR _user$8105[ebp], 0

; 705  : 				if (user)

	cmp	DWORD PTR _user$8105[ebp], 0
	je	SHORT $LN7@collideWit@11

; 706  : 					user = pl.users[i];

	mov	eax, DWORD PTR _pl$8097[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$8100[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$8105[ebp], eax
$LN7@collideWit@11:

; 707  : 
; 708  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8104[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8107[ebp], eax

; 709  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8104[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8108[ebp], eax

; 710  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8104[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8109[ebp], eax

; 711  : 				Vec3f pt1 = points_[i0] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	ecx, DWORD PTR _pt1$8110[ebp]
	push	ecx
	mov	ecx, DWORD PTR _i0$8107[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 712  : 				Vec3f pt2 = points_[i1] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _pt2$8112[ebp]
	push	eax
	mov	ecx, DWORD PTR _i1$8108[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 713  : 				Vec3f pt3 = points_[i2] * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _pt3$8114[ebp]
	push	eax
	mov	ecx, DWORD PTR _i2$8109[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 714  : 				Vec3f center = ellip_.getCenter() * ellip_.getInvRadii();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getInvRadii@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getInvRadii
	push	eax
	lea	eax, DWORD PTR _center$8116[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?getCenter@Ellipsoid@ozcollide@@QBEABVVec3f@2@XZ ; ozcollide::Ellipsoid::getCenter
	mov	ecx, eax
	call	??DVec3f@ozcollide@@QBE?AV01@ABV01@@Z	; ozcollide::Vec3f::operator*

; 715  : 				bool res = magic_testIntersectionSphereTriangle(center, 1, pt1, pt2, pt3);

	push	0
	lea	ecx, DWORD PTR _pt3$8114[ebp]
	push	ecx
	lea	edx, DWORD PTR _pt2$8112[ebp]
	push	edx
	lea	eax, DWORD PTR _pt1$8110[ebp]
	push	eax
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _center$8116[ebp]
	push	ecx
	call	?magic_testIntersectionSphereTriangle@ozcollide@@YA_NABVVec3f@1@M000PAM@Z ; ozcollide::magic_testIntersectionSphereTriangle
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8118[ebp], al

; 716  : 				if (res) {

	movzx	edx, BYTE PTR _res$8118[ebp]
	test	edx, edx
	je	SHORT $LN4@collideWit@11

; 717  : 					nbColls_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], ecx

; 718  : 
; 719  : 					if (callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@collideWit@11

; 720  : 						callback_(*this, *pol, user, _node.aabb, userCallback_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$8105[ebp]
	push	ecx
	mov	edx, DWORD PTR _pol$8104[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 20					; 00000014H

; 721  : 					else {

	jmp	SHORT $LN4@collideWit@11
$LN5@collideWit@11:

; 722  : 						ellipColRes_->polys_.add( pol );

	lea	eax, DWORD PTR _pol$8104[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+68]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 723  : 						ellipColRes_->users_.add( user );

	lea	edx, DWORD PTR _user$8105[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN4@collideWit@11:

; 724  : 					}
; 725  : 				}
; 726  : 			}

	jmp	$LN9@collideWit@11
$LN8@collideWit@11:

; 727  : 		}
; 728  : 		else {

	jmp	SHORT $LN1@collideWit@11
$LN11@collideWit@11:

; 729  : 			if (_node.left)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN2@collideWit@11

; 730  : 				collideWithEllipsoid(*_node.left);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
$LN2@collideWit@11:

; 731  : 			if (_node.right)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN1@collideWit@11

; 732  : 				collideWithEllipsoid(*_node.right);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithEllipsoid
$LN1@collideWit@11:

; 733  : 		}
; 734  : 	}
; 735  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithEllipsoid@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::collideWithEllipsoid
_TEXT	ENDS
EXTRN	?testIntersectionSegmentTri@ozcollide@@YA_NABVVec3f@1@0000PAV21@@Z:PROC ; ozcollide::testIntersectionSegmentTri
EXTRN	?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z:PROC ; ozcollide::testIntersectionSegmentBox
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -40						; size = 4
_user$8145 = -36					; size = 4
_i2$8141 = -32						; size = 4
_i0$8139 = -28						; size = 4
_i1$8140 = -24						; size = 4
_pol$8138 = -20						; size = 4
_res$8142 = -13						; size = 1
_i$8134 = -12						; size = 4
_pl$8131 = -8						; size = 4
_nbPols$8133 = -4					; size = 4
__node$ = 8						; size = 4
?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::isCollideWithSegment
; _this$ = ecx

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 741  : 	if (testIntersectionSegmentBox(seg_pt0_, seg_pt1_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z ; ozcollide::testIntersectionSegmentBox
	add	esp, 12					; 0000000cH
	movzx	eax, al
	cmp	eax, 1
	jne	$LN13@isCollideW@6

; 742  : 		if (!_node.left && !_node.right) {

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN12@isCollideW@6
	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	$LN12@isCollideW@6

; 743  : 			// reach a leaf
; 744  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	eax, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8131[ebp], eax

; 745  : 			int nbPols = pl.nbPolys;

	mov	ecx, DWORD PTR _pl$8131[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _nbPols$8133[ebp], edx

; 746  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8134[ebp], 0
	jmp	SHORT $LN11@isCollideW@6
$LN10@isCollideW@6:
	mov	eax, DWORD PTR _i$8134[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8134[ebp], eax
$LN11@isCollideW@6:
	mov	ecx, DWORD PTR _i$8134[ebp]
	cmp	ecx, DWORD PTR _nbPols$8133[ebp]
	jge	$LN9@isCollideW@6

; 747  : 				const Polygon *pol = &pl.polys[i];

	mov	edx, DWORD PTR _i$8134[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _pl$8131[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _pol$8138[ebp], edx

; 748  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8138[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8139[ebp], eax

; 749  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8138[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8140[ebp], eax

; 750  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8138[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8141[ebp], eax

; 751  : 				bool res = testIntersectionSegmentTri(seg_pt0_, seg_pt1_,
; 752  : 														points_[i0], points_[i1], points_[i2]);

	push	0
	mov	ecx, DWORD PTR _i2$8141[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	mov	eax, DWORD PTR _i1$8140[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	push	eax
	mov	edx, DWORD PTR _i0$8139[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+44]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?testIntersectionSegmentTri@ozcollide@@YA_NABVVec3f@1@0000PAV21@@Z ; ozcollide::testIntersectionSegmentTri
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8142[ebp], al

; 753  : 				if (res) {

	movzx	eax, BYTE PTR _res$8142[ebp]
	test	eax, eax
	je	SHORT $LN8@isCollideW@6

; 754  : 					nbColls_++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+236]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+236], edx

; 755  : 					if (segmentColRes_) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN7@isCollideW@6

; 756  : 						int user = 0;

	mov	DWORD PTR _user$8145[ebp], 0

; 757  : 						if (pl.users)

	mov	edx, DWORD PTR _pl$8131[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN6@isCollideW@6

; 758  : 							user = pl.users[i];

	mov	eax, DWORD PTR _pl$8131[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$8134[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _user$8145[ebp], eax
$LN6@isCollideW@6:

; 759  : 
; 760  : 						segmentColRes_->polys_.add( pol );

	lea	ecx, DWORD PTR _pol$8138[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 761  : 						segmentColRes_->users_.add( user );

	lea	eax, DWORD PTR _user$8145[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN7@isCollideW@6:

; 762  : 					}
; 763  : 					return res;

	mov	al, BYTE PTR _res$8142[ebp]
	jmp	SHORT $LN14@isCollideW@6
$LN8@isCollideW@6:

; 764  : 				}
; 765  : 			}

	jmp	$LN10@isCollideW@6
$LN9@isCollideW@6:

; 766  : 		}
; 767  : 		else {

	jmp	SHORT $LN13@isCollideW@6
$LN12@isCollideW@6:

; 768  : 			if (_node.left) {

	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN4@isCollideW@6

; 769  : 				if (isCollideWithSegment(*_node.left) == true)

	mov	eax, DWORD PTR __node$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment
	movzx	edx, al
	cmp	edx, 1
	jne	SHORT $LN4@isCollideW@6

; 770  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@6
$LN4@isCollideW@6:

; 771  : 			}
; 772  : 			if (_node.right) {

	mov	eax, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN13@isCollideW@6

; 773  : 				if (isCollideWithSegment(*_node.right) == true)

	mov	ecx, DWORD PTR __node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::isCollideWithSegment
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN13@isCollideW@6

; 774  : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isCollideW@6
$LN13@isCollideW@6:

; 775  : 			}
; 776  : 		}
; 777  : 	}
; 778  : 	return false;

	xor	al, al
$LN14@isCollideW@6:

; 779  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCollideWithSegment@AABBTreePoly@ozcollide@@AAE_NABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::isCollideWithSegment
; Function compile flags: /Odtp
_this$ = -40						; size = 4
_i2$8170 = -36						; size = 4
_user$8166 = -32					; size = 4
_i0$8168 = -28						; size = 4
_i1$8169 = -24						; size = 4
_pol$8165 = -20						; size = 4
_res$8171 = -13						; size = 1
_i$8161 = -12						; size = 4
_pl$8158 = -8						; size = 4
_nbPols$8160 = -4					; size = 4
__node$ = 8						; size = 4
?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z PROC ; ozcollide::AABBTreePoly::collideWithSegment
; _this$ = ecx

; 782  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 783  : 	if (testIntersectionSegmentBox(seg_pt0_, seg_pt1_, _node.aabb) == true) {

	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	?testIntersectionSegmentBox@ozcollide@@YA_NABVVec3f@1@0ABVBox@1@@Z ; ozcollide::testIntersectionSegmentBox
	add	esp, 12					; 0000000cH
	movzx	eax, al
	cmp	eax, 1
	jne	$LN13@collideWit@12

; 784  : 		if (!_node.left && !_node.right) {

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	$LN11@collideWit@12
	mov	edx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	$LN11@collideWit@12

; 785  : 			// reach a leaf
; 786  : 			const AABBTreePolygonLeaf &pl = (AABBTreePolygonLeaf&) _node;

	mov	eax, DWORD PTR __node$[ebp]
	mov	DWORD PTR _pl$8158[ebp], eax

; 787  : 			int nbPols = pl.nbPolys;

	mov	ecx, DWORD PTR _pl$8158[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _nbPols$8160[ebp], edx

; 788  : 			for (int i = 0; i < nbPols; i++) {

	mov	DWORD PTR _i$8161[ebp], 0
	jmp	SHORT $LN10@collideWit@12
$LN9@collideWit@12:
	mov	eax, DWORD PTR _i$8161[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8161[ebp], eax
$LN10@collideWit@12:
	mov	ecx, DWORD PTR _i$8161[ebp]
	cmp	ecx, DWORD PTR _nbPols$8160[ebp]
	jge	$LN8@collideWit@12

; 789  : 				const Polygon *pol = &pl.polys[i];

	mov	edx, DWORD PTR _i$8161[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _pl$8158[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _pol$8165[ebp], edx

; 790  : 				int user = 0;

	mov	DWORD PTR _user$8166[ebp], 0

; 791  : 				if (pl.users)

	mov	ecx, DWORD PTR _pl$8158[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN7@collideWit@12

; 792  : 					user = pl.users[i];

	mov	edx, DWORD PTR _pl$8158[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$8161[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _user$8166[ebp], edx
$LN7@collideWit@12:

; 793  : 				int i0 = pol->getIndex(0);

	push	0
	mov	ecx, DWORD PTR _pol$8165[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i0$8168[ebp], eax

; 794  : 				int i1 = pol->getIndex(1);

	push	1
	mov	ecx, DWORD PTR _pol$8165[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i1$8169[ebp], eax

; 795  : 				int i2 = pol->getIndex(2);

	push	2
	mov	ecx, DWORD PTR _pol$8165[ebp]
	call	?getIndex@Polygon@ozcollide@@QBEHH@Z	; ozcollide::Polygon::getIndex
	mov	DWORD PTR _i2$8170[ebp], eax

; 796  : 				bool res = testIntersectionSegmentTri(seg_pt0_, seg_pt1_,
; 797  : 														points_[i0], points_[i1], points_[i2]);

	push	0
	mov	eax, DWORD PTR _i2$8170[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+44]
	push	eax
	mov	edx, DWORD PTR _i1$8169[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+44]
	push	edx
	mov	ecx, DWORD PTR _i0$8168[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	?testIntersectionSegmentTri@ozcollide@@YA_NABVVec3f@1@0000PAV21@@Z ; ozcollide::testIntersectionSegmentTri
	add	esp, 24					; 00000018H
	mov	BYTE PTR _res$8171[ebp], al

; 798  : 				if (res) {

	movzx	edx, BYTE PTR _res$8171[ebp]
	test	edx, edx
	je	SHORT $LN6@collideWit@12

; 799  : 					nbColls_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], ecx

; 800  : 
; 801  : 					if (callback_)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN5@collideWit@12

; 802  : 						callback_(*this, *pol, user, _node.aabb, userCallback_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR __node$[ebp]
	push	eax
	mov	ecx, DWORD PTR _user$8166[ebp]
	push	ecx
	mov	edx, DWORD PTR _pol$8165[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 20					; 00000014H

; 803  : 					else {

	jmp	SHORT $LN6@collideWit@12
$LN5@collideWit@12:

; 804  : 						segmentColRes_->polys_.add(pol);

	lea	eax, DWORD PTR _pol$8165[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ; ozcollide::Vector<ozcollide::Polygon const *>::add

; 805  : 						segmentColRes_->users_.add(user);

	lea	edx, DWORD PTR _user$8166[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	add	ecx, 12					; 0000000cH
	call	?add@?$Vector@H@ozcollide@@QAEXABH@Z	; ozcollide::Vector<int>::add
$LN6@collideWit@12:

; 806  : 					}
; 807  : 				}
; 808  : 			}

	jmp	$LN9@collideWit@12
$LN8@collideWit@12:

; 809  : 		}
; 810  : 		else {

	jmp	SHORT $LN13@collideWit@12
$LN11@collideWit@12:

; 811  : 			if (_node.left)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN2@collideWit@12

; 812  : 				collideWithSegment(*_node.left);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSegment
$LN2@collideWit@12:

; 813  : 			if (_node.right)

	mov	ecx, DWORD PTR __node$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN13@collideWit@12

; 814  : 				collideWithSegment(*_node.right);

	mov	edx, DWORD PTR __node$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ; ozcollide::AABBTreePoly::collideWithSegment
$LN13@collideWit@12:

; 815  : 		}
; 816  : 	}
; 817  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?collideWithSegment@AABBTreePoly@ozcollide@@AAEXABVAABBTreeNode@2@@Z ENDP ; ozcollide::AABBTreePoly::collideWithSegment
; Function compile flags: /Odtp
_this$ = -20						; size = 4
_leaf$8194 = -16					; size = 4
_node$8190 = -12					; size = 4
_nbPoints$ = -8						; size = 4
_i$ = -4						; size = 4
__scale$ = 8						; size = 4
?scale@AABBTreePoly@ozcollide@@UAEXM@Z PROC		; ozcollide::AABBTreePoly::scale
; _this$ = ecx

; 822  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 823  : 	int i;
; 824  : 	int nbPoints = nbPoints_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _nbPoints$[ebp], ecx

; 825  : 	for (i = 0; i < nbPoints; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN9@scale
$LN8@scale:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN9@scale:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _nbPoints$[ebp]
	jge	SHORT $LN7@scale

; 826  : 		points_[i] *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+44]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=
	jmp	SHORT $LN8@scale
$LN7@scale:

; 827  : 
; 828  : 	for (i = 0; i < nbNodes_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@scale
$LN5@scale:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@scale:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN4@scale

; 829  : 		AABBTreeNode *node = &root_[i];

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _node$8190[ebp], eax

; 830  : 		node->aabb.center *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _node$8190[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 831  : 		node->aabb.extent *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _node$8190[ebp]
	add	ecx, 12					; 0000000cH
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 832  : 	}

	jmp	SHORT $LN5@scale
$LN4@scale:

; 833  : 
; 834  : 	for (i = 0; i < nbLeafs_; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@scale
$LN2@scale:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@scale:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN1@scale

; 835  : 		AABBTreePolygonLeaf *leaf = &leafs_[i];

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+36]
	mov	DWORD PTR _leaf$8194[ebp], edx

; 836  : 		leaf->aabb.center *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leaf$8194[ebp]
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=

; 837  : 		leaf->aabb.extent *= _scale;

	push	ecx
	fld	DWORD PTR __scale$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _leaf$8194[ebp]
	add	ecx, 12					; 0000000cH
	call	??XVec3f@ozcollide@@QAEXM@Z		; ozcollide::Vec3f::operator*=
	jmp	SHORT $LN2@scale
$LN1@scale:

; 838  : 	}
; 839  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?scale@AABBTreePoly@ozcollide@@UAEXM@Z ENDP		; ozcollide::AABBTreePoly::scale
; Function compile flags: /Odtp
; File i:\svnroot\client\sdk\ozcollide\vector.h
_TEXT	ENDS
;	COMDAT ?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__t$ = 8						; size = 4
?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z PROC ; ozcollide::Vector<ozcollide::Polygon const *>::add, COMDAT
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 		if (size_ < capacity_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN1@add

; 50   : 			mem_[size_] = _t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __t$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 51   : 			size_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 52   : 			return;

	jmp	SHORT $LN2@add
$LN1@add:

; 53   : 		}
; 54   : 
; 55   : 		resize(size_ + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::resize

; 56   : 		mem_[size_ - 1] = _t;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __t$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx
$LN2@add:

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?add@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXABQBVPolygon@2@@Z ENDP ; ozcollide::Vector<ozcollide::Polygon const *>::add
_TEXT	ENDS
PUBLIC	?reserve@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::reserve
; Function compile flags: /Odtp
;	COMDAT ?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__size$ = 8						; size = 4
?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z PROC ; ozcollide::Vector<ozcollide::Polygon const *>::resize, COMDAT
; _this$ = ecx

; 122  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		if (_size > capacity_)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $LN1@resize

; 124  : 			reserve(_size * 2);

	mov	edx, DWORD PTR __size$[ebp]
	shl	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ; ozcollide::Vector<ozcollide::Polygon const *>::reserve
$LN1@resize:

; 125  : 		size_ = _size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 126  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ENDP ; ozcollide::Vector<ozcollide::Polygon const *>::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ PROC ; ozcollide::Vector<ozcollide::Polygon const *>::size, COMDAT
; _this$ = ecx

; 160  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		return size_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEHXZ ENDP ; ozcollide::Vector<ozcollide::Polygon const *>::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEAAPBVPolygon@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEAAPBVPolygon@1@H@Z PROC ; ozcollide::Vector<ozcollide::Polygon const *>::operator[], COMDAT
; _this$ = ecx

; 198  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		return mem_[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 200  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QBEAAPBVPolygon@1@H@Z ENDP ; ozcollide::Vector<ozcollide::Polygon const *>::operator[]
_TEXT	ENDS
PUBLIC	?resize@?$Vector@H@ozcollide@@QAEXH@Z		; ozcollide::Vector<int>::resize
; Function compile flags: /Odtp
;	COMDAT ?add@?$Vector@H@ozcollide@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__t$ = 8						; size = 4
?add@?$Vector@H@ozcollide@@QAEXABH@Z PROC		; ozcollide::Vector<int>::add, COMDAT
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 		if (size_ < capacity_) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN1@add@2

; 50   : 			mem_[size_] = _t;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR __t$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [eax+ecx*4], edx

; 51   : 			size_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 52   : 			return;

	jmp	SHORT $LN2@add@2
$LN1@add@2:

; 53   : 		}
; 54   : 
; 55   : 		resize(size_ + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$Vector@H@ozcollide@@QAEXH@Z	; ozcollide::Vector<int>::resize

; 56   : 		mem_[size_ - 1] = _t;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __t$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+eax*4-4], ecx
$LN2@add@2:

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?add@?$Vector@H@ozcollide@@QAEXABH@Z ENDP		; ozcollide::Vector<int>::add
_TEXT	ENDS
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp
;	COMDAT ?reserve@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
_toCopy$ = -8						; size = 4
_old$ = -4						; size = 4
__capacity$ = 8						; size = 4
?reserve@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z PROC ; ozcollide::Vector<ozcollide::Polygon const *>::reserve, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		T *old = mem_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], ecx

; 131  : 		mem_ = (T*) malloc(_capacity * sizeof(T));

	mov	edx, DWORD PTR __capacity$[ebp]
	shl	edx, 2
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 132  : 		int toCopy = _capacity > capacity_ ? capacity_ : _capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __capacity$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN4@reserve
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN5@reserve
$LN4@reserve:
	mov	eax, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR tv70[ebp], eax
$LN5@reserve:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _toCopy$[ebp], ecx

; 133  : 		memcpy(mem_, old, toCopy * sizeof(T));

	mov	edx, DWORD PTR _toCopy$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 		if (old)

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN1@reserve

; 135  : 			free(old);

	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN1@reserve:

; 136  : 		capacity_ = _capacity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$Vector@PBVPolygon@ozcollide@@@ozcollide@@QAEXH@Z ENDP ; ozcollide::Vector<ozcollide::Polygon const *>::reserve
_TEXT	ENDS
PUBLIC	?reserve@?$Vector@H@ozcollide@@QAEXH@Z		; ozcollide::Vector<int>::reserve
; Function compile flags: /Odtp
;	COMDAT ?resize@?$Vector@H@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__size$ = 8						; size = 4
?resize@?$Vector@H@ozcollide@@QAEXH@Z PROC		; ozcollide::Vector<int>::resize, COMDAT
; _this$ = ecx

; 122  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		if (_size > capacity_)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $LN1@resize@2

; 124  : 			reserve(_size * 2);

	mov	edx, DWORD PTR __size$[ebp]
	shl	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$Vector@H@ozcollide@@QAEXH@Z	; ozcollide::Vector<int>::reserve
$LN1@resize@2:

; 125  : 		size_ = _size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __size$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 126  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$Vector@H@ozcollide@@QAEXH@Z ENDP		; ozcollide::Vector<int>::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?reserve@?$Vector@H@ozcollide@@QAEXH@Z
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
_toCopy$ = -8						; size = 4
_old$ = -4						; size = 4
__capacity$ = 8						; size = 4
?reserve@?$Vector@H@ozcollide@@QAEXH@Z PROC		; ozcollide::Vector<int>::reserve, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		T *old = mem_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _old$[ebp], ecx

; 131  : 		mem_ = (T*) malloc(_capacity * sizeof(T));

	mov	edx, DWORD PTR __capacity$[ebp]
	shl	edx, 2
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 132  : 		int toCopy = _capacity > capacity_ ? capacity_ : _capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __capacity$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jle	SHORT $LN4@reserve@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN5@reserve@2
$LN4@reserve@2:
	mov	eax, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR tv70[ebp], eax
$LN5@reserve@2:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR _toCopy$[ebp], ecx

; 133  : 		memcpy(mem_, old, toCopy * sizeof(T));

	mov	edx, DWORD PTR _toCopy$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 134  : 		if (old)

	cmp	DWORD PTR _old$[ebp], 0
	je	SHORT $LN1@reserve@2

; 135  : 			free(old);

	mov	eax, DWORD PTR _old$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN1@reserve@2:

; 136  : 		capacity_ = _capacity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __capacity$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$Vector@H@ozcollide@@QAEXH@Z ENDP		; ozcollide::Vector<int>::reserve
_TEXT	ENDS
END

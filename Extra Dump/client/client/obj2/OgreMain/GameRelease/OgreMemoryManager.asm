; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreMemoryManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	??0?$ChainList@VDataChunk@Ogre@@@Ogre@@QAE@XZ	; Ogre::ChainList<Ogre::DataChunk>::ChainList<Ogre::DataChunk>
PUBLIC	??0FixedSizePool@Ogre@@QAE@I@Z			; Ogre::FixedSizePool::FixedSizePool
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrememorymanager.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_unitsize$ = 8						; size = 4
??0FixedSizePool@Ogre@@QAE@I@Z PROC			; Ogre::FixedSizePool::FixedSizePool
; _this$ = ecx

; 43   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$ChainList@VDataChunk@Ogre@@@Ogre@@QAE@XZ ; Ogre::ChainList<Ogre::DataChunk>::ChainList<Ogre::DataChunk>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 44   : 		m_UnitSize = (unitsize + 3) & (~3);

	mov	ecx, DWORD PTR _unitsize$[ebp]
	add	ecx, 3
	and	ecx, -4					; fffffffcH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 45   : 		assert( m_UnitSize < GetChunkSize() );
; 46   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedSizePool@Ogre@@QAE@I@Z ENDP			; Ogre::FixedSizePool::FixedSizePool
_TEXT	ENDS
PUBLIC	?Iterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@PAVChainListNode@2@@Z ; Ogre::ChainList<Ogre::DataChunk>::Iterate
PUBLIC	?BeginIterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@XZ ; Ogre::ChainList<Ogre::DataChunk>::BeginIterate
PUBLIC	??1FixedSizePool@Ogre@@QAE@XZ			; Ogre::FixedSizePool::~FixedSizePool
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pdel$55527 = -8					; size = 4
_pcur$ = -4						; size = 4
??1FixedSizePool@Ogre@@QAE@XZ PROC			; Ogre::FixedSizePool::~FixedSizePool
; _this$ = ecx

; 49   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		DataChunk *pcur = m_MemChunks.BeginIterate();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?BeginIterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@XZ ; Ogre::ChainList<Ogre::DataChunk>::BeginIterate
	mov	DWORD PTR _pcur$[ebp], eax
$LN2@FixedSizeP:

; 51   : 		while( pcur )

	cmp	DWORD PTR _pcur$[ebp], 0
	je	SHORT $LN3@FixedSizeP

; 52   : 		{
; 53   : 			ChainListNode *pdel = pcur;

	mov	eax, DWORD PTR _pcur$[ebp]
	mov	DWORD PTR _pdel$55527[ebp], eax

; 54   : 			pcur = m_MemChunks.Iterate(pcur);

	mov	ecx, DWORD PTR _pcur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Iterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@PAVChainListNode@2@@Z ; Ogre::ChainList<Ogre::DataChunk>::Iterate
	mov	DWORD PTR _pcur$[ebp], eax

; 55   : 			free( pdel );

	mov	edx, DWORD PTR _pdel$55527[ebp]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 56   : 		}

	jmp	SHORT $LN2@FixedSizeP
$LN3@FixedSizeP:

; 57   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedSizePool@Ogre@@QAE@XZ ENDP			; Ogre::FixedSizePool::~FixedSizePool
_TEXT	ENDS
PUBLIC	?PushFront@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@@Z ; Ogre::ChainList<Ogre::DataChunk>::PushFront
PUBLIC	?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ	; Ogre::FixedSizePool::GetChunkSize
PUBLIC	?AllocAndInitChunk@FixedSizePool@Ogre@@AAEXXZ	; Ogre::FixedSizePool::AllocAndInitChunk
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pend$ = -12						; size = 4
_pdata$ = -8						; size = 4
_pchunk$ = -4						; size = 4
?AllocAndInitChunk@FixedSizePool@Ogre@@AAEXXZ PROC	; Ogre::FixedSizePool::AllocAndInitChunk
; _this$ = ecx

; 60   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		DataChunk *pchunk = (DataChunk *)malloc( GetChunkSize() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ ; Ogre::FixedSizePool::GetChunkSize
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pchunk$[ebp], eax

; 62   : 
; 63   : 		uchar *pdata = (uchar *)pchunk + sizeof(DataChunk);

	mov	eax, DWORD PTR _pchunk$[ebp]
	add	eax, 8
	mov	DWORD PTR _pdata$[ebp], eax

; 64   : 		uchar *pend = (uchar *)pchunk + GetChunkSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ ; Ogre::FixedSizePool::GetChunkSize
	add	eax, DWORD PTR _pchunk$[ebp]
	mov	DWORD PTR _pend$[ebp], eax
$LN2@AllocAndIn:

; 65   : 		while( pdata+m_UnitSize <= pend )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pdata$[ebp]
	add	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _pend$[ebp]
	ja	SHORT $LN1@AllocAndIn

; 66   : 		{
; 67   : 			((DataUnit *)pdata)->pnext = m_pFreeHead;

	mov	eax, DWORD PTR _pdata$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 68   : 			m_pFreeHead = ((DataUnit *)pdata);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pdata$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 69   : 
; 70   : 			pdata += m_UnitSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pdata$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _pdata$[ebp], eax

; 71   : 		}

	jmp	SHORT $LN2@AllocAndIn
$LN1@AllocAndIn:

; 72   : 
; 73   : 		m_MemChunks.PushFront( pchunk );

	mov	ecx, DWORD PTR _pchunk$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?PushFront@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@@Z ; Ogre::ChainList<Ogre::DataChunk>::PushFront

; 74   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AllocAndInitChunk@FixedSizePool@Ogre@@AAEXXZ ENDP	; Ogre::FixedSizePool::AllocAndInitChunk
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ PROC		; Ogre::FixedSizePool::GetChunkSize, COMDAT
; _this$ = ecx

; 27   : 		size_t GetChunkSize(){ return (1024*8); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 8192				; 00002000H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetChunkSize@FixedSizePool@Ogre@@AAEIXZ ENDP		; Ogre::FixedSizePool::GetChunkSize
_TEXT	ENDS
PUBLIC	?AllocUnit@FixedSizePool@Ogre@@QAEPAXXZ		; Ogre::FixedSizePool::AllocUnit
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_ptmp$ = -4						; size = 4
?AllocUnit@FixedSizePool@Ogre@@QAEPAXXZ PROC		; Ogre::FixedSizePool::AllocUnit
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 		if( m_pFreeHead == NULL ) AllocAndInitChunk();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN1@AllocUnit
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocAndInitChunk@FixedSizePool@Ogre@@AAEXXZ ; Ogre::FixedSizePool::AllocAndInitChunk
$LN1@AllocUnit:

; 79   : 
; 80   : 		assert( m_pFreeHead );
; 81   : 		void *ptmp = m_pFreeHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _ptmp$[ebp], edx

; 82   : 		m_pFreeHead = m_pFreeHead->pnext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax

; 83   : 
; 84   : 		return ptmp;

	mov	eax, DWORD PTR _ptmp$[ebp]

; 85   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?AllocUnit@FixedSizePool@Ogre@@QAEPAXXZ ENDP		; Ogre::FixedSizePool::AllocUnit
_TEXT	ENDS
PUBLIC	?FreeUnit@FixedSizePool@Ogre@@QAEXPAX@Z		; Ogre::FixedSizePool::FreeUnit
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?FreeUnit@FixedSizePool@Ogre@@QAEXPAX@Z PROC		; Ogre::FixedSizePool::FreeUnit
; _this$ = ecx

; 88   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 		((DataUnit *)p)->pnext = m_pFreeHead;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 90   : 		m_pFreeHead = ((DataUnit *)p);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 91   : 
; 92   : #ifdef _DEBUG
; 93   : 		DataChunk *pcur = m_MemChunks.BeginIterate();
; 94   : 		while( pcur )
; 95   : 		{
; 96   : 			if( IsPtrInChunk(p, pcur) ) return;
; 97   : 			pcur = m_MemChunks.Iterate( pcur );
; 98   : 		}
; 99   : 		assert(0); //要释放的指针不属于这个pool管理
; 100  : #endif
; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?FreeUnit@FixedSizePool@Ogre@@QAEXPAX@Z ENDP		; Ogre::FixedSizePool::FreeUnit
_TEXT	ENDS
PUBLIC	??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ	; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>
PUBLIC	??0?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ	; Ogre::Singleton<Ogre::MemPoolMgr>::Singleton<Ogre::MemPoolMgr>
PUBLIC	??0MemPoolMgr@Ogre@@QAE@XZ			; Ogre::MemPoolMgr::MemPoolMgr
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0MemPoolMgr@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemPoolMgr@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0MemPoolMgr@Ogre@@QAE@XZ$1
__ehfuncinfo$??0MemPoolMgr@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0MemPoolMgr@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv89 = -32						; size = 4
_this$ = -28						; size = 4
$T59829 = -24						; size = 4
$T59828 = -20						; size = 4
_i$55558 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0MemPoolMgr@Ogre@@QAE@XZ PROC				; Ogre::MemPoolMgr::MemPoolMgr
; _this$ = ecx

; 104  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemPoolMgr@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::MemPoolMgr>::Singleton<Ogre::MemPoolMgr>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 105  : 		for( size_t i=0; i<POOL_TABLE_SIZE; i++ )

	mov	DWORD PTR _i$55558[ebp], 0
	jmp	SHORT $LN3@MemPoolMgr
$LN2@MemPoolMgr:
	mov	eax, DWORD PTR _i$55558[ebp]
	add	eax, 1
	mov	DWORD PTR _i$55558[ebp], eax
$LN3@MemPoolMgr:
	cmp	DWORD PTR _i$55558[ebp], 256		; 00000100H
	jae	SHORT $LN4@MemPoolMgr

; 106  : 		{
; 107  : 			m_pPools[i] = new FixedSizePool( (i+1)*4 );

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T59829[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T59829[ebp], 0
	je	SHORT $LN6@MemPoolMgr
	mov	ecx, DWORD PTR _i$55558[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	mov	ecx, DWORD PTR $T59829[ebp]
	call	??0FixedSizePool@Ogre@@QAE@I@Z		; Ogre::FixedSizePool::FixedSizePool
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN7@MemPoolMgr
$LN6@MemPoolMgr:
	mov	DWORD PTR tv89[ebp], 0
$LN7@MemPoolMgr:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T59828[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _i$55558[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T59828[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	jmp	SHORT $LN2@MemPoolMgr
$LN4@MemPoolMgr:

; 108  : 		}
; 109  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0MemPoolMgr@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>
__unwindfunclet$??0MemPoolMgr@Ogre@@QAE@XZ$1:
	mov	eax, DWORD PTR $T59829[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0MemPoolMgr@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemPoolMgr@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemPoolMgr@Ogre@@QAE@XZ ENDP				; Ogre::MemPoolMgr::MemPoolMgr
PUBLIC	??_GFixedSizePool@Ogre@@QAEPAXI@Z		; Ogre::FixedSizePool::`scalar deleting destructor'
PUBLIC	??1MemPoolMgr@Ogre@@QAE@XZ			; Ogre::MemPoolMgr::~MemPoolMgr
xdata$x	SEGMENT
__unwindtable$??1MemPoolMgr@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1MemPoolMgr@Ogre@@QAE@XZ$0
__ehfuncinfo$??1MemPoolMgr@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1MemPoolMgr@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
$T59845 = -24						; size = 4
$T59844 = -20						; size = 4
_i$55569 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1MemPoolMgr@Ogre@@QAE@XZ PROC				; Ogre::MemPoolMgr::~MemPoolMgr
; _this$ = ecx

; 112  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1MemPoolMgr@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 113  : 		for( size_t i=0; i<POOL_TABLE_SIZE; i++ )

	mov	DWORD PTR _i$55569[ebp], 0
	jmp	SHORT $LN3@MemPoolMgr@2
$LN2@MemPoolMgr@2:
	mov	eax, DWORD PTR _i$55569[ebp]
	add	eax, 1
	mov	DWORD PTR _i$55569[ebp], eax
$LN3@MemPoolMgr@2:
	cmp	DWORD PTR _i$55569[ebp], 256		; 00000100H
	jae	SHORT $LN4@MemPoolMgr@2

; 114  : 		{
; 115  : 			delete (m_pPools[i]);

	mov	ecx, DWORD PTR _i$55569[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T59845[ebp], eax
	mov	ecx, DWORD PTR $T59845[ebp]
	mov	DWORD PTR $T59844[ebp], ecx
	cmp	DWORD PTR $T59844[ebp], 0
	je	SHORT $LN6@MemPoolMgr@2
	push	1
	mov	ecx, DWORD PTR $T59844[ebp]
	call	??_GFixedSizePool@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN7@MemPoolMgr@2
$LN6@MemPoolMgr@2:
	mov	DWORD PTR tv77[ebp], 0
$LN7@MemPoolMgr@2:

; 116  : 		}

	jmp	SHORT $LN2@MemPoolMgr@2
$LN4@MemPoolMgr@2:

; 117  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1MemPoolMgr@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>
__ehhandler$??1MemPoolMgr@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1MemPoolMgr@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1MemPoolMgr@Ogre@@QAE@XZ ENDP				; Ogre::MemPoolMgr::~MemPoolMgr
; Function compile flags: /Odtp
;	COMDAT ??_GFixedSizePool@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFixedSizePool@Ogre@@QAEPAXI@Z PROC			; Ogre::FixedSizePool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FixedSizePool@Ogre@@QAE@XZ		; Ogre::FixedSizePool::~FixedSizePool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFixedSizePool@Ogre@@QAEPAXI@Z ENDP			; Ogre::FixedSizePool::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Alloc@MemPoolMgr@Ogre@@QAEPAXI@Z		; Ogre::MemPoolMgr::Alloc
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_n$ = 8							; size = 4
?Alloc@MemPoolMgr@Ogre@@QAEPAXI@Z PROC			; Ogre::MemPoolMgr::Alloc
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		assert( n > 0 );
; 122  : 		size_t i = (n-1)/4;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	shr	eax, 2
	mov	DWORD PTR _i$[ebp], eax

; 123  : 		if( i >= POOL_TABLE_SIZE ) return malloc( n );

	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jb	SHORT $LN2@Alloc
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	jmp	SHORT $LN3@Alloc
	jmp	SHORT $LN3@Alloc
$LN2@Alloc:

; 124  : 		else return m_pPools[i]->AllocUnit();

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	call	?AllocUnit@FixedSizePool@Ogre@@QAEPAXXZ	; Ogre::FixedSizePool::AllocUnit
$LN3@Alloc:

; 125  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?Alloc@MemPoolMgr@Ogre@@QAEPAXI@Z ENDP			; Ogre::MemPoolMgr::Alloc
_TEXT	ENDS
PUBLIC	?Free@MemPoolMgr@Ogre@@QAEXPAXI@Z		; Ogre::MemPoolMgr::Free
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?Free@MemPoolMgr@Ogre@@QAEXPAXI@Z PROC			; Ogre::MemPoolMgr::Free
; _this$ = ecx

; 128  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		assert( n > 0 );
; 130  : 		size_t i = (n-1)/4;

	mov	eax, DWORD PTR _n$[ebp]
	sub	eax, 1
	shr	eax, 2
	mov	DWORD PTR _i$[ebp], eax

; 131  : 		if( i >= POOL_TABLE_SIZE ) free(p);

	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jb	SHORT $LN2@Free
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	jmp	SHORT $LN3@Free
$LN2@Free:

; 132  : 		else m_pPools[i]->FreeUnit( p );

	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	?FreeUnit@FixedSizePool@Ogre@@QAEXPAX@Z	; Ogre::FixedSizePool::FreeUnit
$LN3@Free:

; 133  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Free@MemPoolMgr@Ogre@@QAEXPAXI@Z ENDP			; Ogre::MemPoolMgr::Free
_TEXT	ENDS
PUBLIC	?ms_Singleton@?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@1PAVMemPoolMgr@2@A ; Ogre::Singleton<Ogre::MemPoolMgr>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@1PAVMemPoolMgr@2@A
; File i:\svnroot\client\ogremain\ogresingleton.h
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@1PAVMemPoolMgr@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::MemPoolMgr>::ms_Singleton
; Function compile flags: /Odtp
_BSS	ENDS
;	COMDAT ??0?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::MemPoolMgr>::Singleton<Ogre::MemPoolMgr>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@1PAVMemPoolMgr@2@A, eax ; Ogre::Singleton<Ogre::MemPoolMgr>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::MemPoolMgr>::Singleton<Ogre::MemPoolMgr>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@1PAVMemPoolMgr@2@A, 0 ; Ogre::Singleton<Ogre::MemPoolMgr>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VMemPoolMgr@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::MemPoolMgr>::~Singleton<Ogre::MemPoolMgr>
_TEXT	ENDS
PUBLIC	?Clear@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXXZ ; Ogre::ChainList<Ogre::DataChunk>::Clear
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelist.h
;	COMDAT ??0?$ChainList@VDataChunk@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$ChainList@VDataChunk@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::ChainList<Ogre::DataChunk>::ChainList<Ogre::DataChunk>, COMDAT
; _this$ = ecx

; 24   : 		ChainList(){ Clear(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXXZ ; Ogre::ChainList<Ogre::DataChunk>::Clear
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$ChainList@VDataChunk@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::ChainList<Ogre::DataChunk>::ChainList<Ogre::DataChunk>
_TEXT	ENDS
PUBLIC	?InsertAfter@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@0@Z ; Ogre::ChainList<Ogre::DataChunk>::InsertAfter
; Function compile flags: /Odtp
;	COMDAT ?PushFront@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pnode$ = 8						; size = 4
?PushFront@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@@Z PROC ; Ogre::ChainList<Ogre::DataChunk>::PushFront, COMDAT
; _this$ = ecx

; 35   : 		void PushFront( ChainListNode *pnode ){ InsertAfter(pnode, &m_EndNode); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertAfter@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@0@Z ; Ogre::ChainList<Ogre::DataChunk>::InsertAfter
	mov	esp, ebp
	pop	ebp
	ret	4
?PushFront@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@@Z ENDP ; Ogre::ChainList<Ogre::DataChunk>::PushFront
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?BeginIterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@XZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?BeginIterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@XZ PROC ; Ogre::ChainList<Ogre::DataChunk>::BeginIterate, COMDAT
; _this$ = ecx

; 125  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 			return m_EndNode.m_pNextNode==&m_EndNode ? NULL : static_cast<T *>(m_EndNode.m_pNextNode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN3@BeginItera
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@BeginItera
$LN3@BeginItera:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv69[ebp], eax
$LN4@BeginItera:
	mov	eax, DWORD PTR tv69[ebp]

; 127  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginIterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@XZ ENDP ; Ogre::ChainList<Ogre::DataChunk>::BeginIterate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Iterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@PAVChainListNode@2@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_pnode$ = 8						; size = 4
?Iterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@PAVChainListNode@2@@Z PROC ; Ogre::ChainList<Ogre::DataChunk>::Iterate, COMDAT
; _this$ = ecx

; 129  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 			return pnode->m_pNextNode==&m_EndNode ? NULL : static_cast<T *>(pnode->m_pNextNode);

	mov	eax, DWORD PTR _pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN3@Iterate
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@Iterate
$LN3@Iterate:
	mov	edx, DWORD PTR _pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv69[ebp], eax
$LN4@Iterate:
	mov	eax, DWORD PTR tv69[ebp]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?Iterate@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEPAVDataChunk@2@PAVChainListNode@2@@Z ENDP ; Ogre::ChainList<Ogre::DataChunk>::Iterate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Clear@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXXZ PROC	; Ogre::ChainList<Ogre::DataChunk>::Clear, COMDAT
; _this$ = ecx

; 30   : 		{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			m_EndNode.m_pNextNode = m_EndNode.m_pPrevNode = &m_EndNode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 32   : 			m_nNodes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 33   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXXZ ENDP	; Ogre::ChainList<Ogre::DataChunk>::Clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?InsertAfter@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pnode$ = 8						; size = 4
_pref$ = 12						; size = 4
?InsertAfter@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@0@Z PROC ; Ogre::ChainList<Ogre::DataChunk>::InsertAfter, COMDAT
; _this$ = ecx

; 63   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 			assert( pnode && pref );
; 65   : 
; 66   : 			pnode->m_pPrevNode = pref;

	mov	eax, DWORD PTR _pnode$[ebp]
	mov	ecx, DWORD PTR _pref$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 67   : 			pnode->m_pNextNode = pref->m_pNextNode;

	mov	edx, DWORD PTR _pnode$[ebp]
	mov	eax, DWORD PTR _pref$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 68   : 
; 69   : 			pref->m_pNextNode->m_pPrevNode = pnode;

	mov	edx, DWORD PTR _pref$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 70   : 			pref->m_pNextNode = pnode;

	mov	edx, DWORD PTR _pref$[ebp]
	mov	eax, DWORD PTR _pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 71   : 
; 72   : 			m_nNodes++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 73   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?InsertAfter@?$ChainList@VDataChunk@Ogre@@@Ogre@@QAEXPAVChainListNode@2@0@Z ENDP ; Ogre::ChainList<Ogre::DataChunk>::InsertAfter
_TEXT	ENDS
END

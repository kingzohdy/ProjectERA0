; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3D9VertexDecl.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
CONST	ENDS
PUBLIC	??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z ; Ogre::D3D9VertexDecl::D3D9VertexDecl
EXTRN	__imp_??1VertexFormat@Ogre@@QAE@XZ:PROC
EXTRN	__imp_??0VertexFormat@Ogre@@QAE@ABV01@@Z:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z$0
__ehfuncinfo$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9vertexdecl.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_prs$ = 8						; size = 4
_vertfmt$ = 12						; size = 4
??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z PROC ; Ogre::D3D9VertexDecl::D3D9VertexDecl
; _this$ = ecx

; 8    : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _prs$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vertfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0VertexFormat@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 9    : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1VertexFormat@Ogre@@QAE@XZ
__ehhandler$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z ENDP ; Ogre::D3D9VertexDecl::D3D9VertexDecl
PUBLIC	??1D3D9VertexDecl@Ogre@@QAE@XZ			; Ogre::D3D9VertexDecl::~D3D9VertexDecl
xdata$x	SEGMENT
__unwindtable$??1D3D9VertexDecl@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3D9VertexDecl@Ogre@@QAE@XZ$0
__ehfuncinfo$??1D3D9VertexDecl@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3D9VertexDecl@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D9VertexDecl@Ogre@@QAE@XZ PROC			; Ogre::D3D9VertexDecl::~D3D9VertexDecl
; _this$ = ecx

; 12   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3D9VertexDecl@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 13   : 		SAFE_RELEASE(m_pVertDecl);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@D3D9Vertex
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
$LN2@D3D9Vertex:

; 14   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1VertexFormat@Ogre@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3D9VertexDecl@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1VertexFormat@Ogre@@QAE@XZ
__ehhandler$??1D3D9VertexDecl@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3D9VertexDecl@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3D9VertexDecl@Ogre@@QAE@XZ ENDP			; Ogre::D3D9VertexDecl::~D3D9VertexDecl
PUBLIC	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
PUBLIC	?create@D3D9VertexDecl@Ogre@@QAE_NXZ		; Ogre::D3D9VertexDecl::create
EXTRN	__imp_?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z:PROC
EXTRN	__imp_?getNumElements@VertexFormat@Ogre@@QBEIXZ:PROC
;	COMDAT ?enddecl@?1??create@D3D9VertexDecl@Ogre@@QAE_NXZ@4U_D3DVERTEXELEMENT9@@A
_DATA	SEGMENT
?enddecl@?1??create@D3D9VertexDecl@Ogre@@QAE_NXZ@4U_D3DVERTEXELEMENT9@@A DW 0ffH ; `Ogre::D3D9VertexDecl::create'::`2'::enddecl
	DW	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Odtp
_DATA	ENDS
_TEXT	SEGMENT
tv82 = -2068						; size = 4
_this$ = -2064						; size = 4
_pdecl$ = -2060						; size = 4
_vertelement$ = -2056					; size = 2048
_i$ = -4						; size = 4
?create@D3D9VertexDecl@Ogre@@QAE_NXZ PROC		; Ogre::D3D9VertexDecl::create
; _this$ = ecx

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 2068				; 00000814H
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		static D3DVERTEXELEMENT9 enddecl = D3DDECL_END();
; 100  : 		D3DVERTEXELEMENT9 vertelement[256];
; 101  : 		assert(m_VertFmt.getNumElements() < 255);
; 102  : 
; 103  : 		uint i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 104  : 		for(; i<m_VertFmt.getNumElements(); i++ )

	jmp	SHORT $LN5@create
$LN4@create:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN5@create:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?getNumElements@VertexFormat@Ogre@@QBEIXZ
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@create

; 105  : 		{
; 106  : 			ConvertVertElement(vertelement[i], m_VertFmt.getElement(i));

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR _vertelement$[ebp+edx*8]
	push	eax
	call	?ConvertVertElement@Ogre@@YAXAAU_D3DVERTEXELEMENT9@@ABVVertexElement@1@@Z ; Ogre::ConvertVertElement
	add	esp, 8

; 107  : 		}

	jmp	SHORT $LN4@create
$LN3@create:

; 108  : 		vertelement[i] = enddecl;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR ?enddecl@?1??create@D3D9VertexDecl@Ogre@@QAE_NXZ@4U_D3DVERTEXELEMENT9@@A
	mov	DWORD PTR _vertelement$[ebp+ecx*8], edx
	mov	eax, DWORD PTR ?enddecl@?1??create@D3D9VertexDecl@Ogre@@QAE_NXZ@4U_D3DVERTEXELEMENT9@@A+4
	mov	DWORD PTR _vertelement$[ebp+ecx*8+4], eax

; 109  : 
; 110  : 		IDirect3DVertexDeclaration9 *pdecl;
; 111  : 		if( SUCCEEDED(m_pRS->getD3DDevice()->CreateVertexDeclaration(vertelement, &pdecl)) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
	mov	DWORD PTR tv82[ebp], eax
	lea	edx, DWORD PTR _pdecl$[ebp]
	push	edx
	lea	eax, DWORD PTR _vertelement$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv82[ebp]
	push	ecx
	mov	edx, DWORD PTR tv82[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+344]
	call	ecx
	test	eax, eax
	jl	SHORT $LN2@create

; 112  : 		{
; 113  : 			m_pVertDecl = pdecl;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pdecl$[ebp]
	mov	DWORD PTR [edx+28], eax

; 114  : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@create
	jmp	SHORT $LN6@create
$LN2@create:

; 115  : 		}
; 116  : 		else return false;

	xor	al, al
$LN6@create:

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?create@D3D9VertexDecl@Ogre@@QAE_NXZ ENDP		; Ogre::D3D9VertexDecl::create
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.h
_TEXT	ENDS
;	COMDAT ?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ PROC ; Ogre::D3D9RenderSystem::getD3DDevice, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_pd3dDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ENDP ; Ogre::D3D9RenderSystem::getD3DDevice
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9vertexdecl.cpp
_TEXT	ENDS
_TEXT	SEGMENT
tv87 = -8						; size = 4
tv77 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
?ConvertVertElement@Ogre@@YAXAAU_D3DVERTEXELEMENT9@@ABVVertexElement@1@@Z PROC ; Ogre::ConvertVertElement

; 17   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 18   : 		dst.Stream = src.m_StreamSource;

	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _dst$[ebp]
	mov	WORD PTR [edx], cx

; 19   : 		dst.Method = D3DDECLMETHOD_DEFAULT;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+5], 0

; 20   : 		dst.Offset = src.m_Offset;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 4
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _dst$[ebp]
	mov	WORD PTR [eax+2], dx

; 21   : 		dst.UsageIndex = src.m_Index;

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 28					; 0000001cH
	and	edx, 15					; 0000000fH
	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+7], dl

; 22   : 
; 23   : 		switch(src.m_Type)

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 12					; 0000000cH
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv77[ebp], edx
	cmp	DWORD PTR tv77[ebp], 9
	ja	SHORT $LN20@ConvertVer
	mov	eax, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN24@ConvertVer[eax*4]
$LN19@ConvertVer:

; 24   : 		{
; 25   : 		case VET_FLOAT1:
; 26   : 			dst.Type = D3DDECLTYPE_FLOAT1;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 27   : 			break;

	jmp	SHORT $LN20@ConvertVer
$LN18@ConvertVer:

; 28   : 
; 29   : 		case VET_FLOAT2:
; 30   : 			dst.Type = D3DDECLTYPE_FLOAT2;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx+4], 1

; 31   : 			break;

	jmp	SHORT $LN20@ConvertVer
$LN17@ConvertVer:

; 32   : 
; 33   : 		case VET_FLOAT3:
; 34   : 			dst.Type = D3DDECLTYPE_FLOAT3;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+4], 2

; 35   : 			break;

	jmp	SHORT $LN20@ConvertVer
$LN16@ConvertVer:

; 36   : 
; 37   : 		case VET_FLOAT4:
; 38   : 			dst.Type = D3DDECLTYPE_FLOAT4;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx+4], 3

; 39   : 			break;

	jmp	SHORT $LN20@ConvertVer
$LN15@ConvertVer:

; 40   : 
; 41   : 		case VET_COLOUR:
; 42   : 			dst.Type = D3DDECLTYPE_D3DCOLOR;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx+4], 4

; 43   : 			break;

	jmp	SHORT $LN20@ConvertVer
$LN14@ConvertVer:

; 44   : 
; 45   : 		case VET_UBYTE4:
; 46   : 			dst.Type = D3DDECLTYPE_UBYTE4;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+4], 5
$LN20@ConvertVer:

; 47   : 			break;
; 48   : 
; 49   : 		default:
; 50   : 			assert(0);
; 51   : 			break;
; 52   : 		}
; 53   : 
; 54   : 		switch(src.m_Semantic)

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 4
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv87[ebp], edx
	mov	eax, DWORD PTR tv87[ebp]
	sub	eax, 1
	mov	DWORD PTR tv87[ebp], eax
	cmp	DWORD PTR tv87[ebp], 9
	ja	SHORT $LN22@ConvertVer
	mov	ecx, DWORD PTR tv87[ebp]
	jmp	DWORD PTR $LN25@ConvertVer[ecx*4]
$LN10@ConvertVer:

; 55   : 		{
; 56   : 		case VES_POSITION:
; 57   : 			dst.Usage = D3DDECLUSAGE_POSITION;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx+6], 0

; 58   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN9@ConvertVer:

; 59   : 
; 60   : 		case VES_BLEND_WEIGHTS:
; 61   : 			dst.Usage = D3DDECLUSAGE_BLENDWEIGHT;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+6], 1

; 62   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN8@ConvertVer:

; 63   : 				
; 64   : 		case VES_BLEND_INDICES:
; 65   : 			dst.Usage = D3DDECLUSAGE_BLENDINDICES;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx+6], 2

; 66   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN7@ConvertVer:

; 67   : 
; 68   : 		case VES_NORMAL:
; 69   : 			dst.Usage = D3DDECLUSAGE_NORMAL;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx+6], 3

; 70   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN6@ConvertVer:

; 71   : 
; 72   : 		case VES_COLOR:
; 73   : 			dst.Usage = D3DDECLUSAGE_COLOR;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+6], 10			; 0000000aH

; 74   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN5@ConvertVer:

; 75   : 
; 76   : 		case VES_TEXCOORD:
; 77   : 			dst.Usage = D3DDECLUSAGE_TEXCOORD;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx+6], 5

; 78   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN4@ConvertVer:

; 79   : 		case VES_BINORMAL:
; 80   : 			dst.Usage = D3DDECLUSAGE_BINORMAL;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [edx+6], 7

; 81   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN3@ConvertVer:

; 82   : 
; 83   : 		case VES_TANGENT:
; 84   : 			dst.Usage = D3DDECLUSAGE_TANGENT;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [eax+6], 6

; 85   : 			break;

	jmp	SHORT $LN22@ConvertVer
$LN2@ConvertVer:

; 86   : 
; 87   : 		case VES_POSITIONT:
; 88   : 			dst.Usage = D3DDECLUSAGE_POSITIONT;

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	BYTE PTR [ecx+6], 9
$LN22@ConvertVer:

; 89   : 			break;
; 90   : 
; 91   : 		default:
; 92   : 			assert(0);
; 93   : 			break;
; 94   : 		}
; 95   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@ConvertVer:
	DD	$LN19@ConvertVer
	DD	$LN18@ConvertVer
	DD	$LN17@ConvertVer
	DD	$LN16@ConvertVer
	DD	$LN15@ConvertVer
	DD	$LN20@ConvertVer
	DD	$LN20@ConvertVer
	DD	$LN20@ConvertVer
	DD	$LN20@ConvertVer
	DD	$LN14@ConvertVer
$LN25@ConvertVer:
	DD	$LN10@ConvertVer
	DD	$LN9@ConvertVer
	DD	$LN8@ConvertVer
	DD	$LN7@ConvertVer
	DD	$LN6@ConvertVer
	DD	$LN22@ConvertVer
	DD	$LN5@ConvertVer
	DD	$LN4@ConvertVer
	DD	$LN3@ConvertVer
	DD	$LN2@ConvertVer
?ConvertVertElement@Ogre@@YAXAAU_D3DVERTEXELEMENT9@@ABVVertexElement@1@@Z ENDP ; Ogre::ConvertVertElement
_TEXT	ENDS
PUBLIC	?onLostDevice@D3D9VertexDecl@Ogre@@QAEXXZ	; Ogre::D3D9VertexDecl::onLostDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onLostDevice@D3D9VertexDecl@Ogre@@QAEXXZ PROC		; Ogre::D3D9VertexDecl::onLostDevice
; _this$ = ecx

; 120  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		SAFE_RELEASE(m_pVertDecl);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN2@onLostDevi
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0
$LN2@onLostDevi:

; 122  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@D3D9VertexDecl@Ogre@@QAEXXZ ENDP		; Ogre::D3D9VertexDecl::onLostDevice
_TEXT	ENDS
PUBLIC	?onResetDevice@D3D9VertexDecl@Ogre@@QAE_NXZ	; Ogre::D3D9VertexDecl::onResetDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onResetDevice@D3D9VertexDecl@Ogre@@QAE_NXZ PROC	; Ogre::D3D9VertexDecl::onResetDevice
; _this$ = ecx

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 		return create();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?create@D3D9VertexDecl@Ogre@@QAE_NXZ	; Ogre::D3D9VertexDecl::create

; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@D3D9VertexDecl@Ogre@@QAE_NXZ ENDP	; Ogre::D3D9VertexDecl::onResetDevice
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END

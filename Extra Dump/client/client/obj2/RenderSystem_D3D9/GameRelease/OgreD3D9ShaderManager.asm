; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3D9ShaderManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?ms_MaxLightNum@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_MaxLightNum
PUBLIC	?ms_MaxSkinNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_MaxSkinNum
PUBLIC	?ms_EffectNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_EffectNum
PUBLIC	?ms_EffectMemorySize@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_EffectMemorySize
PUBLIC	?ms_StdEffectNum@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_StdEffectNum
PUBLIC	?ms_BorderEffectNum@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_BorderEffectNum
PUBLIC	?ms_EffectCompileTime@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_EffectCompileTime
PUBLIC	?ms_VSNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_VSNum
PUBLIC	?ms_VSMemorySize@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_VSMemorySize
PUBLIC	?ms_StdVSNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_StdVSNum
PUBLIC	?ms_BorderVSNum@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_BorderVSNum
PUBLIC	?ms_VSCompileTime@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_VSCompileTime
PUBLIC	?ms_PSNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_PSNum
PUBLIC	?ms_PSMemorySize@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_PSMemorySize
PUBLIC	?ms_StdPSNum@CompiledShader@Ogre@@2HA		; Ogre::CompiledShader::ms_StdPSNum
PUBLIC	?ms_BorderPSNum@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_BorderPSNum
PUBLIC	?ms_PSCompileTime@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_PSCompileTime
PUBLIC	?ms_ProcessParamsTime@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_ProcessParamsTime
PUBLIC	?ms_CacheTechniqueTime@CompiledShader@Ogre@@2HA	; Ogre::CompiledShader::ms_CacheTechniqueTime
PUBLIC	?ms_CacheParamHandleTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_CacheParamHandleTime
_BSS	SEGMENT
?ms_MaxLightNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_MaxLightNum
?ms_MaxSkinNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_MaxSkinNum
?ms_EffectNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_EffectNum
?ms_EffectMemorySize@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_EffectMemorySize
?ms_StdEffectNum@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_StdEffectNum
?ms_BorderEffectNum@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_BorderEffectNum
?ms_EffectCompileTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_EffectCompileTime
?ms_VSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_VSNum
?ms_VSMemorySize@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_VSMemorySize
?ms_StdVSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_StdVSNum
?ms_BorderVSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_BorderVSNum
?ms_VSCompileTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_VSCompileTime
?ms_PSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_PSNum
?ms_PSMemorySize@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_PSMemorySize
?ms_StdPSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_StdPSNum
?ms_BorderPSNum@CompiledShader@Ogre@@2HA DD 01H DUP (?)	; Ogre::CompiledShader::ms_BorderPSNum
?ms_PSCompileTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_PSCompileTime
?ms_ProcessParamsTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_ProcessParamsTime
?ms_CacheTechniqueTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_CacheTechniqueTime
?ms_CacheParamHandleTime@CompiledShader@Ogre@@2HA DD 01H DUP (?) ; Ogre::CompiledShader::ms_CacheParamHandleTime
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
	ORG $+4
_s_ParamNames DD FLAT:$SG144306
	DD	FLAT:$SG144307
	DD	FLAT:$SG144308
	DD	FLAT:$SG144309
	DD	FLAT:$SG144310
	DD	FLAT:$SG144311
	DD	FLAT:$SG144312
	DD	FLAT:$SG144313
	DD	FLAT:$SG144314
	DD	FLAT:$SG144315
	DD	FLAT:$SG144316
	DD	FLAT:$SG144317
	DD	FLAT:$SG144318
	DD	FLAT:$SG144319
	DD	FLAT:$SG144320
	DD	FLAT:$SG144321
	DD	FLAT:$SG144322
	DD	FLAT:$SG144323
	DD	FLAT:$SG144324
	DD	FLAT:$SG144325
	DD	FLAT:$SG144326
	DD	FLAT:$SG144327
	DD	FLAT:$SG144328
	DD	FLAT:$SG144329
	DD	FLAT:$SG144330
	DD	FLAT:$SG144331
	DD	FLAT:$SG144332
	DD	FLAT:$SG144333
	DD	FLAT:$SG144334
	DD	FLAT:$SG144335
	DD	FLAT:$SG144336
	DD	FLAT:$SG144337
	DD	FLAT:$SG144338
	DD	FLAT:$SG144339
	DD	FLAT:$SG144340
	DD	FLAT:$SG144341
	DD	FLAT:$SG144342
	DD	FLAT:$SG144343
	DD	FLAT:$SG144344
	DD	FLAT:$SG144345
	DD	FLAT:$SG144346
	DD	FLAT:$SG144347
	DD	FLAT:$SG144348
	DD	FLAT:$SG144349
	DD	FLAT:$SG144350
	DD	FLAT:$SG144351
	DD	FLAT:$SG144352
	DD	FLAT:$SG144353
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
$SG144306 DB	'g_World', 00H
$SG144307 DB	'g_WorldView', 00H
$SG144308 DB	'g_WorldViewProj', 00H
$SG144309 DB	'DIRECTION', 00H
	ORG $+2
$SG144310 DB	'g_AmbientLight', 00H
	ORG $+1
$SG144311 DB	'g_Lights', 00H
	ORG $+3
$SG144312 DB	'g_SpecularColor', 00H
$SG144313 DB	'g_MorphRangePos', 00H
$SG144314 DB	'g_MorphRangeUV', 00H
	ORG $+1
$SG144315 DB	'MORPH_TIME', 00H
	ORG $+1
$SG144316 DB	'g_BoneTM', 00H
	ORG $+3
$SG144317 DB	'g_FogParam', 00H
	ORG $+1
$SG144318 DB	'g_DistFogColor', 00H
	ORG $+1
$SG144319 DB	'g_HeightFogColor', 00H
	ORG $+3
$SG144320 DB	'g_EyePos', 00H
	ORG $+3
$SG144321 DB	'g_EyePosModel', 00H
	ORG $+2
$SG144322 DB	'g_ShadowCenter', 00H
	ORG $+1
$SG144323 DB	'g_depthproj', 00H
$SG144324 DB	'g_depthtexture', 00H
	ORG $+1
$SG144325 DB	'g_shadowdensity', 00H
$SG144326 DB	'ShadowCubeMap', 00H
	ORG $+2
$SG144327 DB	'g_LightSCMPos', 00H
	ORG $+2
$SG144328 DB	'TERRAINDECAL', 00H
	ORG $+3
$SG144329 DB	'g_fTime', 00H
$SG144330 DB	'g_ReflectMap', 00H
	ORG $+3
$SG144331 DB	'REFLECT_MATRIX', 00H
	ORG $+1
$SG144332 DB	'g_FracMap', 00H
	ORG $+2
$SG144333 DB	'g_LightMap', 00H
	ORG $+1
$SG144334 DB	'LIGHTMAP_MATRIX', 00H
$SG144335 DB	'LIGHT_MULTIPLY', 00H
	ORG $+1
$SG144336 DB	'AMBLIGHT_MULTIPLY', 00H
	ORG $+2
$SG144337 DB	'WATERPARA', 00H
	ORG $+2
$SG144338 DB	'WATERCOLOR', 00H
	ORG $+1
$SG144339 DB	'WATERTURB', 00H
	ORG $+2
$SG144340 DB	'g_ModelTransparent', 00H
	ORG $+1
$SG144341 DB	'g_LightDir', 00H
	ORG $+1
$SG144342 DB	'DECAL_TEXTURE0', 00H
	ORG $+1
$SG144343 DB	'DECAL_TEXTURE1', 00H
	ORG $+1
$SG144344 DB	'DECAL_TEXTURE2', 00H
	ORG $+1
$SG144345 DB	'DECAL_TEXTURE3', 00H
	ORG $+1
$SG144346 DB	'DECAL_TEXTURE4', 00H
	ORG $+1
$SG144347 DB	'DECAL_TEXTURE5', 00H
	ORG $+1
$SG144348 DB	'DECAL_TEXTURE6', 00H
	ORG $+1
$SG144349 DB	'DECAL_TEXTURE7', 00H
	ORG $+1
$SG144350 DB	'DECAL_MATRIX', 00H
	ORG $+3
$SG144351 DB	'g_referencepoint', 00H
	ORG $+3
$SG144352 DB	'g_warfogparameter', 00H
	ORG $+2
$SG144353 DB	'g_warfogcolor', 00H
	ORG $+2
$SG144713 DB	'%d', 00H
	ORG $+1
$SG144718 DB	'NUM_LIGHTS', 00H
	ORG $+1
$SG144724 DB	'LIGHT%d_TYPE', 00H
	ORG $+3
$SG144725 DB	'LIGHT%d_SHADOW', 00H
	ORG $+1
$SG144726 DB	'LIGHT%d_SPECULAR', 00H
	ORG $+3
$SG144728 DB	'SKIN_MAXINFL', 00H
	ORG $+3
$SG144730 DB	'MORPH_POS', 00H
	ORG $+2
$SG144732 DB	'MORPH_UV0', 00H
	ORG $+2
$SG144734 DB	'FOG_DISTANCE', 00H
	ORG $+3
$SG144736 DB	'FOG_HEIGHT', 00H
	ORG $+1
$SG144738 DB	'LOG_SHADOWMAP', 00H
	ORG $+2
$SG144740 DB	'LIGHT_MAPPING', 00H
	ORG $+2
$SG144742 DB	'ATI_NV', 00H
	ORG $+1
$SG144744 DB	'TRANSPARENT', 00H
$SG144746 DB	'MRTENABLE', 00H
	ORG $+2
$SG144748 DB	'SHADERLEVEL', 00H
$SG144750 DB	'DECALBLENDMODE', 00H
	ORG $+1
$SG144752 DB	'MODEL_TRANSPARENT', 00H
	ORG $+2
$SG144761 DB	'stdmtl', 00H
	ORG $+1
$SG144763 DB	'border', 00H
	ORG $+1
$SG144767 DB	'stdmtl', 00H
	ORG $+1
$SG144769 DB	'border', 00H
	ORG $+1
$SG144773 DB	'stdmtl', 00H
	ORG $+1
$SG144775 DB	'border', 00H
	ORG $+1
$SG144935 DB	'lod', 00H
$SG144936 DB	'usage', 00H
	ORG $+2
$SG144946 DB	'vs', 00H
	ORG $+1
$SG144951 DB	'ps', 00H
	ORG $+1
$SG145247 DB	'vs_2_0', 00H
	ORG $+1
$SG145248 DB	'VSMain', 00H
	ORG $+1
$SG145250 DB	'ps_2_0', 00H
	ORG $+1
$SG145251 DB	'PSMain', 00H
CONST	ENDS
PUBLIC	??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::push_back
PUBLIC	??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	??0ShaderMacroMgr@Ogre@@QAE@XZ			; Ogre::ShaderMacroMgr::ShaderMacroMgr
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??0ShaderMacroMgr@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ShaderMacroMgr@Ogre@@QAE@XZ$0
__ehfuncinfo$??0ShaderMacroMgr@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ShaderMacroMgr@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ShaderMacroMgr@Ogre@@QAE@XZ PROC			; Ogre::ShaderMacroMgr::ShaderMacroMgr
; _this$ = ecx

; 85   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ShaderMacroMgr@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 86   : 		m_Tail.Definition = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 87   : 		m_Tail.Name = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 88   : 		m_Macros.push_back(m_Tail);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::push_back

; 89   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ShaderMacroMgr@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
__ehhandler$??0ShaderMacroMgr@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ShaderMacroMgr@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ShaderMacroMgr@Ogre@@QAE@XZ ENDP			; Ogre::ShaderMacroMgr::ShaderMacroMgr
PUBLIC	??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
PUBLIC	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
PUBLIC	??1ShaderMacroMgr@Ogre@@QAE@XZ			; Ogre::ShaderMacroMgr::~ShaderMacroMgr
EXTRN	__imp__free:PROC
xdata$x	SEGMENT
__unwindtable$??1ShaderMacroMgr@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ShaderMacroMgr@Ogre@@QAE@XZ$0
__ehfuncinfo$??1ShaderMacroMgr@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ShaderMacroMgr@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$144694 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ShaderMacroMgr@Ogre@@QAE@XZ PROC			; Ogre::ShaderMacroMgr::~ShaderMacroMgr
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ShaderMacroMgr@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 93   : 		for(size_t i=0; i<m_Macros.size()-1; i++)

	mov	DWORD PTR _i$144694[ebp], 0
	jmp	SHORT $LN3@ShaderMacr
$LN2@ShaderMacr:
	mov	eax, DWORD PTR _i$144694[ebp]
	add	eax, 1
	mov	DWORD PTR _i$144694[ebp], eax
$LN3@ShaderMacr:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	sub	eax, 1
	cmp	DWORD PTR _i$144694[ebp], eax
	jae	SHORT $LN4@ShaderMacr

; 94   : 		{
; 95   : 			free((void *)m_Macros[i].Definition);

	mov	ecx, DWORD PTR _i$144694[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 96   : 			free((void *)m_Macros[i].Name);

	mov	eax, DWORD PTR _i$144694[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
	jmp	SHORT $LN2@ShaderMacr
$LN4@ShaderMacr:

; 97   : 		}
; 98   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1ShaderMacroMgr@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
__ehhandler$??1ShaderMacroMgr@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ShaderMacroMgr@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ShaderMacroMgr@Ogre@@QAE@XZ ENDP			; Ogre::ShaderMacroMgr::~ShaderMacroMgr
PUBLIC	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ	; _snprintf_s<256>
PUBLIC	__$ArrayPad$
PUBLIC	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z	; Ogre::ShaderMacroMgr::AddMacro
EXTRN	__imp___strdup:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -276						; size = 4
_buffer$ = -272						; size = 256
__$ArrayPad$ = -12					; size = 4
_tmp$ = -8						; size = 8
_pname$ = 8						; size = 4
_value$ = 12						; size = 4
?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z PROC		; Ogre::ShaderMacroMgr::AddMacro
; _this$ = ecx

; 101  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		char buffer[256];
; 103  : 		D3DXMACRO tmp;
; 104  : 
; 105  : 		tmp.Name = _strdup(pname);

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 106  : 		_snprintf_s(buffer,sizeof(buffer), "%d", value);

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET $SG144713
	push	256					; 00000100H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ; _snprintf_s<256>
	add	esp, 16					; 00000010H

; 107  : 		tmp.Definition = _strdup(buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp+4], eax

; 108  : 
; 109  : 		m_Macros[m_Macros.size()-1] = tmp;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 110  : 		m_Macros.push_back(m_Tail);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::push_back

; 111  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ENDP		; Ogre::ShaderMacroMgr::AddMacro
_TEXT	ENDS
PUBLIC	?GetEnvLightSpecular@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightSpecular
PUBLIC	?GetEnvLightShadow@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightShadow
PUBLIC	?GetEnvLightType@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightType
PUBLIC	__$ArrayPad$
PUBLIC	?createFromShaderEnv@ShaderMacroMgr@Ogre@@QAEXABUShaderEnvFlags@2@@Z ; Ogre::ShaderMacroMgr::createFromShaderEnv
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -268						; size = 4
_buffer$144723 = -264					; size = 256
__$ArrayPad$ = -8					; size = 4
_i$144719 = -4						; size = 4
_env$ = 8						; size = 4
?createFromShaderEnv@ShaderMacroMgr@Ogre@@QAEXABUShaderEnvFlags@2@@Z PROC ; Ogre::ShaderMacroMgr::createFromShaderEnv
; _this$ = ecx

; 114  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 		AddMacro("NUM_LIGHTS", env.nlight);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	push	ecx
	push	OFFSET $SG144718
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro

; 116  : 
; 117  : 		for(int i=0; i<int(env.nlight); i++)

	mov	DWORD PTR _i$144719[ebp], 0
	jmp	SHORT $LN16@createFrom
$LN15@createFrom:
	mov	edx, DWORD PTR _i$144719[ebp]
	add	edx, 1
	mov	DWORD PTR _i$144719[ebp], edx
$LN16@createFrom:
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 7
	cmp	DWORD PTR _i$144719[ebp], ecx
	jge	$LN14@createFrom

; 118  : 		{
; 119  : 			char buffer[256];
; 120  : 			_snprintf_s(buffer,sizeof(buffer), "LIGHT%d_TYPE", i);

	mov	edx, DWORD PTR _i$144719[ebp]
	push	edx
	push	OFFSET $SG144724
	push	256					; 00000100H
	lea	eax, DWORD PTR _buffer$144723[ebp]
	push	eax
	call	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ; _snprintf_s<256>
	add	esp, 16					; 00000010H

; 121  : 			AddMacro(buffer, GetEnvLightType(env, i));

	mov	ecx, DWORD PTR _i$144719[ebp]
	push	ecx
	mov	edx, DWORD PTR _env$[ebp]
	push	edx
	call	?GetEnvLightType@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightType
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _buffer$144723[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro

; 122  : 			_snprintf_s(buffer,sizeof(buffer), "LIGHT%d_SHADOW", i);

	mov	ecx, DWORD PTR _i$144719[ebp]
	push	ecx
	push	OFFSET $SG144725
	push	256					; 00000100H
	lea	edx, DWORD PTR _buffer$144723[ebp]
	push	edx
	call	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ; _snprintf_s<256>
	add	esp, 16					; 00000010H

; 123  : 			AddMacro(buffer, GetEnvLightShadow(env, i));

	mov	eax, DWORD PTR _i$144719[ebp]
	push	eax
	mov	ecx, DWORD PTR _env$[ebp]
	push	ecx
	call	?GetEnvLightShadow@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightShadow
	add	esp, 8
	push	eax
	lea	edx, DWORD PTR _buffer$144723[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro

; 124  : 			_snprintf_s(buffer,sizeof(buffer), "LIGHT%d_SPECULAR", i);

	mov	eax, DWORD PTR _i$144719[ebp]
	push	eax
	push	OFFSET $SG144726
	push	256					; 00000100H
	lea	ecx, DWORD PTR _buffer$144723[ebp]
	push	ecx
	call	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ; _snprintf_s<256>
	add	esp, 16					; 00000010H

; 125  : 			AddMacro(buffer, GetEnvLightSpecular(env, i));

	mov	edx, DWORD PTR _i$144719[ebp]
	push	edx
	mov	eax, DWORD PTR _env$[ebp]
	push	eax
	call	?GetEnvLightSpecular@Ogre@@YAHABUShaderEnvFlags@1@H@Z ; Ogre::GetEnvLightSpecular
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _buffer$144723[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro

; 126  : 		}

	jmp	$LN15@createFrom
$LN14@createFrom:

; 127  : 
; 128  : 		if(env.skin_maxinfl > 0) AddMacro("SKIN_MAXINFL", env.skin_maxinfl);

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 18					; 00000012H
	and	eax, 7
	jbe	SHORT $LN13@createFrom
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 18					; 00000012H
	and	edx, 7
	push	edx
	push	OFFSET $SG144728
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN13@createFrom:

; 129  : 
; 130  : 		if(env.morph_pos > 0) AddMacro("MORPH_POS", env.morph_pos);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 21					; 00000015H
	and	ecx, 1
	jbe	SHORT $LN12@createFrom
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 21					; 00000015H
	and	eax, 1
	push	eax
	push	OFFSET $SG144730
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN12@createFrom:

; 131  : 
; 132  : 		if(env.morph_uv0 > 0) AddMacro("MORPH_UV0", env.morph_uv0);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 22					; 00000016H
	and	edx, 1
	jbe	SHORT $LN11@createFrom
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 22					; 00000016H
	and	ecx, 1
	push	ecx
	push	OFFSET $SG144732
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN11@createFrom:

; 133  : 
; 134  : 		if(env.distfog > 0) AddMacro("FOG_DISTANCE", env.distfog);

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 15					; 0000000fH
	and	eax, 1
	jbe	SHORT $LN10@createFrom
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	push	edx
	push	OFFSET $SG144734
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN10@createFrom:

; 135  : 
; 136  : 		if(env.heightfog > 0) AddMacro("FOG_HEIGHT", env.heightfog);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	jbe	SHORT $LN9@createFrom
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 16					; 00000010H
	and	eax, 1
	push	eax
	push	OFFSET $SG144736
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN9@createFrom:

; 137  : 
; 138  : 		if(env.log_shadowmap > 0) AddMacro("LOG_SHADOWMAP", env.log_shadowmap);//非线性放缩shadowmap

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 17					; 00000011H
	and	edx, 1
	jbe	SHORT $LN8@createFrom
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	push	ecx
	push	OFFSET $SG144738
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN8@createFrom:

; 139  : 
; 140  : 		if(env.lightmap > 0) AddMacro("LIGHT_MAPPING", env.lightmap);

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 24					; 00000018H
	and	eax, 15					; 0000000fH
	jbe	SHORT $LN7@createFrom
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	push	edx
	push	OFFSET $SG144740
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN7@createFrom:

; 141  : 
; 142  : 		if(env.vctype > 0) AddMacro("ATI_NV", env.vctype);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 28					; 0000001cH
	and	ecx, 15					; 0000000fH
	jbe	SHORT $LN6@createFrom
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 28					; 0000001cH
	and	eax, 15					; 0000000fH
	push	eax
	push	OFFSET $SG144742
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN6@createFrom:

; 143  : 
; 144  : 		if(env.transparent > 0) AddMacro("TRANSPARENT", env.transparent);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	and	edx, 15					; 0000000fH
	jbe	SHORT $LN5@createFrom
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET $SG144744
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN5@createFrom:

; 145  : 
; 146  : 		if(env.mrt > 0) AddMacro("MRTENABLE", env.mrt);

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 4
	and	eax, 15					; 0000000fH
	jbe	SHORT $LN4@createFrom
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 4
	and	edx, 15					; 0000000fH
	push	edx
	push	OFFSET $SG144746
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN4@createFrom:

; 147  : 
; 148  : 		if(env.shaderlevel > 0) AddMacro("SHADERLEVEL", env.shaderlevel);

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 8
	and	ecx, 15					; 0000000fH
	jbe	SHORT $LN3@createFrom
	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx+4]
	shr	eax, 8
	and	eax, 15					; 0000000fH
	push	eax
	push	OFFSET $SG144748
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN3@createFrom:

; 149  : 
; 150  : 		if(env.decalblendmode > 0) AddMacro("DECALBLENDMODE", env.decalblendmode);

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 12					; 0000000cH
	and	edx, 15					; 0000000fH
	jbe	SHORT $LN2@createFrom
	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET $SG144750
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN2@createFrom:

; 151  : 
; 152  : 		if(env.model_xparent > 0) AddMacro("MODEL_TRANSPARENT", env.model_xparent);

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 23					; 00000017H
	and	eax, 1
	jbe	SHORT $LN17@createFrom
	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 23					; 00000017H
	and	edx, 1
	push	edx
	push	OFFSET $SG144752
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN17@createFrom:

; 153  : 		
; 154  : 		
; 155  : 	
; 156  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?createFromShaderEnv@ShaderMacroMgr@Ogre@@QAEXABUShaderEnvFlags@2@@Z ENDP ; Ogre::ShaderMacroMgr::createFromShaderEnv
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreshader.h
_TEXT	ENDS
;	COMDAT ?GetEnvLightType@Ogre@@YAHABUShaderEnvFlags@1@H@Z
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_index$ = 12						; size = 4
?GetEnvLightType@Ogre@@YAHABUShaderEnvFlags@1@H@Z PROC	; Ogre::GetEnvLightType, COMDAT

; 100  : 	{

	push	ebp
	mov	ebp, esp

; 101  : 		if(index == 0) return flags.light0_type;

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN6@GetEnvLigh
	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 3
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh
	jmp	SHORT $LN7@GetEnvLigh
$LN6@GetEnvLigh:

; 102  : 		else if(index == 1) return flags.light1_type;

	cmp	DWORD PTR _index$[ebp], 1
	jne	SHORT $LN4@GetEnvLigh
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [ecx]
	shr	eax, 6
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh
	jmp	SHORT $LN7@GetEnvLigh
$LN4@GetEnvLigh:

; 103  : 		else if(index == 2) return flags.light2_type;

	cmp	DWORD PTR _index$[ebp], 2
	jne	SHORT $LN2@GetEnvLigh
	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 9
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh
	jmp	SHORT $LN7@GetEnvLigh
$LN2@GetEnvLigh:

; 104  : 		else return flags.light3_type;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 12					; 0000000cH
	and	eax, 1
$LN7@GetEnvLigh:

; 105  : 	}

	pop	ebp
	ret	0
?GetEnvLightType@Ogre@@YAHABUShaderEnvFlags@1@H@Z ENDP	; Ogre::GetEnvLightType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetEnvLightShadow@Ogre@@YAHABUShaderEnvFlags@1@H@Z
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_index$ = 12						; size = 4
?GetEnvLightShadow@Ogre@@YAHABUShaderEnvFlags@1@H@Z PROC ; Ogre::GetEnvLightShadow, COMDAT

; 107  : 	{

	push	ebp
	mov	ebp, esp

; 108  : 		if(index == 0) return flags.light0_shadow;

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN6@GetEnvLigh@2
	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 4
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@2
	jmp	SHORT $LN7@GetEnvLigh@2
$LN6@GetEnvLigh@2:

; 109  : 		else if(index == 1) return flags.light1_shadow;

	cmp	DWORD PTR _index$[ebp], 1
	jne	SHORT $LN4@GetEnvLigh@2
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [ecx]
	shr	eax, 7
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@2
	jmp	SHORT $LN7@GetEnvLigh@2
$LN4@GetEnvLigh@2:

; 110  : 		else if(index == 2) return flags.light2_shadow;

	cmp	DWORD PTR _index$[ebp], 2
	jne	SHORT $LN2@GetEnvLigh@2
	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@2
	jmp	SHORT $LN7@GetEnvLigh@2
$LN2@GetEnvLigh@2:

; 111  : 		else return flags.light3_shadow;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 13					; 0000000dH
	and	eax, 1
$LN7@GetEnvLigh@2:

; 112  : 	}

	pop	ebp
	ret	0
?GetEnvLightShadow@Ogre@@YAHABUShaderEnvFlags@1@H@Z ENDP ; Ogre::GetEnvLightShadow
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetEnvLightSpecular@Ogre@@YAHABUShaderEnvFlags@1@H@Z
_TEXT	SEGMENT
_flags$ = 8						; size = 4
_index$ = 12						; size = 4
?GetEnvLightSpecular@Ogre@@YAHABUShaderEnvFlags@1@H@Z PROC ; Ogre::GetEnvLightSpecular, COMDAT

; 114  : 	{

	push	ebp
	mov	ebp, esp

; 115  : 		if(index == 0) return flags.light0_specular;

	cmp	DWORD PTR _index$[ebp], 0
	jne	SHORT $LN6@GetEnvLigh@3
	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 5
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@3
	jmp	SHORT $LN7@GetEnvLigh@3
$LN6@GetEnvLigh@3:

; 116  : 		else if(index == 1) return flags.light1_specular;

	cmp	DWORD PTR _index$[ebp], 1
	jne	SHORT $LN4@GetEnvLigh@3
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [ecx]
	shr	eax, 8
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@3
	jmp	SHORT $LN7@GetEnvLigh@3
$LN4@GetEnvLigh@3:

; 117  : 		else if(index == 2) return flags.light2_specular;

	cmp	DWORD PTR _index$[ebp], 2
	jne	SHORT $LN2@GetEnvLigh@3
	mov	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	jmp	SHORT $LN7@GetEnvLigh@3
	jmp	SHORT $LN7@GetEnvLigh@3
$LN2@GetEnvLigh@3:

; 118  : 		else return flags.light3_specular;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [eax]
	shr	eax, 14					; 0000000eH
	and	eax, 1
$LN7@GetEnvLigh@3:

; 119  : 	}

	pop	ebp
	ret	0
?GetEnvLightSpecular@Ogre@@YAHABUShaderEnvFlags@1@H@Z ENDP ; Ogre::GetEnvLightSpecular
_TEXT	ENDS
PUBLIC	??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
PUBLIC	??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z ; Ogre::CompiledShader::CompiledShader
EXTRN	__imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z:PROC
EXTRN	__imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ:PROC
EXTRN	__imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ:PROC
xdata$x	SEGMENT
__unwindtable$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$2
__ehfuncinfo$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_createCompiledShader$ = 8				; size = 4
_type$ = 12						; size = 4
??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z PROC ; Ogre::CompiledShader::CompiledShader
; _this$ = ecx

; 186  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 187  : 		m_pDevice = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr())->getD3DDevice();

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	mov	ecx, eax
	call	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 188  : 
; 189  : 		m_bCreated = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+364], 0

; 190  : 		m_bAllCreated = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+365], 0

; 191  : 
; 192  : 		if (type == COMPILED_EFFECT)

	cmp	DWORD PTR _type$[ebp], 0
	jne	SHORT $LN11@CompiledSh

; 193  : 		{
; 194  : 			ms_EffectNum++;

	mov	ecx, DWORD PTR ?ms_EffectNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_EffectNum
	add	ecx, 1
	mov	DWORD PTR ?ms_EffectNum@CompiledShader@Ogre@@2HA, ecx ; Ogre::CompiledShader::ms_EffectNum

; 195  : 
; 196  : 			if (createCompiledShader->getName() == "stdmtl")

	push	OFFSET $SG144761
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@CompiledSh

; 197  : 				ms_StdEffectNum++;

	mov	eax, DWORD PTR ?ms_StdEffectNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_StdEffectNum
	add	eax, 1
	mov	DWORD PTR ?ms_StdEffectNum@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_StdEffectNum
$LN10@CompiledSh:

; 198  : 
; 199  : 			if (createCompiledShader->getName() == "border")

	push	OFFSET $SG144763
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@CompiledSh

; 200  : 				ms_BorderEffectNum++;

	mov	edx, DWORD PTR ?ms_BorderEffectNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_BorderEffectNum
	add	edx, 1
	mov	DWORD PTR ?ms_BorderEffectNum@CompiledShader@Ogre@@2HA, edx ; Ogre::CompiledShader::ms_BorderEffectNum
$LN9@CompiledSh:

; 201  : 		}

	jmp	$LN12@CompiledSh
$LN11@CompiledSh:

; 202  : 		else if (type == COMPILED_VS)

	cmp	DWORD PTR _type$[ebp], 1
	jne	SHORT $LN7@CompiledSh

; 203  : 		{
; 204  : 			ms_VSNum++;

	mov	eax, DWORD PTR ?ms_VSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_VSNum
	add	eax, 1
	mov	DWORD PTR ?ms_VSNum@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_VSNum

; 205  : 
; 206  : 			if (createCompiledShader->getName() == "stdmtl")

	push	OFFSET $SG144767
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@CompiledSh

; 207  : 				ms_StdVSNum++;

	mov	edx, DWORD PTR ?ms_StdVSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_StdVSNum
	add	edx, 1
	mov	DWORD PTR ?ms_StdVSNum@CompiledShader@Ogre@@2HA, edx ; Ogre::CompiledShader::ms_StdVSNum
$LN6@CompiledSh:

; 208  : 
; 209  : 			if (createCompiledShader->getName() == "border")

	push	OFFSET $SG144769
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@CompiledSh

; 210  : 				ms_BorderVSNum++;

	mov	ecx, DWORD PTR ?ms_BorderVSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_BorderVSNum
	add	ecx, 1
	mov	DWORD PTR ?ms_BorderVSNum@CompiledShader@Ogre@@2HA, ecx ; Ogre::CompiledShader::ms_BorderVSNum
$LN5@CompiledSh:

; 211  : 		}

	jmp	SHORT $LN12@CompiledSh
$LN7@CompiledSh:

; 212  : 		else if (type == COMPILED_PS)

	cmp	DWORD PTR _type$[ebp], 2
	jne	SHORT $LN12@CompiledSh

; 213  : 		{
; 214  : 			ms_PSNum++;

	mov	edx, DWORD PTR ?ms_PSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_PSNum
	add	edx, 1
	mov	DWORD PTR ?ms_PSNum@CompiledShader@Ogre@@2HA, edx ; Ogre::CompiledShader::ms_PSNum

; 215  : 
; 216  : 			if (createCompiledShader->getName() == "stdmtl")

	push	OFFSET $SG144773
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CompiledSh

; 217  : 				ms_StdPSNum++;

	mov	ecx, DWORD PTR ?ms_StdPSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_StdPSNum
	add	ecx, 1
	mov	DWORD PTR ?ms_StdPSNum@CompiledShader@Ogre@@2HA, ecx ; Ogre::CompiledShader::ms_StdPSNum
$LN2@CompiledSh:

; 218  : 
; 219  : 			if (createCompiledShader->getName() == "border")

	push	OFFSET $SG144775
	mov	ecx, DWORD PTR _createCompiledShader$[ebp]
	call	DWORD PTR __imp_?getName@MaterialTemplate@Ogre@@QAEABVFixedString@2@XZ
	push	eax
	call	DWORD PTR __imp_??8Ogre@@YA_NABVFixedString@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@CompiledSh

; 220  : 				ms_BorderPSNum++;

	mov	eax, DWORD PTR ?ms_BorderPSNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_BorderPSNum
	add	eax, 1
	mov	DWORD PTR ?ms_BorderPSNum@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_BorderPSNum
$LN12@CompiledSh:

; 221  : 		}
; 222  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	jmp	??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
__unwindfunclet$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
__ehhandler$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z ENDP ; Ogre::CompiledShader::CompiledShader
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.h
;	COMDAT ?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ PROC ; Ogre::D3D9RenderSystem::getD3DDevice, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_pd3dDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ENDP ; Ogre::D3D9RenderSystem::getD3DDevice
_TEXT	ENDS
PUBLIC	??_GTechniqueDesc@Ogre@@QAEPAXI@Z		; Ogre::TechniqueDesc::`scalar deleting destructor'
PUBLIC	??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator[]
PUBLIC	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
PUBLIC	??1CompiledShader@Ogre@@QAE@XZ			; Ogre::CompiledShader::~CompiledShader
xdata$x	SEGMENT
__unwindtable$??1CompiledShader@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$2
__ehfuncinfo$??1CompiledShader@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CompiledShader@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv185 = -32						; size = 4
_this$ = -28						; size = 4
$T157777 = -24						; size = 4
$T157776 = -20						; size = 4
_i$144784 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CompiledShader@Ogre@@QAE@XZ PROC			; Ogre::CompiledShader::~CompiledShader
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CompiledShader@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 226  : 		SAFE_RELEASE(m_pBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@CompiledSh@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$LN8@CompiledSh@2:

; 227  : 		SAFE_RELEASE(m_pEffect);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN7@CompiledSh@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+44], 0
$LN7@CompiledSh@2:

; 228  : 		SAFE_RELEASE(m_pVS);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN6@CompiledSh@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
$LN6@CompiledSh@2:

; 229  : 		SAFE_RELEASE(m_pPS);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN5@CompiledSh@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0
$LN5@CompiledSh@2:

; 230  : 		SAFE_RELEASE(m_pConst);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN4@CompiledSh@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 0
$LN4@CompiledSh@2:

; 231  : 
; 232  : 		for(size_t i=0; i<m_TechDesc.size(); i++)

	mov	DWORD PTR _i$144784[ebp], 0
	jmp	SHORT $LN3@CompiledSh@2
$LN2@CompiledSh@2:
	mov	ecx, DWORD PTR _i$144784[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$144784[ebp], ecx
$LN3@CompiledSh@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	cmp	DWORD PTR _i$144784[ebp], eax
	jae	SHORT $LN9@CompiledSh@2

; 233  : 		{
; 234  : 			delete m_TechDesc[i];

	mov	edx, DWORD PTR _i$144784[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T157777[ebp], eax
	mov	ecx, DWORD PTR $T157777[ebp]
	mov	DWORD PTR $T157776[ebp], ecx
	cmp	DWORD PTR $T157776[ebp], 0
	je	SHORT $LN11@CompiledSh@2
	push	1
	mov	ecx, DWORD PTR $T157776[ebp]
	call	??_GTechniqueDesc@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN12@CompiledSh@2
$LN11@CompiledSh@2:
	mov	DWORD PTR tv185[ebp], 0
$LN12@CompiledSh@2:

; 235  : 		}

	jmp	SHORT $LN2@CompiledSh@2
$LN9@CompiledSh@2:

; 236  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	jmp	??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
__unwindfunclet$??1CompiledShader@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	jmp	??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
__ehhandler$??1CompiledShader@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CompiledShader@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CompiledShader@Ogre@@QAE@XZ ENDP			; Ogre::CompiledShader::~CompiledShader
PUBLIC	??1TechniqueDesc@Ogre@@QAE@XZ			; Ogre::TechniqueDesc::~TechniqueDesc
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GTechniqueDesc@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTechniqueDesc@Ogre@@QAEPAXI@Z PROC			; Ogre::TechniqueDesc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TechniqueDesc@Ogre@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTechniqueDesc@Ogre@@QAEPAXI@Z ENDP			; Ogre::TechniqueDesc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1TechniqueDesc@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1TechniqueDesc@Ogre@@QAE@XZ$0
__ehfuncinfo$??1TechniqueDesc@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1TechniqueDesc@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1TechniqueDesc@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1TechniqueDesc@Ogre@@QAE@XZ PROC			; Ogre::TechniqueDesc::~TechniqueDesc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1TechniqueDesc@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1TechniqueDesc@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
__ehhandler$??1TechniqueDesc@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1TechniqueDesc@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1TechniqueDesc@Ogre@@QAE@XZ ENDP			; Ogre::TechniqueDesc::~TechniqueDesc
PUBLIC	?getTechnique@CompiledShader@Ogre@@QAEPAUTechniqueDesc@2@IW4RenderUsage@2@@Z ; Ogre::CompiledShader::getTechnique
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_ptech$144807 = -16					; size = 4
_i$144803 = -12						; size = 4
_tech_usage$ = -8					; size = 4
_pbesttech$ = -4					; size = 4
_lod$ = 8						; size = 4
_renderusage$ = 12					; size = 4
?getTechnique@CompiledShader@Ogre@@QAEPAUTechniqueDesc@2@IW4RenderUsage@2@@Z PROC ; Ogre::CompiledShader::getTechnique
; _this$ = ecx

; 239  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 		TechniqueDesc *pbesttech = NULL;

	mov	DWORD PTR _pbesttech$[ebp], 0

; 241  : 		size_t tech_usage = 1;

	mov	DWORD PTR _tech_usage$[ebp], 1

; 242  : 		tech_usage = tech_usage<<renderusage;

	mov	eax, DWORD PTR _tech_usage$[ebp]
	mov	ecx, DWORD PTR _renderusage$[ebp]
	shl	eax, cl
	mov	DWORD PTR _tech_usage$[ebp], eax

; 243  : 
; 244  : 		for(size_t i=0; i<m_TechDesc.size(); i++)

	mov	DWORD PTR _i$144803[ebp], 0
	jmp	SHORT $LN6@getTechniq
$LN5@getTechniq:
	mov	ecx, DWORD PTR _i$144803[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$144803[ebp], ecx
$LN6@getTechniq:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	cmp	DWORD PTR _i$144803[ebp], eax
	jae	SHORT $LN4@getTechniq

; 245  : 		{
; 246  : 			TechniqueDesc *ptech = m_TechDesc[i];

	mov	edx, DWORD PTR _i$144803[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _ptech$144807[ebp], eax

; 247  : 			if(ptech->renderusage&tech_usage)

	mov	ecx, DWORD PTR _ptech$144807[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, DWORD PTR _tech_usage$[ebp]
	je	SHORT $LN3@getTechniq

; 248  : 			{
; 249  : 				if(ptech->lod == lod)

	mov	eax, DWORD PTR _ptech$144807[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _lod$[ebp]
	jne	SHORT $LN2@getTechniq

; 250  : 					return ptech;

	mov	eax, DWORD PTR _ptech$144807[ebp]
	jmp	SHORT $LN7@getTechniq

; 251  : 				else 

	jmp	SHORT $LN3@getTechniq
$LN2@getTechniq:

; 252  : 					pbesttech = ptech;

	mov	edx, DWORD PTR _ptech$144807[ebp]
	mov	DWORD PTR _pbesttech$[ebp], edx
$LN3@getTechniq:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN5@getTechniq
$LN4@getTechniq:

; 255  : 
; 256  : 		return pbesttech;

	mov	eax, DWORD PTR _pbesttech$[ebp]
$LN7@getTechniq:

; 257  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?getTechnique@CompiledShader@Ogre@@QAEPAUTechniqueDesc@2@IW4RenderUsage@2@@Z ENDP ; Ogre::CompiledShader::getTechnique
_TEXT	ENDS
PUBLIC	?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ	; Ogre::CompiledShader::cacheParamHandle
EXTRN	__imp_??BFixedString@Ogre@@QBEPBDXZ:PROC
EXTRN	__imp_?getParam@MaterialTemplate@Ogre@@QAEPAUParamDefine@12@I@Z:PROC
EXTRN	__imp_?getNumParam@MaterialTemplate@Ogre@@QAEIXZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pname$144834 = -12					; size = 4
_pname$144824 = -8					; size = 4
_i$ = -4						; size = 4
?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ PROC	; Ogre::CompiledShader::cacheParamHandle
; _this$ = ecx

; 260  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 		size_t i;
; 262  : 
; 263  : 		assert(m_pMtlTemplate->getNumParam() <= ARRAY_ELEMENTS(m_MtlHandles));
; 264  : 		if(m_Type == COMPILED_EFFECT) //!!!effect会把所有的参数编译进去

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	$LN16@cacheParam

; 265  : 		{
; 266  : 			for(i=0; i<SPU_ENV_PARAM_END; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN15@cacheParam
$LN14@cacheParam:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN15@cacheParam:
	cmp	DWORD PTR _i$[ebp], 48			; 00000030H
	jae	SHORT $LN13@cacheParam

; 267  : 			{
; 268  : 				if (m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN12@cacheParam

; 269  : 					m_EnvHandles[i] = m_pEffect->GetParameterByName(NULL, s_ParamNames[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s_ParamNames[eax*4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+60], eax
$LN12@cacheParam:

; 270  : 			}

	jmp	SHORT $LN14@cacheParam
$LN13@cacheParam:

; 271  : 
; 272  : 			for(i=0; i<m_pMtlTemplate->getNumParam(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN11@cacheParam
$LN10@cacheParam:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN11@cacheParam:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?getNumParam@MaterialTemplate@Ogre@@QAEIXZ
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN9@cacheParam

; 273  : 			{
; 274  : 				const char *pname = (const char *)m_pMtlTemplate->getParam(i)->name;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?getParam@MaterialTemplate@Ogre@@QAEPAUParamDefine@12@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	mov	DWORD PTR _pname$144824[ebp], eax

; 275  : 				if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@cacheParam

; 276  : 					m_MtlHandles[i] = m_pEffect->GetParameterByName(NULL, pname);

	mov	ecx, DWORD PTR _pname$144824[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+252], eax
$LN8@cacheParam:

; 277  : 			}

	jmp	SHORT $LN10@cacheParam
$LN9@cacheParam:

; 278  : 		}
; 279  : 		else

	jmp	$LN17@cacheParam
$LN16@cacheParam:

; 280  : 		{
; 281  : 			for(i=0; i<SPU_ENV_PARAM_END; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@cacheParam
$LN5@cacheParam:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN6@cacheParam:
	cmp	DWORD PTR _i$[ebp], 48			; 00000030H
	jae	SHORT $LN4@cacheParam

; 282  : 			{
; 283  : 				m_EnvHandles[i] = m_pConst->GetConstantByName(NULL, s_ParamNames[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _s_ParamNames[eax*4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+60], eax

; 284  : 			}

	jmp	SHORT $LN5@cacheParam
$LN4@cacheParam:

; 285  : 
; 286  : 			for(i=0; i<m_pMtlTemplate->getNumParam(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@cacheParam
$LN2@cacheParam:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@cacheParam:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR __imp_?getNumParam@MaterialTemplate@Ogre@@QAEIXZ
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN17@cacheParam

; 287  : 			{
; 288  : 				const char *pname = (const char *)m_pMtlTemplate->getParam(i)->name;

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	DWORD PTR __imp_?getParam@MaterialTemplate@Ogre@@QAEPAUParamDefine@12@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	mov	DWORD PTR _pname$144834[ebp], eax

; 289  : 				m_MtlHandles[i] = m_pConst->GetConstantByName(NULL, pname);

	mov	eax, DWORD PTR _pname$144834[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+36]
	call	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+252], eax

; 290  : 			}

	jmp	SHORT $LN2@cacheParam
$LN17@cacheParam:

; 291  : 		}
; 292  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ ENDP	; Ogre::CompiledShader::cacheParamHandle
_TEXT	ENDS
PUBLIC	?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z	; Ogre::CompiledShader::setConstant
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_h$144849 = -8						; size = 4
_h$144843 = -4						; size = 4
_pname$ = 8						; size = 4
_pdata$ = 12						; size = 4
_len$ = 16						; size = 4
?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z PROC	; Ogre::CompiledShader::setConstant
; _this$ = ecx

; 295  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 		if(m_Type == COMPILED_EFFECT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@setConstan

; 297  : 		{
; 298  : 			D3DXHANDLE h = NULL; 

	mov	DWORD PTR _h$144843[ebp], 0

; 299  : 			if (m_pEffect)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN5@setConstan

; 300  : 				h = m_pEffect->GetParameterByName(NULL, pname);

	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	mov	DWORD PTR _h$144843[ebp], eax
$LN5@setConstan:

; 301  : 			if(h != NULL)

	cmp	DWORD PTR _h$144843[ebp], 0
	je	SHORT $LN4@setConstan

; 302  : 			{
; 303  : 				if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN4@setConstan

; 304  : 					m_pEffect->SetValue(h, pdata, (UINT)len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _h$144843[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+80]
	call	eax
$LN4@setConstan:

; 305  : 			}
; 306  : 		}
; 307  : 		else

	jmp	SHORT $LN7@setConstan
$LN6@setConstan:

; 308  : 		{
; 309  : 			D3DXHANDLE h = m_pConst->GetConstantByName(NULL, pname);

	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+36]
	call	ecx
	mov	DWORD PTR _h$144849[ebp], eax

; 310  : 			if(h != NULL) m_pConst->SetValue(m_pDevice, h, pdata, (UINT)len);

	cmp	DWORD PTR _h$144849[ebp], 0
	je	SHORT $LN7@setConstan
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$144849[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax
$LN7@setConstan:

; 311  : 		}
; 312  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z ENDP	; Ogre::CompiledShader::setConstant
_TEXT	ENDS
PUBLIC	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -64						; size = 4
_cdesc$144870 = -60					; size = 48
_count$144871 = -12					; size = 4
_i$144861 = -8						; size = 4
_h$ = -4						; size = 4
_usage$ = 8						; size = 4
_pdata$ = 12						; size = 4
_len$ = 16						; size = 4
?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z PROC ; Ogre::CompiledShader::setConstant
; _this$ = ecx

; 315  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 		D3DXHANDLE h;
; 317  : 		if(usage < SPU_ENV_PARAM_END) h = m_EnvHandles[usage];

	cmp	DWORD PTR _usage$[ebp], 48		; 00000030H
	jge	SHORT $LN13@setConstan@2
	mov	eax, DWORD PTR _usage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+60]
	mov	DWORD PTR _h$[ebp], edx

; 318  : 		else

	jmp	SHORT $LN12@setConstan@2
$LN13@setConstan@2:

; 319  : 		{
; 320  : 			size_t i = usage - SPU_GENERAL_PARAM;

	mov	eax, DWORD PTR _usage$[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _i$144861[ebp], eax

; 321  : 			assert(i<ARRAY_ELEMENTS(m_MtlHandles));
; 322  : 			h = m_MtlHandles[i];

	mov	ecx, DWORD PTR _i$144861[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+252]
	mov	DWORD PTR _h$[ebp], eax
$LN12@setConstan@2:

; 323  : 		}
; 324  : 
; 325  : 		if(h == NULL) return;

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN11@setConstan@2
	jmp	$LN14@setConstan@2
$LN11@setConstan@2:

; 326  : 
; 327  : 		if(m_Type == COMPILED_EFFECT)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN10@setConstan@2

; 328  : 		{
; 329  : 			if (m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN9@setConstan@2

; 330  : 				m_pEffect->SetValue(h, pdata, (UINT)len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+80]
	call	edx
$LN9@setConstan@2:

; 331  : 		}

	jmp	$LN14@setConstan@2
$LN10@setConstan@2:

; 332  : 		else if(m_Type == COMPILED_VS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 1
	jne	$LN7@setConstan@2

; 333  : 		{
; 334  : 			if(usage == SPU_LIGHTDATA) //!!!hack, 对这种结构数组以后再看怎么处理

	cmp	DWORD PTR _usage$[ebp], 5
	jne	SHORT $LN6@setConstan@2

; 335  : 			{
; 336  : 				D3DXCONSTANT_DESC cdesc;
; 337  : 				UINT count;
; 338  : 				if (m_pConst)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN5@setConstan@2

; 339  : 				{
; 340  : 					m_pConst->GetConstantDesc(h, &cdesc, &count);

	lea	edx, DWORD PTR _count$144871[ebp]
	push	edx
	lea	eax, DWORD PTR _cdesc$144870[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+24]
	call	ecx

; 341  : 
; 342  : 					m_pDevice->SetVertexShaderConstantF(cdesc.RegisterIndex, (const float *)pdata, (UINT)len/16);

	mov	edx, DWORD PTR _len$[ebp]
	shr	edx, 4
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cdesc$144870[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+376]
	call	ecx
$LN5@setConstan@2:

; 343  : 				}
; 344  : 			}
; 345  : 			else

	jmp	SHORT $LN4@setConstan@2
$LN6@setConstan@2:

; 346  : 			{
; 347  : 				if (m_pConst)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN4@setConstan@2

; 348  : 					m_pConst->SetValue(m_pDevice, h, pdata, (UINT)len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
$LN4@setConstan@2:

; 349  : 			}
; 350  : 		}
; 351  : 		else

	jmp	SHORT $LN14@setConstan@2
$LN7@setConstan@2:

; 352  : 		{
; 353  : 			if (m_pConst)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN14@setConstan@2

; 354  : 				m_pConst->SetValue(m_pDevice, h, pdata, (UINT)len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
$LN14@setConstan@2:

; 355  : 		}
; 356  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ENDP ; Ogre::CompiledShader::setConstant
_TEXT	ENDS
PUBLIC	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$144889 = -8						; size = 4
_h$ = -4						; size = 4
_usage$ = 8						; size = 4
_htech$ = 12						; size = 4
?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z PROC ; Ogre::CompiledShader::hasConstant
; _this$ = ecx

; 359  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 		D3DXHANDLE h;
; 361  : 		if(usage < SPU_ENV_PARAM_END) h = m_EnvHandles[usage];

	cmp	DWORD PTR _usage$[ebp], 48		; 00000030H
	jge	SHORT $LN7@hasConstan
	mov	eax, DWORD PTR _usage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+60]
	mov	DWORD PTR _h$[ebp], edx

; 362  : 		else

	jmp	SHORT $LN6@hasConstan
$LN7@hasConstan:

; 363  : 		{
; 364  : 			size_t i = usage - SPU_GENERAL_PARAM;

	mov	eax, DWORD PTR _usage$[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _i$144889[ebp], eax

; 365  : 			assert(i<ARRAY_ELEMENTS(m_MtlHandles));
; 366  : 			h = m_MtlHandles[i];

	mov	ecx, DWORD PTR _i$144889[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+252]
	mov	DWORD PTR _h$[ebp], eax
$LN6@hasConstan:

; 367  : 		}
; 368  : 
; 369  : 		if(h != NULL)

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN5@hasConstan

; 370  : 		{
; 371  : 			if(m_Type == COMPILED_EFFECT)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN4@hasConstan

; 372  : 			{
; 373  : 				if (m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN3@hasConstan

; 374  : 					return m_pEffect->IsParameterUsed(h, htech)==TRUE;

	mov	eax, DWORD PTR _htech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+248]
	call	ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN8@hasConstan
$LN3@hasConstan:

; 375  : 			}

	jmp	SHORT $LN2@hasConstan
$LN4@hasConstan:

; 376  : 			else return true;

	mov	al, 1
	jmp	SHORT $LN8@hasConstan
$LN2@hasConstan:
	jmp	SHORT $LN8@hasConstan
$LN5@hasConstan:

; 377  : 		}
; 378  : 		else return false;

	xor	al, al
$LN8@hasConstan:

; 379  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ENDP ; Ogre::CompiledShader::hasConstant
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEXABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::push_back
PUBLIC	??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator[]
PUBLIC	?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize
PUBLIC	??0TechniqueDesc@Ogre@@QAE@XZ			; Ogre::TechniqueDesc::TechniqueDesc
PUBLIC	?cacheTechnique@CompiledShader@Ogre@@QAEXXZ	; Ogre::CompiledShader::cacheTechnique
EXTRN	_strcpy:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ$0
__ehfuncinfo$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv93 = -72						; size = 4
_this$ = -68						; size = 4
$T157805 = -64						; size = 4
$T157804 = -60						; size = 4
_psname$144950 = -56					; size = 4
_hpass$144944 = -52					; size = 4
_passdesc$144943 = -48					; size = 4
_vsname$144945 = -44					; size = 4
_ipass$144939 = -40					; size = 4
_techdesc$144937 = -36					; size = 12
_ptech$144930 = -24					; size = 4
_i$144923 = -20						; size = 4
_htech$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?cacheTechnique@CompiledShader@Ogre@@QAEXXZ PROC	; Ogre::CompiledShader::cacheTechnique
; _this$ = ecx

; 402  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		if(m_Type != COMPILED_EFFECT) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN15@cacheTechn
	jmp	$LN16@cacheTechn
$LN15@cacheTechn:

; 404  : 
; 405  : 		D3DXHANDLE htech = NULL;

	mov	DWORD PTR _htech$[ebp], 0

; 406  : 		for( int i=0; i<16; i++ )

	mov	DWORD PTR _i$144923[ebp], 0
	jmp	SHORT $LN14@cacheTechn
$LN13@cacheTechn:
	mov	ecx, DWORD PTR _i$144923[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$144923[ebp], ecx
$LN14@cacheTechn:
	cmp	DWORD PTR _i$144923[ebp], 16		; 00000010H
	jge	$LN16@cacheTechn

; 407  : 		{
; 408  : 			if (!m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN11@cacheTechn

; 409  : 				return;

	jmp	$LN16@cacheTechn
$LN11@cacheTechn:

; 410  : 
; 411  : 			if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN10@cacheTechn

; 412  : 				htech = m_pEffect->GetTechnique(i);

	mov	ecx, DWORD PTR _i$144923[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+48]
	call	ecx
	mov	DWORD PTR _htech$[ebp], eax
$LN10@cacheTechn:

; 413  : 			if( htech == NULL ) return;

	cmp	DWORD PTR _htech$[ebp], 0
	jne	SHORT $LN9@cacheTechn
	jmp	$LN16@cacheTechn
$LN9@cacheTechn:

; 414  : 
; 415  : 		//	if( SUCCEEDED(m_pEffect->ValidateTechnique(htech)) )//!!!need to check vs, ps_2_0 此函数很耗！！相当耗！！！
; 416  : 			{
; 417  : 				TechniqueDesc *ptech = new TechniqueDesc;

	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T157805[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T157805[ebp], 0
	je	SHORT $LN18@cacheTechn
	mov	ecx, DWORD PTR $T157805[ebp]
	call	??0TechniqueDesc@Ogre@@QAE@XZ
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN19@cacheTechn
$LN18@cacheTechn:
	mov	DWORD PTR tv93[ebp], 0
$LN19@cacheTechn:
	mov	edx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T157804[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T157804[ebp]
	mov	DWORD PTR _ptech$144930[ebp], eax

; 418  : 				ptech->htech = htech;

	mov	ecx, DWORD PTR _ptech$144930[ebp]
	mov	edx, DWORD PTR _htech$[ebp]
	mov	DWORD PTR [ecx], edx

; 419  : 				ptech->lod = GetTechniqueAnnotation(m_pEffect, htech, "lod");

	push	OFFSET $SG144935
	mov	eax, DWORD PTR _htech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?GetTechniqueAnnotation@Ogre@@YAHPAUID3DXEffect@@PBD1@Z ; Ogre::GetTechniqueAnnotation
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _ptech$144930[ebp]
	mov	DWORD PTR [ecx+4], eax

; 420  : 				ptech->renderusage = GetTechniqueAnnotation(m_pEffect, htech, "usage");

	push	OFFSET $SG144936
	mov	edx, DWORD PTR _htech$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?GetTechniqueAnnotation@Ogre@@YAHPAUID3DXEffect@@PBD1@Z ; Ogre::GetTechniqueAnnotation
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ptech$144930[ebp]
	mov	DWORD PTR [edx+8], eax

; 421  : 
; 422  : 				D3DXTECHNIQUE_DESC techdesc;
; 423  : 				if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN8@cacheTechn

; 424  : 					m_pEffect->GetTechniqueDesc(htech, &techdesc);

	lea	ecx, DWORD PTR _techdesc$144937[ebp]
	push	ecx
	mov	edx, DWORD PTR _htech$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+20]
	call	edx
$LN8@cacheTechn:

; 425  : 				ptech->m_Pass.resize(techdesc.Passes);

	mov	eax, DWORD PTR _techdesc$144937[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _ptech$144930[ebp]
	add	ecx, 12					; 0000000cH
	call	?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize

; 426  : 
; 427  : 				for(UINT ipass=0; ipass<techdesc.Passes; ipass++)

	mov	DWORD PTR _ipass$144939[ebp], 0
	jmp	SHORT $LN7@cacheTechn
$LN6@cacheTechn:
	mov	ecx, DWORD PTR _ipass$144939[ebp]
	add	ecx, 1
	mov	DWORD PTR _ipass$144939[ebp], ecx
$LN7@cacheTechn:
	mov	edx, DWORD PTR _ipass$144939[ebp]
	cmp	edx, DWORD PTR _techdesc$144937[ebp+4]
	jae	$LN5@cacheTechn

; 428  : 				{
; 429  : 					PassDesc &passdesc = ptech->m_Pass[ipass];

	mov	eax, DWORD PTR _ipass$144939[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptech$144930[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator[]
	mov	DWORD PTR _passdesc$144943[ebp], eax

; 430  : 					D3DXHANDLE hpass = m_pEffect->GetPass(htech, ipass);

	mov	ecx, DWORD PTR _ipass$144939[ebp]
	push	ecx
	mov	edx, DWORD PTR _htech$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+56]
	call	edx
	mov	DWORD PTR _hpass$144944[ebp], eax

; 431  : 					const char *vsname = GetAnnotationStr(m_pEffect, hpass, "vs");

	push	OFFSET $SG144946
	mov	eax, DWORD PTR _hpass$144944[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?GetAnnotationStr@Ogre@@YAPBDPAUID3DXEffect@@PBD1@Z ; Ogre::GetAnnotationStr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _vsname$144945[ebp], eax

; 432  : 					if(vsname)

	cmp	DWORD PTR _vsname$144945[ebp], 0
	je	SHORT $LN4@cacheTechn

; 433  : 					{
; 434  : 						assert(strlen(vsname) < sizeof(passdesc.vs));
; 435  : 						strcpy(passdesc.vs, vsname); //如果为空，表示vertexshader = NULL，使用固定管线

	mov	eax, DWORD PTR _vsname$144945[ebp]
	push	eax
	mov	ecx, DWORD PTR _passdesc$144943[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 436  : 					}
; 437  : 					else

	jmp	SHORT $LN3@cacheTechn
$LN4@cacheTechn:

; 438  : 					{
; 439  : 						passdesc.vs[0] = 1; //表示使用effect里面定义的vs, ps

	mov	edx, DWORD PTR _passdesc$144943[ebp]
	mov	BYTE PTR [edx], 1

; 440  : 						passdesc.vs[1] = 0;

	mov	eax, DWORD PTR _passdesc$144943[ebp]
	mov	BYTE PTR [eax+1], 0
$LN3@cacheTechn:

; 441  : 					}
; 442  : 
; 443  : 					const char *psname = GetAnnotationStr(m_pEffect, hpass, "ps");

	push	OFFSET $SG144951
	mov	ecx, DWORD PTR _hpass$144944[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?GetAnnotationStr@Ogre@@YAPBDPAUID3DXEffect@@PBD1@Z ; Ogre::GetAnnotationStr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _psname$144950[ebp], eax

; 444  : 					if(psname)

	cmp	DWORD PTR _psname$144950[ebp], 0
	je	SHORT $LN2@cacheTechn

; 445  : 					{
; 446  : 						assert(strlen(psname) < sizeof(passdesc.ps));
; 447  : 						strcpy(passdesc.ps, psname);

	mov	ecx, DWORD PTR _psname$144950[ebp]
	push	ecx
	mov	edx, DWORD PTR _passdesc$144943[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_strcpy
	add	esp, 8

; 448  : 					}
; 449  : 					else

	jmp	SHORT $LN1@cacheTechn
$LN2@cacheTechn:

; 450  : 					{
; 451  : 						passdesc.ps[0] = 1;//表示使用effect里面定义的vs, ps

	mov	eax, DWORD PTR _passdesc$144943[ebp]
	mov	BYTE PTR [eax+16], 1

; 452  : 						passdesc.ps[1] = 0;

	mov	ecx, DWORD PTR _passdesc$144943[ebp]
	mov	BYTE PTR [ecx+17], 0
$LN1@cacheTechn:

; 453  : 					}
; 454  : 				}

	jmp	$LN6@cacheTechn
$LN5@cacheTechn:

; 455  : 
; 456  : 				m_TechDesc.push_back(ptech);

	lea	edx, DWORD PTR _ptech$144930[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 316				; 0000013cH
	call	?push_back@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEXABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::push_back
	jmp	$LN13@cacheTechn
$LN16@cacheTechn:

; 457  : 			}
; 458  : 		}
; 459  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ$0:
	mov	eax, DWORD PTR $T157805[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?cacheTechnique@CompiledShader@Ogre@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?cacheTechnique@CompiledShader@Ogre@@QAEXXZ ENDP	; Ogre::CompiledShader::cacheTechnique
; Function compile flags: /Odtp
_TEXT	SEGMENT
_i$ = -8						; size = 4
_h$ = -4						; size = 4
_peffect$ = 8						; size = 4
_htech$ = 12						; size = 4
_pname$ = 16						; size = 4
?GetTechniqueAnnotation@Ogre@@YAHPAUID3DXEffect@@PBD1@Z PROC ; Ogre::GetTechniqueAnnotation

; 382  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 383  : 		D3DXHANDLE h = peffect->GetAnnotationByName(htech, pname);

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _htech$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+76]
	call	edx
	mov	DWORD PTR _h$[ebp], eax

; 384  : 		if(h == NULL) return 0;

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN3@GetTechniq
	xor	eax, eax
	jmp	SHORT $LN4@GetTechniq
$LN3@GetTechniq:

; 385  : 
; 386  : 		int i;
; 387  : 		if(SUCCEEDED(peffect->GetInt(h, &i))) return i;

	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+108]
	call	edx
	test	eax, eax
	jl	SHORT $LN2@GetTechniq
	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $LN4@GetTechniq
	jmp	SHORT $LN4@GetTechniq
$LN2@GetTechniq:

; 388  : 		else return 0;

	xor	eax, eax
$LN4@GetTechniq:

; 389  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechniqueAnnotation@Ogre@@YAHPAUID3DXEffect@@PBD1@Z ENDP ; Ogre::GetTechniqueAnnotation
; Function compile flags: /Odtp
_pstr$ = -8						; size = 4
_h$ = -4						; size = 4
_peffect$ = 8						; size = 4
_htech$ = 12						; size = 4
_pname$ = 16						; size = 4
?GetAnnotationStr@Ogre@@YAPBDPAUID3DXEffect@@PBD1@Z PROC ; Ogre::GetAnnotationStr

; 392  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 393  : 		D3DXHANDLE h = peffect->GetAnnotationByName(htech, pname);

	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _htech$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+76]
	call	edx
	mov	DWORD PTR _h$[ebp], eax

; 394  : 		if(h == NULL) return NULL;

	cmp	DWORD PTR _h$[ebp], 0
	jne	SHORT $LN3@GetAnnotat
	xor	eax, eax
	jmp	SHORT $LN4@GetAnnotat
$LN3@GetAnnotat:

; 395  : 
; 396  : 		const char *pstr = NULL;

	mov	DWORD PTR _pstr$[ebp], 0

; 397  : 		if(SUCCEEDED(peffect->GetString(h, &pstr))) return pstr;

	lea	eax, DWORD PTR _pstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+204]
	call	edx
	test	eax, eax
	jl	SHORT $LN2@GetAnnotat
	mov	eax, DWORD PTR _pstr$[ebp]
	jmp	SHORT $LN4@GetAnnotat
	jmp	SHORT $LN4@GetAnnotat
$LN2@GetAnnotat:

; 398  : 		else return NULL;

	xor	eax, eax
$LN4@GetAnnotat:

; 399  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAnnotationStr@Ogre@@YAPBDPAUID3DXEffect@@PBD1@Z ENDP ; Ogre::GetAnnotationStr
_TEXT	ENDS
PUBLIC	??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TechniqueDesc@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TechniqueDesc@Ogre@@QAE@XZ$0
__ehfuncinfo$??0TechniqueDesc@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0TechniqueDesc@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TechniqueDesc@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0TechniqueDesc@Ogre@@QAE@XZ PROC			; Ogre::TechniqueDesc::TechniqueDesc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TechniqueDesc@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TechniqueDesc@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
__ehhandler$??0TechniqueDesc@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TechniqueDesc@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TechniqueDesc@Ogre@@QAE@XZ ENDP			; Ogre::TechniqueDesc::TechniqueDesc
PUBLIC	?paramUsage2Handle@CompiledShader@Ogre@@QAEPBDW4ShaderParamUsage@2@@Z ; Ogre::CompiledShader::paramUsage2Handle
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$144964 = -8						; size = 4
_h$ = -4						; size = 4
_usage$ = 8						; size = 4
?paramUsage2Handle@CompiledShader@Ogre@@QAEPBDW4ShaderParamUsage@2@@Z PROC ; Ogre::CompiledShader::paramUsage2Handle
; _this$ = ecx

; 462  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		D3DXHANDLE h;
; 464  : 		if(usage < SPU_ENV_PARAM_END) h = m_EnvHandles[usage];

	cmp	DWORD PTR _usage$[ebp], 48		; 00000030H
	jge	SHORT $LN2@paramUsage
	mov	eax, DWORD PTR _usage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+60]
	mov	DWORD PTR _h$[ebp], edx

; 465  : 		else

	jmp	SHORT $LN1@paramUsage
$LN2@paramUsage:

; 466  : 		{
; 467  : 			size_t i = usage - SPU_GENERAL_PARAM;

	mov	eax, DWORD PTR _usage$[ebp]
	sub	eax, 1000				; 000003e8H
	mov	DWORD PTR _i$144964[ebp], eax

; 468  : 			assert(i<ARRAY_ELEMENTS(m_MtlHandles));
; 469  : 			h = m_MtlHandles[i];

	mov	ecx, DWORD PTR _i$144964[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+252]
	mov	DWORD PTR _h$[ebp], eax
$LN1@paramUsage:

; 470  : 		}
; 471  : 
; 472  : 		return h;

	mov	eax, DWORD PTR _h$[ebp]

; 473  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?paramUsage2Handle@CompiledShader@Ogre@@QAEPBDW4ShaderParamUsage@2@@Z ENDP ; Ogre::CompiledShader::paramUsage2Handle
_TEXT	ENDS
PUBLIC	?onLostDevice@CompiledShader@Ogre@@QAEXXZ	; Ogre::CompiledShader::onLostDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onLostDevice@CompiledShader@Ogre@@QAEXXZ PROC		; Ogre::CompiledShader::onLostDevice
; _this$ = ecx

; 476  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if(m_Type == COMPILED_EFFECT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN7@onLostDevi

; 478  : 		{
; 479  : 			if (m_pEffect)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN6@onLostDevi

; 480  : 				m_pEffect->OnLostDevice();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+276]
	call	ecx
$LN6@onLostDevi:

; 481  : 		}

	jmp	SHORT $LN8@onLostDevi
$LN7@onLostDevi:

; 482  : 		else if(m_Type == COMPILED_VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN4@onLostDevi

; 483  : 		{
; 484  : 			m_bCreated = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+364], 0

; 485  : 			SAFE_RELEASE(m_pVS);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $LN3@onLostDevi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
$LN3@onLostDevi:

; 486  : 		}
; 487  : 		else

	jmp	SHORT $LN8@onLostDevi
$LN4@onLostDevi:

; 488  : 		{
; 489  : 			m_bCreated = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+364], 0

; 490  : 			SAFE_RELEASE(m_pPS);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN8@onLostDevi
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$LN8@onLostDevi:

; 491  : 		}
; 492  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@CompiledShader@Ogre@@QAEXXZ ENDP		; Ogre::CompiledShader::onLostDevice
_TEXT	ENDS
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	?onResetDevice@CompiledShader@Ogre@@QAE_NXZ	; Ogre::CompiledShader::onResetDevice
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_D3DXGetShaderConstantTable@8:PROC
EXTRN	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z:PROC ; Ogre::D3D9RenderSystem::createPixelShader
EXTRN	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z:PROC ; Ogre::D3D9RenderSystem::createVertexShader
EXTRN	_memcpy:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T157828 = -24						; size = 4
$T157827 = -20						; size = 4
_buffer$ = -16						; size = 4
_bufferSize$ = -8					; size = 4
_prs$ = -4						; size = 4
?onResetDevice@CompiledShader@Ogre@@QAE_NXZ PROC	; Ogre::CompiledShader::onResetDevice
; _this$ = ecx

; 495  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 		D3D9RenderSystem *prs = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr());

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	mov	DWORD PTR _prs$[ebp], eax

; 497  : 
; 498  : 		HRESULT hr;
; 499  : 
; 500  : 		UINT bufferSize = m_CompiledBuf.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	DWORD PTR _bufferSize$[ebp], eax

; 501  : 		char *buffer = new char[bufferSize];

	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T157827[ebp], eax
	mov	ecx, DWORD PTR $T157827[ebp]
	mov	DWORD PTR _buffer$[ebp], ecx

; 502  : 		memcpy(buffer, &m_CompiledBuf[0], bufferSize*sizeof(char));

	mov	edx, DWORD PTR _bufferSize$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	push	eax
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 503  : 
; 504  : 		if (m_Type == COMPILED_EFFECT)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN7@onResetDev

; 505  : 		{
; 506  : 			if (m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN6@onResetDev

; 507  : 				return SUCCEEDED(m_pEffect->OnResetDevice());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+280]
	call	edx
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	mov	al, cl
	jmp	$LN8@onResetDev
$LN6@onResetDev:

; 508  : 		}

	jmp	SHORT $LN5@onResetDev
$LN7@onResetDev:

; 509  : 		else if (m_Type == COMPILED_VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN4@onResetDev

; 510  : 		{
; 511  : 			m_bCreated = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+364], 1

; 512  : 			m_pVS = prs->createVertexShader(buffer, bufferSize);

	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createVertexShader
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 513  : 		}
; 514  : 		else

	jmp	SHORT $LN5@onResetDev
$LN4@onResetDev:

; 515  : 		{
; 516  : 			m_bCreated = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+364], 1

; 517  : 			m_pPS = prs->createPixelShader(buffer, bufferSize);

	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createPixelShader
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN5@onResetDev:

; 518  : 		}
; 519  : 
; 520  : 		if (m_pVS || m_pPS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN1@onResetDev
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN2@onResetDev
$LN1@onResetDev:

; 521  : 		{
; 522  : 			D3DXGetShaderConstantTable((const DWORD *)buffer, &m_pConst);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_D3DXGetShaderConstantTable@8
$LN2@onResetDev:

; 523  : 			assert(m_pConst);
; 524  : 		}
; 525  : 
; 526  : 		delete [] buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR $T157828[ebp], ecx
	mov	edx, DWORD PTR $T157828[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 527  : 
; 528  : 		cacheTechnique();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?cacheTechnique@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheTechnique

; 529  : 		cacheParamHandle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheParamHandle

; 530  : 
; 531  : 		return true;

	mov	al, 1
$LN8@onResetDev:

; 532  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@CompiledShader@Ogre@@QAE_NXZ ENDP	; Ogre::CompiledShader::onResetDevice
_TEXT	ENDS
PUBLIC	?create@CompiledShader@Ogre@@QAE_NXZ		; Ogre::CompiledShader::create
EXTRN	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAXI@Z:PROC ; Ogre::D3D9RenderSystem::createD3DXEffect
EXTRN	__imp__timeGetTime@0:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T157831 = -36						; size = 4
$T157830 = -32						; size = 4
_buffer$ = -28						; size = 4
_tickParam$ = -24					; size = 4
_bufferSize$ = -20					; size = 4
_tick$ = -16						; size = 4
_tickCacheTechnique$ = -12				; size = 4
_prs$ = -8						; size = 4
_tickCacheParamHandleTime$ = -4				; size = 4
?create@CompiledShader@Ogre@@QAE_NXZ PROC		; Ogre::CompiledShader::create
; _this$ = ecx

; 535  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 536  : 		if (m_bCreated)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+364]
	test	ecx, ecx
	je	SHORT $LN7@create

; 537  : 			return false;

	xor	al, al
	jmp	$LN8@create
$LN7@create:

; 538  : 
; 539  : 		D3D9RenderSystem *prs = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr());

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	mov	DWORD PTR _prs$[ebp], eax

; 540  : 
; 541  : 		UINT bufferSize = m_CompiledBuf.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	DWORD PTR _bufferSize$[ebp], eax

; 542  : 		char *buffer = new char[bufferSize];

	mov	edx, DWORD PTR _bufferSize$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T157830[ebp], eax
	mov	eax, DWORD PTR $T157830[ebp]
	mov	DWORD PTR _buffer$[ebp], eax

; 543  : 		memcpy(buffer, &m_CompiledBuf[0], bufferSize*sizeof(char));

	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	push	eax
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 544  : 
; 545  : 		uint tick = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR _tick$[ebp], eax

; 546  : 		if (m_Type == COMPILED_EFFECT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@create

; 547  : 		{			
; 548  : 			m_pEffect = prs->createD3DXEffect(buffer, bufferSize);

	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAXI@Z ; Ogre::D3D9RenderSystem::createD3DXEffect
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 549  : 			ms_EffectCompileTime += timeGetTime() - tick;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tick$[ebp]
	add	eax, DWORD PTR ?ms_EffectCompileTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_EffectCompileTime
	mov	DWORD PTR ?ms_EffectCompileTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_EffectCompileTime
	jmp	SHORT $LN5@create
$LN6@create:

; 550  : 		}
; 551  : 		else if (m_Type == COMPILED_VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 1
	jne	SHORT $LN4@create

; 552  : 		{
; 553  : 			m_pVS = prs->createVertexShader(buffer, bufferSize);

	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createVertexShader
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], eax

; 554  : 			ms_VSCompileTime += timeGetTime() - tick;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tick$[ebp]
	add	eax, DWORD PTR ?ms_VSCompileTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_VSCompileTime
	mov	DWORD PTR ?ms_VSCompileTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_VSCompileTime

; 555  : 		}
; 556  : 		else

	jmp	SHORT $LN5@create
$LN4@create:

; 557  : 		{
; 558  : 			m_pPS = prs->createPixelShader(buffer, bufferSize);

	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createPixelShader
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax

; 559  : 			ms_PSCompileTime += timeGetTime() - tick;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tick$[ebp]
	add	eax, DWORD PTR ?ms_PSCompileTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_PSCompileTime
	mov	DWORD PTR ?ms_PSCompileTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_PSCompileTime
$LN5@create:

; 560  : 		}
; 561  : 
; 562  : 		assert(m_pEffect || m_pVS || m_pPS);
; 563  : 
; 564  : 		uint tickParam = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR _tickParam$[ebp], eax

; 565  : 
; 566  : 		if (m_pVS || m_pPS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN1@create
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN2@create
$LN1@create:

; 567  : 		{
; 568  : 			D3DXGetShaderConstantTable((const DWORD *)buffer, &m_pConst);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_D3DXGetShaderConstantTable@8
$LN2@create:

; 569  : 			assert(m_pConst);
; 570  : 		}
; 571  : 		
; 572  : 		delete [] buffer;

	mov	ecx, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR $T157831[ebp], ecx
	mov	edx, DWORD PTR $T157831[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 573  : 
; 574  : 		uint tickCacheTechnique = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR _tickCacheTechnique$[ebp], eax

; 575  : 		cacheTechnique();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?cacheTechnique@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheTechnique

; 576  : 		ms_CacheTechniqueTime += timeGetTime() - tickCacheTechnique;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tickCacheTechnique$[ebp]
	add	eax, DWORD PTR ?ms_CacheTechniqueTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_CacheTechniqueTime
	mov	DWORD PTR ?ms_CacheTechniqueTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_CacheTechniqueTime

; 577  : 
; 578  : 		uint tickCacheParamHandleTime = timeGetTime();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR _tickCacheParamHandleTime$[ebp], eax

; 579  : 		cacheParamHandle();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheParamHandle

; 580  : 		ms_CacheParamHandleTime += timeGetTime() - tickCacheParamHandleTime;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tickCacheParamHandleTime$[ebp]
	add	eax, DWORD PTR ?ms_CacheParamHandleTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_CacheParamHandleTime
	mov	DWORD PTR ?ms_CacheParamHandleTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_CacheParamHandleTime

; 581  : 
; 582  : 		m_bCreated = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+364], 1

; 583  : 
; 584  : 		ms_ProcessParamsTime += timeGetTime() - tickParam;

	call	DWORD PTR __imp__timeGetTime@0
	sub	eax, DWORD PTR _tickParam$[ebp]
	add	eax, DWORD PTR ?ms_ProcessParamsTime@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_ProcessParamsTime
	mov	DWORD PTR ?ms_ProcessParamsTime@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_ProcessParamsTime

; 585  : 
; 586  : 		return true;

	mov	al, 1
$LN8@create:

; 587  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?create@CompiledShader@Ogre@@QAE_NXZ ENDP		; Ogre::CompiledShader::create
_TEXT	ENDS
PUBLIC	??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
PUBLIC	??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
PUBLIC	??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z ; Ogre::CompiledShaderGroup::CompiledShaderGroup
EXTRN	__imp_??1FixedString@Ogre@@QAE@XZ:PROC
EXTRN	__imp_??0FixedString@Ogre@@QAE@ABV01@@Z:PROC
xdata$x	SEGMENT
__unwindtable$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$2
__ehfuncinfo$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_pmtltemplate$ = 12					; size = 4
_path$ = 16						; size = 4
??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z PROC ; Ogre::CompiledShaderGroup::CompiledShaderGroup
; _this$ = ecx

; 590  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pmtltemplate$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _path$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??0FixedString@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 591  : 		m_bCreatedAll = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+68], 0

; 592  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1FixedString@Ogre@@QAE@XZ
__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
__unwindfunclet$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
__ehhandler$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CompiledShaderGroup@Ogre@@QAE@W4COMPILED_TYPE@1@PAVD3DMaterialTemplate@1@ABVFixedString@1@@Z ENDP ; Ogre::CompiledShaderGroup::CompiledShaderGroup
PUBLIC	??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ PROC ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
__ehhandler$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
PUBLIC	??_GCompiledShader@Ogre@@QAEPAXI@Z		; Ogre::CompiledShader::`scalar deleting destructor'
PUBLIC	??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
PUBLIC	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
PUBLIC	??1CompiledShaderGroup@Ogre@@QAE@XZ		; Ogre::CompiledShaderGroup::~CompiledShaderGroup
xdata$x	SEGMENT
__unwindtable$??1CompiledShaderGroup@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$2
__ehfuncinfo$??1CompiledShaderGroup@Ogre@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CompiledShaderGroup@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv83 = -32						; size = 4
_this$ = -28						; size = 4
$T157851 = -24						; size = 4
$T157850 = -20						; size = 4
_i$145034 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CompiledShaderGroup@Ogre@@QAE@XZ PROC		; Ogre::CompiledShaderGroup::~CompiledShaderGroup
; _this$ = ecx

; 595  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CompiledShaderGroup@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 596  : 		for(size_t i=0; i<m_Shaders.size(); i++)

	mov	DWORD PTR _i$145034[ebp], 0
	jmp	SHORT $LN3@CompiledSh@3
$LN2@CompiledSh@3:
	mov	eax, DWORD PTR _i$145034[ebp]
	add	eax, 1
	mov	DWORD PTR _i$145034[ebp], eax
$LN3@CompiledSh@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	cmp	DWORD PTR _i$145034[ebp], eax
	jae	SHORT $LN4@CompiledSh@3

; 597  : 		{
; 598  : 			delete m_Shaders[i];

	mov	ecx, DWORD PTR _i$145034[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T157851[ebp], edx
	mov	eax, DWORD PTR $T157851[ebp]
	mov	DWORD PTR $T157850[ebp], eax
	cmp	DWORD PTR $T157850[ebp], 0
	je	SHORT $LN6@CompiledSh@3
	push	1
	mov	ecx, DWORD PTR $T157850[ebp]
	call	??_GCompiledShader@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN7@CompiledSh@3
$LN6@CompiledSh@3:
	mov	DWORD PTR tv83[ebp], 0
$LN7@CompiledSh@3:

; 599  : 		}

	jmp	SHORT $LN2@CompiledSh@3
$LN4@CompiledSh@3:

; 600  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??1FixedString@Ogre@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1FixedString@Ogre@@QAE@XZ
__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
__unwindfunclet$??1CompiledShaderGroup@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
__ehhandler$??1CompiledShaderGroup@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CompiledShaderGroup@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CompiledShaderGroup@Ogre@@QAE@XZ ENDP		; Ogre::CompiledShaderGroup::~CompiledShaderGroup
; Function compile flags: /Odtp
;	COMDAT ??_GCompiledShader@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCompiledShader@Ogre@@QAEPAXI@Z PROC			; Ogre::CompiledShader::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CompiledShader@Ogre@@QAE@XZ		; Ogre::CompiledShader::~CompiledShader
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCompiledShader@Ogre@@QAEPAXI@Z ENDP			; Ogre::CompiledShader::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?onLostDevice@CompiledShaderGroup@Ogre@@QAEXXZ	; Ogre::CompiledShaderGroup::onLostDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$145047 = -4						; size = 4
?onLostDevice@CompiledShaderGroup@Ogre@@QAEXXZ PROC	; Ogre::CompiledShaderGroup::onLostDevice
; _this$ = ecx

; 603  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 		for(size_t i=0; i<m_Shaders.size(); i++)

	mov	DWORD PTR _i$145047[ebp], 0
	jmp	SHORT $LN3@onLostDevi@2
$LN2@onLostDevi@2:
	mov	eax, DWORD PTR _i$145047[ebp]
	add	eax, 1
	mov	DWORD PTR _i$145047[ebp], eax
$LN3@onLostDevi@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	cmp	DWORD PTR _i$145047[ebp], eax
	jae	SHORT $LN4@onLostDevi@2

; 605  : 		{
; 606  : 			m_Shaders[i]->onLostDevice();

	mov	ecx, DWORD PTR _i$145047[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?onLostDevice@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::onLostDevice
	jmp	SHORT $LN2@onLostDevi@2
$LN4@onLostDevi@2:

; 607  : 		}
; 608  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@CompiledShaderGroup@Ogre@@QAEXXZ ENDP	; Ogre::CompiledShaderGroup::onLostDevice
_TEXT	ENDS
PUBLIC	?onResetDevice@CompiledShaderGroup@Ogre@@QAE_NXZ ; Ogre::CompiledShaderGroup::onResetDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$145054 = -4						; size = 4
?onResetDevice@CompiledShaderGroup@Ogre@@QAE_NXZ PROC	; Ogre::CompiledShaderGroup::onResetDevice
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		for(size_t i=0; i<m_Shaders.size(); i++)

	mov	DWORD PTR _i$145054[ebp], 0
	jmp	SHORT $LN4@onResetDev@2
$LN3@onResetDev@2:
	mov	eax, DWORD PTR _i$145054[ebp]
	add	eax, 1
	mov	DWORD PTR _i$145054[ebp], eax
$LN4@onResetDev@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	cmp	DWORD PTR _i$145054[ebp], eax
	jae	SHORT $LN2@onResetDev@2

; 613  : 		{
; 614  : 			if(!m_Shaders[i]->onResetDevice()) return false;

	mov	ecx, DWORD PTR _i$145054[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?onResetDevice@CompiledShader@Ogre@@QAE_NXZ ; Ogre::CompiledShader::onResetDevice
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@onResetDev@2
	xor	al, al
	jmp	SHORT $LN5@onResetDev@2
$LN1@onResetDev@2:

; 615  : 		}

	jmp	SHORT $LN3@onResetDev@2
$LN2@onResetDev@2:

; 616  : 		return true;

	mov	al, 1
$LN5@onResetDev@2:

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@CompiledShaderGroup@Ogre@@QAE_NXZ ENDP	; Ogre::CompiledShaderGroup::onResetDevice
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::find
PUBLIC	??0ShaderEnvKey@Ogre@@QAE@XZ			; Ogre::ShaderEnvKey::ShaderEnvKey
PUBLIC	?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::CompiledShaderGroup::createCompiledShader
PUBLIC	??A?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QAEAAUShaderEnv@Ogre@@I@Z ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::operator[]
PUBLIC	?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::size
PUBLIC	?getCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::CompiledShaderGroup::getCompiledShader
EXTRN	__imp_?isCompileShaderEnvKeys@Root@Ogre@@QAE_NXZ:PROC
EXTRN	__imp_?getSingleton@?$Singleton@VRoot@Ogre@@@Ogre@@SAAAVRoot@2@XZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T157866 = -84						; size = 8
_shader$145079 = -76					; size = 4
_env$145077 = -72					; size = 24
_i$145072 = -44						; size = 4
_shaderEnvs$145071 = -40				; size = 4
_isCompileShaderEnvKeys$ = -33				; size = 1
_key$ = -32						; size = 16
_pShaderTemp$ = -12					; size = 4
_iter$ = -8						; size = 8
_env$ = 8						; size = 4
_macros$ = 12						; size = 4
?getCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z PROC ; Ogre::CompiledShaderGroup::getCompiledShader
; _this$ = ecx

; 620  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		bool isCompileShaderEnvKeys = Root::getSingleton().isCompileShaderEnvKeys();

	call	DWORD PTR __imp_?getSingleton@?$Singleton@VRoot@Ogre@@@Ogre@@SAAAVRoot@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?isCompileShaderEnvKeys@Root@Ogre@@QAE_NXZ
	mov	BYTE PTR _isCompileShaderEnvKeys$[ebp], al

; 622  : 
; 623  : 		if (isCompileShaderEnvKeys)

	movzx	eax, BYTE PTR _isCompileShaderEnvKeys$[ebp]
	test	eax, eax
	je	$LN10@getCompile

; 624  : 		{
; 625  : 			if (!m_bCreatedAll)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+68]
	test	edx, edx
	jne	$LN10@getCompile

; 626  : 			{
; 627  : 				std::vector<ShaderEnv> &shaderEnvs = m_pMtlTemplate->m_ShaderEnvs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _shaderEnvs$145071[ebp], ecx

; 628  : 				for (int i=0; i<(int)shaderEnvs.size(); i++)

	mov	DWORD PTR _i$145072[ebp], 0
	jmp	SHORT $LN8@getCompile
$LN7@getCompile:
	mov	edx, DWORD PTR _i$145072[ebp]
	add	edx, 1
	mov	DWORD PTR _i$145072[ebp], edx
$LN8@getCompile:
	mov	ecx, DWORD PTR _shaderEnvs$145071[ebp]
	call	?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::size
	cmp	DWORD PTR _i$145072[ebp], eax
	jge	SHORT $LN6@getCompile

; 629  : 				{
; 630  : 					ShaderEnv env = shaderEnvs[i];

	mov	eax, DWORD PTR _i$145072[ebp]
	push	eax
	mov	ecx, DWORD PTR _shaderEnvs$145071[ebp]
	call	??A?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QAEAAUShaderEnv@Ogre@@I@Z ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _env$145077[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _env$145077[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _env$145077[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _env$145077[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _env$145077[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _env$145077[ebp+20], edx

; 631  : 					if (env.Type == m_Type)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _env$145077[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@getCompile

; 632  : 					{
; 633  : 						CompiledShader *shader = NULL;

	mov	DWORD PTR _shader$145079[ebp], 0

; 634  : 						shader = createCompiledShader(env.key.env, env.key.macros);

	lea	edx, DWORD PTR _env$145077[ebp+16]
	push	edx
	lea	eax, DWORD PTR _env$145077[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::CompiledShaderGroup::createCompiledShader
	mov	DWORD PTR _shader$145079[ebp], eax
$LN5@getCompile:

; 635  : 					}
; 636  : 				}

	jmp	SHORT $LN7@getCompile
$LN6@getCompile:

; 637  : 				m_bCreatedAll = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], 1
$LN10@getCompile:

; 638  : 			}
; 639  : 		}
; 640  : 
; 641  : 		if (env.nlight > CompiledShader::ms_MaxLightNum)

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 7
	cmp	eax, DWORD PTR ?ms_MaxLightNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_MaxLightNum
	jbe	SHORT $LN4@getCompile

; 642  : 			CompiledShader::ms_MaxLightNum = env.nlight;

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 7
	mov	DWORD PTR ?ms_MaxLightNum@CompiledShader@Ogre@@2HA, edx ; Ogre::CompiledShader::ms_MaxLightNum
$LN4@getCompile:

; 643  : 
; 644  : 		if (env.skin_maxinfl > CompiledShader::ms_MaxSkinNum)

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 18					; 00000012H
	and	ecx, 7
	cmp	ecx, DWORD PTR ?ms_MaxSkinNum@CompiledShader@Ogre@@2HA ; Ogre::CompiledShader::ms_MaxSkinNum
	jbe	SHORT $LN3@getCompile

; 645  : 			CompiledShader::ms_MaxSkinNum = env.skin_maxinfl;

	mov	edx, DWORD PTR _env$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 18					; 00000012H
	and	eax, 7
	mov	DWORD PTR ?ms_MaxSkinNum@CompiledShader@Ogre@@2HA, eax ; Ogre::CompiledShader::ms_MaxSkinNum
$LN3@getCompile:

; 646  : 
; 647  : 		assert(sizeof(env)==8 && sizeof(macros)==8);
; 648  : 		ShaderEnvKey key;

	lea	ecx, DWORD PTR _key$[ebp]
	call	??0ShaderEnvKey@Ogre@@QAE@XZ		; Ogre::ShaderEnvKey::ShaderEnvKey

; 649  : 		key.env = env;

	mov	ecx, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _key$[ebp], edx
	mov	DWORD PTR _key$[ebp+4], eax

; 650  : 		key.macros = macros;

	mov	ecx, DWORD PTR _macros$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _key$[ebp+8], edx
	mov	DWORD PTR _key$[ebp+12], eax

; 651  : 
; 652  : 		std::map<ShaderEnvKey, CompiledShader *>::iterator iter = m_MacroShaderMap.find(key);

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?find@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::find

; 653  : 		if(iter != m_MacroShaderMap.end())

	lea	eax, DWORD PTR $T157866[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@getCompile

; 654  : 		{
; 655  : 			if (!iter->second->m_bCreated)

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
	mov	edx, DWORD PTR [eax+16]
	movzx	eax, BYTE PTR [edx+364]
	test	eax, eax
	jne	SHORT $LN1@getCompile

; 656  : 			{
; 657  : 				iter->second->create();

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
	mov	ecx, DWORD PTR [eax+16]
	call	?create@CompiledShader@Ogre@@QAE_NXZ	; Ogre::CompiledShader::create
$LN1@getCompile:

; 658  : 			}
; 659  : 
; 660  : 			return iter->second;	

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN11@getCompile
$LN2@getCompile:

; 661  : 		}
; 662  : 
; 663  : 		//FixedString name = m_pMtlTemplate->getName();
; 664  : 		//if (name == "stdmtl")
; 665  : 		//{
; 666  : 		//	ShaderEnvFlags envFlag = env;
; 667  : 		//	for (int i=0; i<5; i++)
; 668  : 		//	{
; 669  : 		//		envFlag.nlight = i;
; 670  : 
; 671  : 		//		for (int j=0; j<6; j++)
; 672  : 		//		{
; 673  : 		//			envFlag.skin_maxinfl = j;
; 674  : 
; 675  : 		//			CompiledShader *pShaderEnv = createCompiledShader(envFlag, macros);
; 676  : 		//			if (pShaderEnv)
; 677  : 		//				pShaderEnv->m_bAllCreated = true;
; 678  : 		//		}
; 679  : 		//	}
; 680  : 		//}
; 681  : 
; 682  : 		CompiledShader *pShaderTemp = createCompiledShader(env, macros);

	mov	ecx, DWORD PTR _macros$[ebp]
	push	ecx
	mov	edx, DWORD PTR _env$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::CompiledShaderGroup::createCompiledShader
	mov	DWORD PTR _pShaderTemp$[ebp], eax

; 683  : 
; 684  : 		return pShaderTemp;

	mov	eax, DWORD PTR _pShaderTemp$[ebp]
$LN11@getCompile:

; 685  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?getCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ENDP ; Ogre::CompiledShaderGroup::getCompiledShader
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematerialtemplate.h
_TEXT	ENDS
;	COMDAT ??0ShaderEnvKey@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ShaderEnvKey@Ogre@@QAE@XZ PROC			; Ogre::ShaderEnvKey::ShaderEnvKey, COMDAT
; _this$ = ecx

; 23   : 		ShaderEnvKey()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 		{
; 25   : 			keydata[0] = keydata[1] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 26   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ShaderEnvKey@Ogre@@QAE@XZ ENDP			; Ogre::ShaderEnvKey::ShaderEnvKey
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEXABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::push_back
PUBLIC	?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z ; Ogre::CompiledShader::addShaderKey
PUBLIC	??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::operator[]
PUBLIC	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize
PUBLIC	?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ ; Ogre::ShaderMacroMgr::GetMacros
EXTRN	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAUID3DXBuffer@@@Z:PROC ; Ogre::D3D9RenderSystem::createPixelShader
EXTRN	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAUID3DXBuffer@@@Z:PROC ; Ogre::D3D9RenderSystem::createVertexShader
EXTRN	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAUID3DXBuffer@@@Z:PROC ; Ogre::D3D9RenderSystem::createD3DXEffect
EXTRN	_memcmp:PROC
EXTRN	__imp_?hash@StringUtil@Ogre@@SAIPBDIH@Z:PROC
EXTRN	?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z:PROC ; Ogre::D3D9RenderSystem::compileCode
xdata$x	SEGMENT
__unwindtable$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z$1
__ehfuncinfo$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv298 = -148						; size = 4
tv195 = -144						; size = 4
tv77 = -140						; size = 4
_this$ = -136						; size = 4
$T157884 = -132						; size = 4
$T157883 = -128						; size = 4
$T157880 = -124						; size = 4
$T157879 = -120						; size = 4
$T157878 = -116						; size = 4
$T157875 = -112						; size = 4
$T157874 = -108						; size = 4
$T157871 = -104						; size = 4
$T157870 = -100						; size = 4
_bufferEqual$145265 = -93				; size = 1
_ptmp2$145262 = -92					; size = 4
_sizeEqual$145264 = -86					; size = 1
_keyEqual$145263 = -85					; size = 1
_i$145258 = -84						; size = 4
_i$145238 = -80						; size = 4
_bufferSize$ = -76					; size = 4
_ptmp$ = -72						; size = 4
_macromgr$ = -68					; size = 32
_key$ = -36						; size = 16
_prs$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_env$ = 8						; size = 4
_macros$ = 12						; size = 4
?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z PROC ; Ogre::CompiledShaderGroup::createCompiledShader
; _this$ = ecx

; 688  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		ShaderEnvKey key;

	lea	ecx, DWORD PTR _key$[ebp]
	call	??0ShaderEnvKey@Ogre@@QAE@XZ		; Ogre::ShaderEnvKey::ShaderEnvKey

; 690  : 		key.env = env;

	mov	eax, DWORD PTR _env$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _key$[ebp], ecx
	mov	DWORD PTR _key$[ebp+4], edx

; 691  : 		key.macros = macros;

	mov	eax, DWORD PTR _macros$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _key$[ebp+8], ecx
	mov	DWORD PTR _key$[ebp+12], edx

; 692  : 
; 693  : 		CompiledShader *ptmp = new CompiledShader(m_pMtlTemplate, m_Type);

	push	368					; 00000170H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T157871[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T157871[ebp], 0
	je	SHORT $LN21@createComp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR $T157871[ebp]
	call	??0CompiledShader@Ogre@@QAE@PAVD3DMaterialTemplate@1@W4COMPILED_TYPE@1@@Z ; Ogre::CompiledShader::CompiledShader
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN22@createComp
$LN21@createComp:
	mov	DWORD PTR tv77[ebp], 0
$LN22@createComp:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T157870[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T157870[ebp]
	mov	DWORD PTR _ptmp$[ebp], edx

; 694  : 
; 695  : 		D3D9RenderSystem *prs = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr());

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	mov	DWORD PTR _prs$[ebp], eax

; 696  : 
; 697  : 		ShaderMacroMgr macromgr;

	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	??0ShaderMacroMgr@Ogre@@QAE@XZ		; Ogre::ShaderMacroMgr::ShaderMacroMgr
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 698  : 		macromgr.createFromShaderEnv(env);

	mov	eax, DWORD PTR _env$[ebp]
	push	eax
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	?createFromShaderEnv@ShaderMacroMgr@Ogre@@QAEXABUShaderEnvFlags@2@@Z ; Ogre::ShaderMacroMgr::createFromShaderEnv

; 699  : 
; 700  : 		for(int i=0; i<MaterialMacro::MAX_MACRO; i++)

	mov	DWORD PTR _i$145238[ebp], 0
	jmp	SHORT $LN18@createComp
$LN17@createComp:
	mov	ecx, DWORD PTR _i$145238[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$145238[ebp], ecx
$LN18@createComp:
	cmp	DWORD PTR _i$145238[ebp], 4
	jge	SHORT $LN16@createComp

; 701  : 		{
; 702  : 			if(macros.indices[i] > 0)

	mov	edx, DWORD PTR _macros$[ebp]
	add	edx, DWORD PTR _i$145238[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $LN15@createComp

; 703  : 			{
; 704  : 				macromgr.AddMacro((const char *)m_pMtlTemplate->getParam(macros.indices[i]-1)->name, macros.value[i]);

	mov	ecx, DWORD PTR _macros$[ebp]
	add	ecx, DWORD PTR _i$145238[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _macros$[ebp]
	add	eax, DWORD PTR _i$145238[ebp]
	movzx	ecx, BYTE PTR [eax]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?getParam@MaterialTemplate@Ogre@@QAEPAUParamDefine@12@I@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	?AddMacro@ShaderMacroMgr@Ogre@@QAEXPBDH@Z ; Ogre::ShaderMacroMgr::AddMacro
$LN15@createComp:

; 705  : 			}
; 706  : 		}

	jmp	SHORT $LN17@createComp
$LN16@createComp:

; 707  : 
; 708  : 		if(m_Type == COMPILED_EFFECT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN14@createComp

; 709  : 		{
; 710  : 			ptmp->m_pBuffer = prs->compileCode(m_Path, 0, macromgr.GetMacros());

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ ; Ogre::ShaderMacroMgr::GetMacros
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z ; Ogre::D3D9RenderSystem::compileCode
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [ecx+12], eax
	jmp	$LN13@createComp
$LN14@createComp:

; 711  : 		}
; 712  : 		else if(m_Type == COMPILED_VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN12@createComp

; 713  : 		{
; 714  : 			ptmp->m_pBuffer = prs->compileCode(m_Path, 0, macromgr.GetMacros(), "VSMain", "vs_2_0", &ptmp->m_pConst);

	mov	eax, DWORD PTR _ptmp$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	push	OFFSET $SG145247
	push	OFFSET $SG145248
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ ; Ogre::ShaderMacroMgr::GetMacros
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z ; Ogre::D3D9RenderSystem::compileCode
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 715  : 		}
; 716  : 		else

	jmp	SHORT $LN13@createComp
$LN12@createComp:

; 717  : 		{
; 718  : 			ptmp->m_pBuffer = prs->compileCode(m_Path, 0, macromgr.GetMacros(), "PSMain", "ps_2_0", &ptmp->m_pConst);

	mov	edx, DWORD PTR _ptmp$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	push	OFFSET $SG145250
	push	OFFSET $SG145251
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ ; Ogre::ShaderMacroMgr::GetMacros
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??BFixedString@Ogre@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z ; Ogre::D3D9RenderSystem::compileCode
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN13@createComp:

; 719  : 		}
; 720  : 
; 721  : 		if(ptmp->m_pBuffer == NULL)

	mov	edx, DWORD PTR _ptmp$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN10@createComp

; 722  : 		{
; 723  : 			delete ptmp;

	mov	eax, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR $T157875[ebp], eax
	mov	ecx, DWORD PTR $T157875[ebp]
	mov	DWORD PTR $T157874[ebp], ecx
	cmp	DWORD PTR $T157874[ebp], 0
	je	SHORT $LN23@createComp
	push	1
	mov	ecx, DWORD PTR $T157874[ebp]
	call	??_GCompiledShader@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN24@createComp
$LN23@createComp:
	mov	DWORD PTR tv195[ebp], 0
$LN24@createComp:

; 724  : 			return NULL;

	mov	DWORD PTR $T157878[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	??1ShaderMacroMgr@Ogre@@QAE@XZ		; Ogre::ShaderMacroMgr::~ShaderMacroMgr
	mov	eax, DWORD PTR $T157878[ebp]
	jmp	$LN19@createComp
$LN10@createComp:

; 725  : 		}
; 726  : 
; 727  : 		ptmp->m_BufferKey = StringUtil::hash((const char *)ptmp->m_pBuffer->GetBufferPointer(), 3, int(ptmp->m_pBuffer->GetBufferSize()));

	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+16]
	call	ecx
	push	eax
	push	3
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	push	eax
	call	DWORD PTR __imp_?hash@StringUtil@Ogre@@SAIPBDIH@Z
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [edx+40], eax

; 728  : 
; 729  : 		// copy compiled buffer
; 730  : 		uint bufferSize = ptmp->m_pBuffer->GetBufferSize();

	mov	eax, DWORD PTR _ptmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+16]
	call	edx
	mov	DWORD PTR _bufferSize$[ebp], eax

; 731  : 		ptmp->m_CompiledBuf.resize(bufferSize);

	mov	eax, DWORD PTR _bufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptmp$[ebp]
	add	ecx, 16					; 00000010H
	call	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ; std::vector<char,std::allocator<char> >::resize

; 732  : 		memcpy(&ptmp->m_CompiledBuf[0], ptmp->m_pBuffer->GetBufferPointer(), bufferSize);

	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+12]
	call	ecx
	push	eax
	push	0
	mov	ecx, DWORD PTR _ptmp$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 733  : 
; 734  : 		for(size_t i=0; i<m_Shaders.size(); i++)

	mov	DWORD PTR _i$145258[ebp], 0
	jmp	SHORT $LN9@createComp
$LN8@createComp:
	mov	edx, DWORD PTR _i$145258[ebp]
	add	edx, 1
	mov	DWORD PTR _i$145258[ebp], edx
$LN9@createComp:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	cmp	DWORD PTR _i$145258[ebp], eax
	jae	$LN7@createComp

; 735  : 		{
; 736  : 			CompiledShader *ptmp2 = m_Shaders[i];

	mov	eax, DWORD PTR _i$145258[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ptmp2$145262[ebp], ecx

; 737  : 			bool keyEqual = (ptmp->m_BufferKey==ptmp2->m_BufferKey);

	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	eax, DWORD PTR _ptmp2$145262[ebp]
	mov	ecx, DWORD PTR [edx+40]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+40]
	sete	dl
	mov	BYTE PTR _keyEqual$145263[ebp], dl

; 738  : 			bool sizeEqual = (ptmp->m_CompiledBuf.size() == ptmp2->m_CompiledBuf.size());

	mov	ecx, DWORD PTR _ptmp$[ebp]
	add	ecx, 16					; 00000010H
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _ptmp2$145262[ebp]
	add	ecx, 16					; 00000010H
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	xor	ecx, ecx
	cmp	esi, eax
	sete	cl
	mov	BYTE PTR _sizeEqual$145264[ebp], cl

; 739  : 			bool bufferEqual = false;

	mov	BYTE PTR _bufferEqual$145265[ebp], 0

; 740  : 			if (keyEqual && sizeEqual)

	movzx	edx, BYTE PTR _keyEqual$145263[ebp]
	test	edx, edx
	je	SHORT $LN6@createComp
	movzx	eax, BYTE PTR _sizeEqual$145264[ebp]
	test	eax, eax
	je	SHORT $LN6@createComp

; 741  : 			{
; 742  : 				bufferEqual = (0 == memcmp(&ptmp->m_CompiledBuf[0],
; 743  : 					&ptmp2->m_CompiledBuf[0], ptmp->m_CompiledBuf.size()));

	mov	ecx, DWORD PTR _ptmp$[ebp]
	add	ecx, 16					; 00000010H
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	push	0
	mov	ecx, DWORD PTR _ptmp2$145262[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	push	eax
	push	0
	mov	ecx, DWORD PTR _ptmp$[ebp]
	add	ecx, 16					; 00000010H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	add	eax, 1
	mov	BYTE PTR _bufferEqual$145265[ebp], al
$LN6@createComp:

; 744  : 			}
; 745  : 			//bool sizeEqual = (ptmp->m_pBuffer->GetBufferSize()==ptmp2->m_pBuffer->GetBufferSize());
; 746  : 			//bool bufferEqual = (0 == memcmp(ptmp->m_pBuffer->GetBufferPointer(), 
; 747  : 			//	ptmp2->m_pBuffer->GetBufferPointer(), ptmp->m_pBuffer->GetBufferSize()));
; 748  : 
; 749  : 			if (keyEqual && sizeEqual && bufferEqual )

	movzx	ecx, BYTE PTR _keyEqual$145263[ebp]
	test	ecx, ecx
	je	$LN5@createComp
	movzx	edx, BYTE PTR _sizeEqual$145264[ebp]
	test	edx, edx
	je	$LN5@createComp
	movzx	eax, BYTE PTR _bufferEqual$145265[ebp]
	test	eax, eax
	je	$LN5@createComp

; 750  : 			{
; 751  : 				delete ptmp;

	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR $T157880[ebp], ecx
	mov	edx, DWORD PTR $T157880[ebp]
	mov	DWORD PTR $T157879[ebp], edx
	cmp	DWORD PTR $T157879[ebp], 0
	je	SHORT $LN25@createComp
	push	1
	mov	ecx, DWORD PTR $T157879[ebp]
	call	??_GCompiledShader@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN26@createComp
$LN25@createComp:
	mov	DWORD PTR tv298[ebp], 0
$LN26@createComp:

; 752  : 
; 753  : 				// m_Shaders.push_back(ptmp2);(不要这个，释放时会有问题)
; 754  : 				m_MacroShaderMap[key] = ptmp2;

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::operator[]
	mov	ecx, DWORD PTR _ptmp2$145262[ebp]
	mov	DWORD PTR [eax], ecx

; 755  : 				ptmp2->addShaderKey(key);

	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _key$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _key$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _key$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _key$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _ptmp2$145262[ebp]
	call	?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z ; Ogre::CompiledShader::addShaderKey

; 756  : 
; 757  : 				return ptmp2;

	mov	edx, DWORD PTR _ptmp2$145262[ebp]
	mov	DWORD PTR $T157883[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	??1ShaderMacroMgr@Ogre@@QAE@XZ		; Ogre::ShaderMacroMgr::~ShaderMacroMgr
	mov	eax, DWORD PTR $T157883[ebp]
	jmp	$LN19@createComp
$LN5@createComp:

; 758  : 			}
; 759  : 		}

	jmp	$LN8@createComp
$LN7@createComp:

; 760  : 
; 761  : 		if(m_Type == COMPILED_EFFECT)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@createComp

; 762  : 		{
; 763  : 			ptmp->m_pEffect = prs->createD3DXEffect(ptmp->m_pBuffer);

	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createD3DXEffect
	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [ecx+44], eax
	jmp	SHORT $LN3@createComp
$LN4@createComp:

; 764  : 		}
; 765  : 		else if(m_Type == COMPILED_VS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN2@createComp

; 766  : 		{
; 767  : 			ptmp->m_pVS = prs->createVertexShader(ptmp->m_pBuffer);

	mov	eax, DWORD PTR _ptmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createVertexShader
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [edx+48], eax

; 768  : 		}
; 769  : 		else

	jmp	SHORT $LN3@createComp
$LN2@createComp:

; 770  : 		{
; 771  : 			ptmp->m_pPS = prs->createPixelShader(ptmp->m_pBuffer);

	mov	eax, DWORD PTR _ptmp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _prs$[ebp]
	call	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createPixelShader
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [edx+52], eax
$LN3@createComp:

; 772  : 		}
; 773  : 
; 774  : 		ptmp->cacheTechnique();

	mov	ecx, DWORD PTR _ptmp$[ebp]
	call	?cacheTechnique@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheTechnique

; 775  : 		ptmp->cacheParamHandle();

	mov	ecx, DWORD PTR _ptmp$[ebp]
	call	?cacheParamHandle@CompiledShader@Ogre@@QAEXXZ ; Ogre::CompiledShader::cacheParamHandle

; 776  : 
; 777  : 		ptmp->m_bCreated = true;

	mov	eax, DWORD PTR _ptmp$[ebp]
	mov	BYTE PTR [eax+364], 1

; 778  : 
; 779  : 		ptmp->addShaderKey(key);

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _key$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _key$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _key$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _ptmp$[ebp]
	call	?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z ; Ogre::CompiledShader::addShaderKey

; 780  : 
; 781  : 		m_MacroShaderMap[key] = ptmp;

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::operator[]
	mov	edx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR [eax], edx

; 782  : 		m_Shaders.push_back(ptmp);

	lea	eax, DWORD PTR _ptmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEXABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::push_back

; 783  : 
; 784  : 		return ptmp;

	mov	ecx, DWORD PTR _ptmp$[ebp]
	mov	DWORD PTR $T157884[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _macromgr$[ebp]
	call	??1ShaderMacroMgr@Ogre@@QAE@XZ		; Ogre::ShaderMacroMgr::~ShaderMacroMgr
	mov	eax, DWORD PTR $T157884[ebp]
$LN19@createComp:

; 785  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z$0:
	mov	eax, DWORD PTR $T157871[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z$1:
	lea	ecx, DWORD PTR _macromgr$[ebp]
	jmp	??1ShaderMacroMgr@Ogre@@QAE@XZ		; Ogre::ShaderMacroMgr::~ShaderMacroMgr
__ehhandler$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?createCompiledShader@CompiledShaderGroup@Ogre@@QAEPAVCompiledShader@2@ABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ENDP ; Ogre::CompiledShaderGroup::createCompiledShader
PUBLIC	?push_back@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEXABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::push_back
PUBLIC	?hasShaderKey@CompiledShader@Ogre@@QAE_NTShaderEnvKey@2@@Z ; Ogre::CompiledShader::hasShaderKey
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.h
;	COMDAT ?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 16
?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z PROC ; Ogre::CompiledShader::addShaderKey, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			if (!hasShaderKey(key))

	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _key$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _key$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _key$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _key$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasShaderKey@CompiledShader@Ogre@@QAE_NTShaderEnvKey@2@@Z ; Ogre::CompiledShader::hasShaderKey
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@addShaderK

; 49   : 			{
; 50   : 				mShaderEnvKeys.push_back(key);

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	?push_back@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEXABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::push_back
$LN2@addShaderK:

; 51   : 			}
; 52   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?addShaderKey@CompiledShader@Ogre@@QAEXTShaderEnvKey@2@@Z ENDP ; Ogre::CompiledShader::addShaderKey
_TEXT	ENDS
PUBLIC	??8Ogre@@YA_NABTShaderEnvKey@0@0@Z		; Ogre::operator==
PUBLIC	??A?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAATShaderEnvKey@Ogre@@I@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator[]
PUBLIC	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
; Function compile flags: /Odtp
;	COMDAT ?hasShaderKey@CompiledShader@Ogre@@QAE_NTShaderEnvKey@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$133476 = -8						; size = 4
_bHas$ = -1						; size = 1
_key$ = 8						; size = 16
?hasShaderKey@CompiledShader@Ogre@@QAE_NTShaderEnvKey@2@@Z PROC ; Ogre::CompiledShader::hasShaderKey, COMDAT
; _this$ = ecx

; 55   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 			bool bHas = false;

	mov	BYTE PTR _bHas$[ebp], 0

; 57   : 
; 58   : 			for (int i=0; i<(int)mShaderEnvKeys.size(); i++)

	mov	DWORD PTR _i$133476[ebp], 0
	jmp	SHORT $LN4@hasShaderK
$LN3@hasShaderK:
	mov	eax, DWORD PTR _i$133476[ebp]
	add	eax, 1
	mov	DWORD PTR _i$133476[ebp], eax
$LN4@hasShaderK:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	cmp	DWORD PTR _i$133476[ebp], eax
	jge	SHORT $LN2@hasShaderK

; 59   : 			{
; 60   : 				if (key == mShaderEnvKeys[i])

	mov	ecx, DWORD PTR _i$133476[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 340				; 00000154H
	call	??A?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAATShaderEnvKey@Ogre@@I@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator[]
	push	eax
	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	call	??8Ogre@@YA_NABTShaderEnvKey@0@0@Z	; Ogre::operator==
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@hasShaderK

; 61   : 					bHas = true;

	mov	BYTE PTR _bHas$[ebp], 1
$LN1@hasShaderK:

; 62   : 			}

	jmp	SHORT $LN3@hasShaderK
$LN2@hasShaderK:

; 63   : 
; 64   : 			return bHas;

	mov	al, BYTE PTR _bHas$[ebp]

; 65   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?hasShaderKey@CompiledShader@Ogre@@QAE_NTShaderEnvKey@2@@Z ENDP ; Ogre::CompiledShader::hasShaderKey
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3dmaterialtemplate.h
_TEXT	ENDS
;	COMDAT ??8Ogre@@YA_NABTShaderEnvKey@0@0@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv84 = -16						; size = 4
tv83 = -12						; size = 4
tv73 = -8						; size = 4
tv72 = -4						; size = 4
_key1$ = 8						; size = 4
_key2$ = 12						; size = 4
??8Ogre@@YA_NABTShaderEnvKey@0@0@Z PROC			; Ogre::operator==, COMDAT

; 37   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 38   : 		return key1.keydata[0] == key2.keydata[0] && 
; 39   : 			key1.keydata[1] == key2.keydata[1];

	mov	eax, DWORD PTR _key1$[ebp]
	mov	ecx, DWORD PTR _key2$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR tv73[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator
	mov	edx, DWORD PTR _key1$[ebp]
	mov	eax, DWORD PTR _key2$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	mov	DWORD PTR tv84[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR tv84[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+12]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv68[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv68[ebp]

; 40   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??8Ogre@@YA_NABTShaderEnvKey@0@0@Z ENDP			; Ogre::operator==
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
_TEXT	ENDS
;	COMDAT ?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ PROC ; Ogre::ShaderMacroMgr::GetMacros, COMDAT
; _this$ = ecx

; 77   : 		const D3DXMACRO *GetMacros(){ return &m_Macros[0]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMacros@ShaderMacroMgr@Ogre@@QAEPBU_D3DXMACRO@@XZ ENDP ; Ogre::ShaderMacroMgr::GetMacros
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
PUBLIC	?compileAllShaders@CompiledShaderGroup@Ogre@@QAEXXZ ; Ogre::CompiledShaderGroup::compileAllShaders
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T157903 = -24						; size = 8
$T157902 = -16						; size = 8
_iter$ = -8						; size = 8
?compileAllShaders@CompiledShaderGroup@Ogre@@QAEXXZ PROC ; Ogre::CompiledShaderGroup::compileAllShaders
; _this$ = ecx

; 788  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 		std::map<ShaderEnvKey, CompiledShader *>::iterator iter = m_MacroShaderMap.begin();

	lea	eax, DWORD PTR _iter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	jmp	SHORT $LN3@compileAll
$LN2@compileAll:

; 790  : 
; 791  : 		for (; iter!=m_MacroShaderMap.end(); iter++)

	push	0
	lea	ecx, DWORD PTR $T157902[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++
$LN3@compileAll:
	lea	edx, DWORD PTR $T157903[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@compileAll

; 792  : 		{
; 793  : 			iter->second->create();

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
	mov	ecx, DWORD PTR [eax+16]
	call	?create@CompiledShader@Ogre@@QAE_NXZ	; Ogre::CompiledShader::create
	jmp	SHORT $LN2@compileAll
$LN4@compileAll:

; 794  : 		}
; 795  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?compileAllShaders@CompiledShaderGroup@Ogre@@QAEXXZ ENDP ; Ogre::CompiledShaderGroup::compileAllShaders
_TEXT	ENDS
PUBLIC	??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??1ShaderTechnique@Ogre@@MAE@XZ			; Ogre::ShaderTechnique::~ShaderTechnique
PUBLIC	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
PUBLIC	?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize
PUBLIC	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
PUBLIC	??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??_7D3DShaderTechnique@Ogre@@6B@		; Ogre::D3DShaderTechnique::`vftable'
PUBLIC	??0ShaderTechnique@Ogre@@QAE@XZ			; Ogre::ShaderTechnique::ShaderTechnique
PUBLIC	??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z ; Ogre::D3DShaderTechnique::D3DShaderTechnique
PUBLIC	??_R4D3DShaderTechnique@Ogre@@6B@		; Ogre::D3DShaderTechnique::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3DShaderTechnique@Ogre@@@8		; Ogre::D3DShaderTechnique `RTTI Type Descriptor'
PUBLIC	??_R3D3DShaderTechnique@Ogre@@8			; Ogre::D3DShaderTechnique::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3DShaderTechnique@Ogre@@8			; Ogre::D3DShaderTechnique::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3DShaderTechnique@Ogre@@8	; Ogre::D3DShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ShaderTechnique@Ogre@@8		; Ogre::ShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVShaderTechnique@Ogre@@@8		; Ogre::ShaderTechnique `RTTI Type Descriptor'
PUBLIC	??_R3ShaderTechnique@Ogre@@8			; Ogre::ShaderTechnique::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ShaderTechnique@Ogre@@8			; Ogre::ShaderTechnique::`RTTI Base Class Array'
PUBLIC	?begin@D3DShaderTechnique@Ogre@@UAEIXZ		; Ogre::D3DShaderTechnique::begin
PUBLIC	?end@D3DShaderTechnique@Ogre@@UAEXXZ		; Ogre::D3DShaderTechnique::end
PUBLIC	?beginPass@D3DShaderTechnique@Ogre@@UAEXI@Z	; Ogre::D3DShaderTechnique::beginPass
PUBLIC	?endPass@D3DShaderTechnique@Ogre@@UAEXXZ	; Ogre::D3DShaderTechnique::endPass
PUBLIC	?setConstant@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::D3DShaderTechnique::setConstant
PUBLIC	?setConstant@D3DShaderTechnique@Ogre@@UAEXPBDPBXI@Z ; Ogre::D3DShaderTechnique::setConstant
PUBLIC	?setTexture@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z ; Ogre::D3DShaderTechnique::setTexture
PUBLIC	?setTexture@D3DShaderTechnique@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z ; Ogre::D3DShaderTechnique::setTexture
PUBLIC	?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z ; Ogre::D3DShaderTechnique::setStreamInput
PUBLIC	?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z ; Ogre::D3DShaderTechnique::setStreamInput
PUBLIC	?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z ; Ogre::D3DShaderTechnique::setStreamInput
PUBLIC	?commitChanges@D3DShaderTechnique@Ogre@@UAEXXZ	; Ogre::D3DShaderTechnique::commitChanges
PUBLIC	?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z ; Ogre::D3DShaderTechnique::draw
PUBLIC	?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@II@Z ; Ogre::D3DShaderTechnique::draw
PUBLIC	?getRequiredParams@D3DShaderTechnique@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z ; Ogre::D3DShaderTechnique::getRequiredParams
EXTRN	_memset:PROC
EXTRN	?getCompiledVSPS@D3DMaterialTemplate@Ogre@@QAEPAVCompiledShader@2@W4COMPILED_TYPE@2@PBDABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z:PROC ; Ogre::D3DMaterialTemplate::getCompiledVSPS
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ED3DShaderTechnique@Ogre@@UAEPAXI@Z:PROC	; Ogre::D3DShaderTechnique::`vector deleting destructor'
;	COMDAT ??_R2ShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R2ShaderTechnique@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ShaderTechnique@Ogre@@8 ; Ogre::ShaderTechnique::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R3ShaderTechnique@Ogre@@8 DD 00H			; Ogre::ShaderTechnique::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVShaderTechnique@Ogre@@@8
_DATA	SEGMENT
??_R0?AVShaderTechnique@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ShaderTechnique `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVShaderTechnique@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ShaderTechnique@Ogre@@8 DD FLAT:??_R0?AVShaderTechnique@Ogre@@@8 ; Ogre::ShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3DShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3DShaderTechnique@Ogre@@8 DD FLAT:??_R0?AVD3DShaderTechnique@Ogre@@@8 ; Ogre::D3DShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3DShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3DShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R2D3DShaderTechnique@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3DShaderTechnique@Ogre@@8 ; Ogre::D3DShaderTechnique::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3DShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R3D3DShaderTechnique@Ogre@@8 DD 00H			; Ogre::D3DShaderTechnique::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2D3DShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3DShaderTechnique@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3DShaderTechnique@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3DShaderTechnique `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3DShaderTechnique@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3DShaderTechnique@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3DShaderTechnique@Ogre@@6B@ DD 00H		; Ogre::D3DShaderTechnique::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3DShaderTechnique@Ogre@@@8
	DD	FLAT:??_R3D3DShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3DShaderTechnique@Ogre@@6B@
CONST	SEGMENT
??_7D3DShaderTechnique@Ogre@@6B@ DD FLAT:??_R4D3DShaderTechnique@Ogre@@6B@ ; Ogre::D3DShaderTechnique::`vftable'
	DD	FLAT:?begin@D3DShaderTechnique@Ogre@@UAEIXZ
	DD	FLAT:?end@D3DShaderTechnique@Ogre@@UAEXXZ
	DD	FLAT:?beginPass@D3DShaderTechnique@Ogre@@UAEXI@Z
	DD	FLAT:?endPass@D3DShaderTechnique@Ogre@@UAEXXZ
	DD	FLAT:?setConstant@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z
	DD	FLAT:?setConstant@D3DShaderTechnique@Ogre@@UAEXPBDPBXI@Z
	DD	FLAT:?setTexture@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z
	DD	FLAT:?setTexture@D3DShaderTechnique@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z
	DD	FLAT:?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z
	DD	FLAT:?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z
	DD	FLAT:?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z
	DD	FLAT:?commitChanges@D3DShaderTechnique@Ogre@@UAEXXZ
	DD	FLAT:?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z
	DD	FLAT:?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@II@Z
	DD	FLAT:?getRequiredParams@D3DShaderTechnique@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z
	DD	FLAT:??_ED3DShaderTechnique@Ogre@@UAEPAXI@Z
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z$1
__ehfuncinfo$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
_data$145334 = -44					; size = 4
_i$145330 = -40						; size = 4
_usage$145324 = -36					; size = 4
_data$145316 = -32					; size = 4
_desc$145317 = -28					; size = 4
_i$145312 = -24						; size = 4
_ptechdesc$ = -20					; size = 4
_npass$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pmtltemplate$ = 8					; size = 4
_env$ = 12						; size = 4
_macros$ = 16						; size = 4
_lod$ = 20						; size = 4
_usage$ = 24						; size = 4
??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z PROC ; Ogre::D3DShaderTechnique::D3DShaderTechnique
; _this$ = ecx

; 799  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ShaderTechnique@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DShaderTechnique@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pmtltemplate$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+220], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+228], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 800  : 		m_pEffect = pmtltemplate->getCompiledVSPS(COMPILED_EFFECT, NULL, env, macros);

	mov	eax, DWORD PTR _macros$[ebp]
	push	eax
	mov	ecx, DWORD PTR _env$[ebp]
	push	ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _pmtltemplate$[ebp]
	call	?getCompiledVSPS@D3DMaterialTemplate@Ogre@@QAEPAVCompiledShader@2@W4COMPILED_TYPE@2@PBDABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::D3DMaterialTemplate::getCompiledVSPS
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 801  : 		if(m_pEffect == NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN21@D3DShaderT

; 802  : 			return;

	jmp	$LN22@D3DShaderT
$LN21@D3DShaderT:

; 803  : 
; 804  : 		TechniqueDesc *ptechdesc = m_pEffect->getTechnique(lod, usage);

	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lod$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?getTechnique@CompiledShader@Ogre@@QAEPAUTechniqueDesc@2@IW4RenderUsage@2@@Z ; Ogre::CompiledShader::getTechnique
	mov	DWORD PTR _ptechdesc$[ebp], eax

; 805  : 		if(ptechdesc == NULL) 

	cmp	DWORD PTR _ptechdesc$[ebp], 0
	jne	SHORT $LN20@D3DShaderT

; 806  : 			return;

	jmp	$LN22@D3DShaderT
$LN20@D3DShaderT:

; 807  : 
; 808  : 		m_hTech = ptechdesc->htech;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ptechdesc$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax

; 809  : 		m_pDevice = m_pEffect->m_pDevice;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+228], ecx

; 810  : 
; 811  : 		size_t npass = ptechdesc->m_Pass.size();

	mov	ecx, DWORD PTR _ptechdesc$[ebp]
	add	ecx, 12					; 0000000cH
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	mov	DWORD PTR _npass$[ebp], eax

; 812  : 		m_AllPass.resize(npass);

	mov	edx, DWORD PTR _npass$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize

; 813  : 		memset(&m_AllPass[0], 0, npass*sizeof(PassData));

	mov	eax, DWORD PTR _npass$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 814  : 
; 815  : 		for(size_t i=0; i<npass; i++)

	mov	DWORD PTR _i$145312[ebp], 0
	jmp	SHORT $LN19@D3DShaderT
$LN18@D3DShaderT:
	mov	ecx, DWORD PTR _i$145312[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$145312[ebp], ecx
$LN19@D3DShaderT:
	mov	edx, DWORD PTR _i$145312[ebp]
	cmp	edx, DWORD PTR _npass$[ebp]
	jae	$LN17@D3DShaderT

; 816  : 		{
; 817  : 			PassData &data = m_AllPass[i];

	mov	eax, DWORD PTR _i$145312[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	mov	DWORD PTR _data$145316[ebp], eax

; 818  : 			PassDesc &desc = ptechdesc->m_Pass[i];

	mov	ecx, DWORD PTR _i$145312[ebp]
	push	ecx
	mov	ecx, DWORD PTR _ptechdesc$[ebp]
	add	ecx, 12					; 0000000cH
	call	??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator[]
	mov	DWORD PTR _desc$145317[ebp], eax

; 819  : 
; 820  : 			if(desc.vs[0] == 1) 

	mov	edx, DWORD PTR _desc$145317[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 1
	jne	SHORT $LN16@D3DShaderT

; 821  : 				data.use_fx_vs = true; 

	mov	ecx, DWORD PTR _data$145316[ebp]
	mov	BYTE PTR [ecx+8], 1
	jmp	SHORT $LN15@D3DShaderT
$LN16@D3DShaderT:

; 822  : 			else if(desc.vs[0] != 0) 

	mov	edx, DWORD PTR _desc$145317[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN15@D3DShaderT

; 823  : 				data.vs = pmtltemplate->getCompiledVSPS(COMPILED_VS, desc.vs, env, macros);

	mov	ecx, DWORD PTR _macros$[ebp]
	push	ecx
	mov	edx, DWORD PTR _env$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$145317[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pmtltemplate$[ebp]
	call	?getCompiledVSPS@D3DMaterialTemplate@Ogre@@QAEPAVCompiledShader@2@W4COMPILED_TYPE@2@PBDABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::D3DMaterialTemplate::getCompiledVSPS
	mov	ecx, DWORD PTR _data$145316[ebp]
	mov	DWORD PTR [ecx], eax
$LN15@D3DShaderT:

; 824  : 
; 825  : 			if(desc.ps[0] == 1) 

	mov	edx, DWORD PTR _desc$145317[ebp]
	movsx	eax, BYTE PTR [edx+16]
	cmp	eax, 1
	jne	SHORT $LN13@D3DShaderT

; 826  : 				data.use_fx_ps = true;

	mov	ecx, DWORD PTR _data$145316[ebp]
	mov	BYTE PTR [ecx+9], 1
	jmp	SHORT $LN12@D3DShaderT
$LN13@D3DShaderT:

; 827  : 			else if(desc.ps[0] != 0) 

	mov	edx, DWORD PTR _desc$145317[ebp]
	movsx	eax, BYTE PTR [edx+16]
	test	eax, eax
	je	SHORT $LN12@D3DShaderT

; 828  : 				data.ps = pmtltemplate->getCompiledVSPS(COMPILED_PS, desc.ps, env, macros);

	mov	ecx, DWORD PTR _macros$[ebp]
	push	ecx
	mov	edx, DWORD PTR _env$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$145317[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	2
	mov	ecx, DWORD PTR _pmtltemplate$[ebp]
	call	?getCompiledVSPS@D3DMaterialTemplate@Ogre@@QAEPAVCompiledShader@2@W4COMPILED_TYPE@2@PBDABUShaderEnvFlags@2@ABUMaterialMacro@2@@Z ; Ogre::D3DMaterialTemplate::getCompiledVSPS
	mov	ecx, DWORD PTR _data$145316[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN12@D3DShaderT:

; 829  : 		}

	jmp	$LN18@D3DShaderT
$LN17@D3DShaderT:

; 830  : 
; 831  : 		for(ShaderParamUsage usage=SPU_INSTANCE_PARAM; usage<SPU_ENV_PARAM_END; usage=(ShaderParamUsage)(usage+1))

	mov	DWORD PTR _usage$145324[ebp], 0
	jmp	SHORT $LN10@D3DShaderT
$LN9@D3DShaderT:
	mov	edx, DWORD PTR _usage$145324[ebp]
	add	edx, 1
	mov	DWORD PTR _usage$145324[ebp], edx
$LN10@D3DShaderT:
	cmp	DWORD PTR _usage$145324[ebp], 48	; 00000030H
	jge	$LN22@D3DShaderT

; 832  : 		{
; 833  : 			if(m_pEffect->hasConstant(usage, ptechdesc->htech))

	mov	eax, DWORD PTR _ptechdesc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _usage$145324[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@D3DShaderT

; 834  : 			{
; 835  : 				m_UsedParams[m_NumUsedParams++] = usage;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _usage$145324[ebp]
	mov	DWORD PTR [ecx+eax*4+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], ecx
$LN7@D3DShaderT:

; 836  : 			}
; 837  : 
; 838  : 			for(size_t i=0; i<npass; i++)

	mov	DWORD PTR _i$145330[ebp], 0
	jmp	SHORT $LN6@D3DShaderT
$LN5@D3DShaderT:
	mov	eax, DWORD PTR _i$145330[ebp]
	add	eax, 1
	mov	DWORD PTR _i$145330[ebp], eax
$LN6@D3DShaderT:
	mov	ecx, DWORD PTR _i$145330[ebp]
	cmp	ecx, DWORD PTR _npass$[ebp]
	jae	$LN4@D3DShaderT

; 839  : 			{
; 840  : 				PassData &data = m_AllPass[i];

	mov	edx, DWORD PTR _i$145330[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	mov	DWORD PTR _data$145334[ebp], eax

; 841  : 				if((data.vs&&data.vs->hasConstant(usage,NULL)) || (data.ps&&data.ps->hasConstant(usage,NULL)))

	mov	eax, DWORD PTR _data$145334[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@D3DShaderT
	push	0
	mov	ecx, DWORD PTR _usage$145324[ebp]
	push	ecx
	mov	edx, DWORD PTR _data$145334[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@D3DShaderT
$LN1@D3DShaderT:
	mov	ecx, DWORD PTR _data$145334[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN3@D3DShaderT
	push	0
	mov	edx, DWORD PTR _usage$145324[ebp]
	push	edx
	mov	eax, DWORD PTR _data$145334[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@D3DShaderT
$LN2@D3DShaderT:

; 842  : 				{
; 843  : 					m_UsedParams[m_NumUsedParams++] = usage;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+220]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _usage$145324[ebp]
	mov	DWORD PTR [ecx+eax*4+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+220], ecx

; 844  : 					break;

	jmp	SHORT $LN4@D3DShaderT
$LN3@D3DShaderT:

; 845  : 				}
; 846  : 			}

	jmp	$LN5@D3DShaderT
$LN4@D3DShaderT:

; 847  : 		}

	jmp	$LN9@D3DShaderT
$LN22@D3DShaderT:

; 848  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
__unwindfunclet$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
__ehhandler$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DShaderTechnique@Ogre@@QAE@PAVD3DMaterialTemplate@1@ABUShaderEnvFlags@1@ABUMaterialMacro@1@IW4RenderUsage@1@@Z ENDP ; Ogre::D3DShaderTechnique::D3DShaderTechnique
PUBLIC	??_7ShaderTechnique@Ogre@@6B@			; Ogre::ShaderTechnique::`vftable'
PUBLIC	??_R4ShaderTechnique@Ogre@@6B@			; Ogre::ShaderTechnique::`RTTI Complete Object Locator'
EXTRN	__purecall:PROC
EXTRN	??_EShaderTechnique@Ogre@@MAEPAXI@Z:PROC	; Ogre::ShaderTechnique::`vector deleting destructor'
;	COMDAT ??_R4ShaderTechnique@Ogre@@6B@
; File i:\svnroot\client\ogremain\ogreshader.h
rdata$r	SEGMENT
??_R4ShaderTechnique@Ogre@@6B@ DD 00H			; Ogre::ShaderTechnique::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVShaderTechnique@Ogre@@@8
	DD	FLAT:??_R3ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ShaderTechnique@Ogre@@6B@
CONST	SEGMENT
??_7ShaderTechnique@Ogre@@6B@ DD FLAT:??_R4ShaderTechnique@Ogre@@6B@ ; Ogre::ShaderTechnique::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EShaderTechnique@Ogre@@MAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1ShaderTechnique@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ShaderTechnique@Ogre@@MAE@XZ PROC			; Ogre::ShaderTechnique::~ShaderTechnique, COMDAT
; _this$ = ecx

; 195  : 		virtual ~ShaderTechnique(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ShaderTechnique@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1ShaderTechnique@Ogre@@MAE@XZ ENDP			; Ogre::ShaderTechnique::~ShaderTechnique
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GShaderTechnique@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GShaderTechnique@Ogre@@MAEPAXI@Z PROC		; Ogre::ShaderTechnique::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GShaderTechnique@Ogre@@MAEPAXI@Z ENDP		; Ogre::ShaderTechnique::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1D3DShaderTechnique@Ogre@@UAE@XZ		; Ogre::D3DShaderTechnique::~D3DShaderTechnique
; Function compile flags: /Odtp
;	COMDAT ??_GD3DShaderTechnique@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DShaderTechnique@Ogre@@UAEPAXI@Z PROC		; Ogre::D3DShaderTechnique::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DShaderTechnique@Ogre@@UAE@XZ	; Ogre::D3DShaderTechnique::~D3DShaderTechnique
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DShaderTechnique@Ogre@@UAEPAXI@Z ENDP		; Ogre::D3DShaderTechnique::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ShaderTechnique@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ShaderTechnique@Ogre@@QAE@XZ PROC			; Ogre::ShaderTechnique::ShaderTechnique, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ShaderTechnique@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ShaderTechnique@Ogre@@QAE@XZ ENDP			; Ogre::ShaderTechnique::ShaderTechnique
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1D3DShaderTechnique@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DShaderTechnique@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1D3DShaderTechnique@Ogre@@UAE@XZ$1
__ehfuncinfo$??1D3DShaderTechnique@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1D3DShaderTechnique@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DShaderTechnique@Ogre@@UAE@XZ PROC			; Ogre::D3DShaderTechnique::~D3DShaderTechnique
; _this$ = ecx

; 851  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DShaderTechnique@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DShaderTechnique@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 852  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DShaderTechnique@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
__unwindfunclet$??1D3DShaderTechnique@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	jmp	??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
__ehhandler$??1D3DShaderTechnique@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DShaderTechnique@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DShaderTechnique@Ogre@@UAE@XZ ENDP			; Ogre::D3DShaderTechnique::~D3DShaderTechnique
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_npass$ = -8						; size = 4
_peffect$ = -4						; size = 4
?begin@D3DShaderTechnique@Ogre@@UAEIXZ PROC		; Ogre::D3DShaderTechnique::begin
; _this$ = ecx

; 855  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 856  : 		if(m_hTech == NULL) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN4@begin
	xor	eax, eax
	jmp	SHORT $LN5@begin
$LN4@begin:

; 857  : 
; 858  : 		ID3DXEffect *peffect = m_pEffect->m_pEffect;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _peffect$[ebp], eax

; 859  : 
; 860  : 		if (!peffect)

	cmp	DWORD PTR _peffect$[ebp], 0
	jne	SHORT $LN3@begin

; 861  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN5@begin
$LN3@begin:

; 862  : 
; 863  : 		peffect->SetTechnique(m_hTech);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _peffect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _peffect$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+232]
	call	eax

; 864  : 
; 865  : 		UINT npass;
; 866  : 		if(FAILED(peffect->Begin(&npass, 0))) return 0;

	push	0
	lea	ecx, DWORD PTR _npass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+252]
	call	edx
	test	eax, eax
	jge	SHORT $LN2@begin
	xor	eax, eax
	jmp	SHORT $LN5@begin
	jmp	SHORT $LN5@begin
$LN2@begin:

; 867  : 		else return npass;

	mov	eax, DWORD PTR _npass$[ebp]
$LN5@begin:

; 868  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?begin@D3DShaderTechnique@Ogre@@UAEIXZ ENDP		; Ogre::D3DShaderTechnique::begin
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?end@D3DShaderTechnique@Ogre@@UAEXXZ PROC		; Ogre::D3DShaderTechnique::end
; _this$ = ecx

; 871  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 872  : 		if (!m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN2@end

; 873  : 			return;

	jmp	SHORT $LN3@end
$LN2@end:

; 874  : 
; 875  : 		if (!m_pEffect->m_pEffect)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $LN1@end

; 876  : 			return;

	jmp	SHORT $LN3@end
$LN1@end:

; 877  : 
; 878  : 		m_pEffect->m_pEffect->End();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+268]
	call	edx
$LN3@end:

; 879  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?end@D3DShaderTechnique@Ogre@@UAEXXZ ENDP		; Ogre::D3DShaderTechnique::end
; Function compile flags: /Odtp
_this$ = -8						; size = 4
_desc$ = -4						; size = 4
_ipass$ = 8						; size = 4
?beginPass@D3DShaderTechnique@Ogre@@UAEXI@Z PROC	; Ogre::D3DShaderTechnique::beginPass
; _this$ = ecx

; 882  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 883  : 		if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN7@beginPass

; 884  : 			m_pEffect->m_pEffect->BeginPass((UINT)ipass);

	mov	ecx, DWORD PTR _ipass$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR [eax+256]
	call	ecx
$LN7@beginPass:

; 885  : 
; 886  : 		m_CurPass = ipass;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ipass$[ebp]
	mov	DWORD PTR [edx+16], eax

; 887  : 
; 888  : 		PassData &desc = m_AllPass[ipass];

	mov	ecx, DWORD PTR _ipass$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	mov	DWORD PTR _desc$[ebp], eax

; 889  : 		if(!desc.use_fx_vs)

	mov	edx, DWORD PTR _desc$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	jne	SHORT $LN6@beginPass

; 890  : 		{
; 891  : 			if(desc.vs)

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@beginPass

; 892  : 				m_pDevice->SetVertexShader(desc.vs->m_pVS);

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+368]
	call	ecx

; 893  : 			else

	jmp	SHORT $LN6@beginPass
$LN5@beginPass:

; 894  : 				m_pDevice->SetVertexShader(NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+368]
	call	ecx
$LN6@beginPass:

; 895  : 		}
; 896  : 		
; 897  : 		if(!desc.use_fx_ps)

	mov	edx, DWORD PTR _desc$[ebp]
	movzx	eax, BYTE PTR [edx+9]
	test	eax, eax
	jne	SHORT $LN8@beginPass

; 898  : 		{
; 899  : 			if(desc.ps)

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN2@beginPass

; 900  : 				m_pDevice->SetPixelShader(desc.ps->m_pPS);

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+428]
	call	ecx

; 901  : 			else

	jmp	SHORT $LN8@beginPass
$LN2@beginPass:

; 902  : 				m_pDevice->SetPixelShader(NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+428]
	call	ecx
$LN8@beginPass:

; 903  : 		}
; 904  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?beginPass@D3DShaderTechnique@Ogre@@UAEXI@Z ENDP	; Ogre::D3DShaderTechnique::beginPass
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?endPass@D3DShaderTechnique@Ogre@@UAEXXZ PROC		; Ogre::D3DShaderTechnique::endPass
; _this$ = ecx

; 907  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 908  : 		if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@endPass

; 909  : 			m_pEffect->m_pEffect->EndPass();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [edx+44]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	eax, DWORD PTR [edx+264]
	call	eax
$LN2@endPass:

; 910  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?endPass@D3DShaderTechnique@Ogre@@UAEXXZ ENDP		; Ogre::D3DShaderTechnique::endPass
; Function compile flags: /Odtp
_this$ = -8						; size = 4
_desc$ = -4						; size = 4
_pname$ = 8						; size = 4
_pdata$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?setConstant@D3DShaderTechnique@Ogre@@UAEXPBDPBXI@Z PROC ; Ogre::D3DShaderTechnique::setConstant
; _this$ = ecx

; 913  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 		if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@setConstan@3

; 915  : 			m_pEffect->setConstant(pname, pdata, nbytes);

	mov	ecx, DWORD PTR _nbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _pname$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z ; Ogre::CompiledShader::setConstant
$LN3@setConstan@3:

; 916  : 
; 917  : 		m_bDirty = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+224], 1

; 918  : 
; 919  : 		PassData &desc = m_AllPass[m_CurPass];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	mov	DWORD PTR _desc$[ebp], eax

; 920  : 		if(desc.ps) desc.ps->setConstant(pname, pdata, nbytes);

	mov	edx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@setConstan@3
	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z ; Ogre::CompiledShader::setConstant
$LN2@setConstan@3:

; 921  : 		if(desc.vs) desc.vs->setConstant(pname, pdata, nbytes);

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@setConstan@3
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?setConstant@CompiledShader@Ogre@@QAEXPBDPBXI@Z ; Ogre::CompiledShader::setConstant
$LN4@setConstan@3:

; 922  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@D3DShaderTechnique@Ogre@@UAEXPBDPBXI@Z ENDP ; Ogre::D3DShaderTechnique::setConstant
; Function compile flags: /Odtp
_this$ = -8						; size = 4
_desc$ = -4						; size = 4
_usage$ = 8						; size = 4
_pdata$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?setConstant@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z PROC ; Ogre::D3DShaderTechnique::setConstant
; _this$ = ecx

; 925  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 		if (m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@setConstan@4

; 927  : 			m_pEffect->setConstant(usage, pdata, nbytes);

	mov	ecx, DWORD PTR _nbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _usage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
$LN3@setConstan@4:

; 928  : 		m_bDirty = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+224], 1

; 929  : 
; 930  : 		PassData &desc = m_AllPass[m_CurPass];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
	mov	DWORD PTR _desc$[ebp], eax

; 931  : 		if(desc.ps) desc.ps->setConstant(usage, pdata, nbytes);

	mov	edx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@setConstan@4
	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdata$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
$LN2@setConstan@4:

; 932  : 		if(desc.vs) desc.vs->setConstant(usage, pdata, nbytes);

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN4@setConstan@4
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
$LN4@setConstan@4:

; 933  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z ENDP ; Ogre::D3DShaderTechnique::setConstant
_TEXT	ENDS
PUBLIC	?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$ = -12						; size = 4
_hparam$ = -8						; size = 4
_peffect$ = -4						; size = 4
_pname$ = 8						; size = 4
_ptexture$ = 12						; size = 4
?setTexture@D3DShaderTechnique@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z PROC ; Ogre::D3DShaderTechnique::setTexture
; _this$ = ecx

; 936  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 937  : 		if (!m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN4@setTexture

; 938  : 			return;

	jmp	SHORT $LN5@setTexture
$LN4@setTexture:

; 939  : 
; 940  : 		ID3DXEffect *peffect = m_pEffect->m_pEffect;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _peffect$[ebp], eax

; 941  : 		D3DXHANDLE hparam = peffect->GetParameterByName(NULL, pname);

	mov	ecx, DWORD PTR _pname$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _peffect$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _peffect$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+36]
	call	edx
	mov	DWORD PTR _hparam$[ebp], eax

; 942  : 		if(hparam == NULL) return;

	cmp	DWORD PTR _hparam$[ebp], 0
	jne	SHORT $LN3@setTexture
	jmp	SHORT $LN5@setTexture
$LN3@setTexture:

; 943  : 
; 944  : 		HRESULT hr;
; 945  : 		if(ptexture == NULL) hr = peffect->SetTexture(hparam, NULL);

	cmp	DWORD PTR _ptexture$[ebp], 0
	jne	SHORT $LN2@setTexture
	push	0
	mov	eax, DWORD PTR _hparam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _peffect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _peffect$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+208]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax
	jmp	SHORT $LN1@setTexture
$LN2@setTexture:

; 946  : 		else hr = peffect->SetTexture(hparam, static_cast<D3D9HardwarePixelBuffer *>(ptexture)->getSysTexture());

	mov	ecx, DWORD PTR _ptexture$[ebp]
	call	?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
	push	eax
	mov	edx, DWORD PTR _hparam$[ebp]
	push	edx
	mov	eax, DWORD PTR _peffect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _peffect$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+208]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax
$LN1@setTexture:

; 947  : 		assert(SUCCEEDED(hr));
; 948  : 
; 949  : 		m_bDirty = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+224], 1
$LN5@setTexture:

; 950  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setTexture@D3DShaderTechnique@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z ENDP ; Ogre::D3DShaderTechnique::setTexture
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarepixelbuffer.h
_TEXT	ENDS
;	COMDAT ?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ PROC ; Ogre::D3D9HardwarePixelBuffer::getSysTexture, COMDAT
; _this$ = ecx

; 76   : 		IDirect3DBaseTexture9 *getSysTexture(){ return m_pSysTex; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ENDP ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
_hr$145422 = -12					; size = 4
_peffect$ = -8						; size = 4
_h$ = -4						; size = 4
_usage$ = 8						; size = 4
_ptexture$ = 12						; size = 4
?setTexture@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z PROC ; Ogre::D3DShaderTechnique::setTexture
; _this$ = ecx

; 953  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 954  : 		if (!m_pEffect)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN4@setTexture@2

; 955  : 			return;

	jmp	SHORT $LN5@setTexture@2
$LN4@setTexture@2:

; 956  : 
; 957  : 		ID3DXEffect *peffect = m_pEffect->m_pEffect;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _peffect$[ebp], eax

; 958  : 		D3DXHANDLE h = m_pEffect->paramUsage2Handle(usage);

	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?paramUsage2Handle@CompiledShader@Ogre@@QAEPBDW4ShaderParamUsage@2@@Z ; Ogre::CompiledShader::paramUsage2Handle
	mov	DWORD PTR _h$[ebp], eax

; 959  : 		if(h != NULL)	

	cmp	DWORD PTR _h$[ebp], 0
	je	SHORT $LN5@setTexture@2

; 960  : 		{
; 961  : 			HRESULT hr;
; 962  : 			if(ptexture == NULL) hr = peffect->SetTexture(h, NULL);

	cmp	DWORD PTR _ptexture$[ebp], 0
	jne	SHORT $LN2@setTexture@2
	push	0
	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, DWORD PTR _peffect$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _peffect$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+208]
	call	ecx
	mov	DWORD PTR _hr$145422[ebp], eax
	jmp	SHORT $LN1@setTexture@2
$LN2@setTexture@2:

; 963  : 			else hr = peffect->SetTexture(h, static_cast<D3D9HardwarePixelBuffer *>(ptexture)->getSysTexture());

	mov	ecx, DWORD PTR _ptexture$[ebp]
	call	?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
	push	eax
	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	mov	eax, DWORD PTR _peffect$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _peffect$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+208]
	call	eax
	mov	DWORD PTR _hr$145422[ebp], eax
$LN1@setTexture@2:

; 964  : 			assert(SUCCEEDED(hr));
; 965  : 
; 966  : 			m_bDirty = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+224], 1
$LN5@setTexture@2:

; 967  : 		}
; 968  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setTexture@D3DShaderTechnique@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z ENDP ; Ogre::D3DShaderTechnique::setTexture
_TEXT	ENDS
PUBLIC	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
EXTRN	__imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ:PROC
EXTRN	__imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv92 = -28						; size = 4
_this$ = -24						; size = 4
_pool$145441 = -20					; size = 4
_offset$145443 = -16					; size = 4
_pvb$145440 = -12					; size = 4
_i$145435 = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_ppvb$ = 12						; size = 4
_poffsetbytes$ = 16					; size = 4
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z PROC ; Ogre::D3DShaderTechnique::setStreamInput
; _this$ = ecx

; 971  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 		assert(ppvb!=NULL);
; 973  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR _pdevice$[ebp], ecx

; 974  : 
; 975  : 		for(int i=0; i<8; i++)

	mov	DWORD PTR _i$145435[ebp], 0
	jmp	SHORT $LN4@setStreamI
$LN3@setStreamI:
	mov	edx, DWORD PTR _i$145435[ebp]
	add	edx, 1
	mov	DWORD PTR _i$145435[ebp], edx
$LN4@setStreamI:
	cmp	DWORD PTR _i$145435[ebp], 8
	jge	$LN2@setStreamI

; 976  : 		{
; 977  : 			if(ppvb[i] == NULL)

	mov	eax, DWORD PTR _i$145435[ebp]
	mov	ecx, DWORD PTR _ppvb$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@setStreamI

; 978  : 			{
; 979  : 				pdevice->SetStreamSource(i, NULL, 0, 0);

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _i$145435[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+400]
	call	eax

; 980  : 				break;

	jmp	SHORT $LN2@setStreamI
$LN1@setStreamI:

; 981  : 			}
; 982  : 
; 983  : 			HardwareVertexBuffer *pvb = ppvb[i];

	mov	ecx, DWORD PTR _i$145435[ebp]
	mov	edx, DWORD PTR _ppvb$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pvb$145440[ebp], eax

; 984  : 			D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$145440[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$145441[ebp], eax

; 985  : 
; 986  : 			size_t offset = poffsetbytes==NULL?0:poffsetbytes[i];

	cmp	DWORD PTR _poffsetbytes$[ebp], 0
	jne	SHORT $LN7@setStreamI
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN8@setStreamI
$LN7@setStreamI:
	mov	ecx, DWORD PTR _i$145435[ebp]
	mov	edx, DWORD PTR _poffsetbytes$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv92[ebp], eax
$LN8@setStreamI:
	mov	ecx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _offset$145443[ebp], ecx

; 987  : 
; 988  : 			assert(pvb->m_Stride > 0);
; 989  : 			pdevice->SetStreamSource(i, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	edx, DWORD PTR _pvb$145440[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _pvb$145440[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$145443[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$145441[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	mov	ecx, DWORD PTR _i$145435[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+400]
	call	edx

; 990  : 		}

	jmp	$LN3@setStreamI
$LN2@setStreamI:

; 991  : 
; 992  : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	eax, DWORD PTR _vertdecl$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+348]
	call	edx

; 993  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z ENDP ; Ogre::D3DShaderTechnique::setStreamInput
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
_TEXT	ENDS
;	COMDAT ?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ PROC ; Ogre::D3DVertexBufferPool::getSysBuf, COMDAT
; _this$ = ecx

; 37   : 		IDirect3DVertexBuffer9 *getSysBuf(){ return m_pSysBuf; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ENDP ; Ogre::D3DVertexBufferPool::getSysBuf
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
_TEXT	ENDS
_TEXT	SEGMENT
tv82 = -28						; size = 4
_this$ = -24						; size = 4
_pool$145462 = -20					; size = 4
_offset$145464 = -16					; size = 4
_pvb$145461 = -12					; size = 4
_i$145457 = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_ppvb$ = 12						; size = 4
_nNumInstance$ = 16					; size = 4
_poffsetbytes$ = 20					; size = 4
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z PROC ; Ogre::D3DShaderTechnique::setStreamInput
; _this$ = ecx

; 996  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		assert(ppvb!=NULL);
; 998  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR _pdevice$[ebp], ecx

; 999  : 
; 1000 : 		for(int i=0; i<2; i++)

	mov	DWORD PTR _i$145457[ebp], 0
	jmp	SHORT $LN3@setStreamI@2
$LN2@setStreamI@2:
	mov	edx, DWORD PTR _i$145457[ebp]
	add	edx, 1
	mov	DWORD PTR _i$145457[ebp], edx
$LN3@setStreamI@2:
	cmp	DWORD PTR _i$145457[ebp], 2
	jge	SHORT $LN1@setStreamI@2

; 1001 : 		{
; 1002 : 			HardwareVertexBuffer *pvb = ppvb[i];

	mov	eax, DWORD PTR _i$145457[ebp]
	mov	ecx, DWORD PTR _ppvb$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pvb$145461[ebp], edx

; 1003 : 			D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$145461[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$145462[ebp], eax

; 1004 : 
; 1005 : 			size_t offset = poffsetbytes==NULL?0:poffsetbytes[i];

	cmp	DWORD PTR _poffsetbytes$[ebp], 0
	jne	SHORT $LN6@setStreamI@2
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN7@setStreamI@2
$LN6@setStreamI@2:
	mov	eax, DWORD PTR _i$145457[ebp]
	mov	ecx, DWORD PTR _poffsetbytes$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv82[ebp], edx
$LN7@setStreamI@2:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _offset$145464[ebp], eax

; 1006 : 
; 1007 : 			assert(pvb->m_Stride > 0);
; 1008 : 			pdevice->SetStreamSource(i, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	ecx, DWORD PTR _pvb$145461[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	ecx, DWORD PTR _pvb$145461[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$145464[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$145462[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	mov	eax, DWORD PTR _i$145457[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+400]
	call	ecx

; 1009 : 		}

	jmp	SHORT $LN2@setStreamI@2
$LN1@setStreamI@2:

; 1010 : 
; 1011 : 		pdevice->SetStreamSourceFreq(0,D3DSTREAMSOURCE_INDEXEDDATA | nNumInstance);

	mov	edx, DWORD PTR _nNumInstance$[ebp]
	or	edx, 1073741824				; 40000000H
	push	edx
	push	0
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+408]
	call	eax

; 1012 : 
; 1013 : 		pdevice->SetStreamSourceFreq(1,D3DSTREAMSOURCE_INSTANCEDATA | 1ul);

	push	-2147483647				; 80000001H
	push	1
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+408]
	call	ecx

; 1014 : 
; 1015 : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	edx, DWORD PTR _vertdecl$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+348]
	call	ecx

; 1016 : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z ENDP ; Ogre::D3DShaderTechnique::setStreamInput
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_pool$ = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_pvb$ = 12						; size = 4
_offset$ = 16						; size = 4
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z PROC ; Ogre::D3DShaderTechnique::setStreamInput
; _this$ = ecx

; 1019 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1020 : 		assert(pvb!=NULL);
; 1021 : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+228]
	mov	DWORD PTR _pdevice$[ebp], ecx

; 1022 : 		D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$[ebp], eax

; 1023 : 
; 1024 : 		assert(pvb->m_Stride > 0);
; 1025 : 		pdevice->SetStreamSource(0, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	edx, DWORD PTR _pvb$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _pvb$[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	push	0
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+400]
	call	ecx

; 1026 : 		pdevice->SetStreamSource(1, NULL, 0, 0);

	push	0
	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+400]
	call	edx

; 1027 : 
; 1028 : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	eax, DWORD PTR _vertdecl$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+348]
	call	edx

; 1029 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setStreamInput@D3DShaderTechnique@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z ENDP ; Ogre::D3DShaderTechnique::setStreamInput
; Function compile flags: /Odtp
_this$ = -16						; size = 4
_pdevice$ = -12						; size = 4
_d3dprimtype$ = -8					; size = 4
_stats$ = -4						; size = 4
_primtype$ = 8						; size = 4
_start_vert$ = 12					; size = 4
_nprimitive$ = 16					; size = 4
?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@II@Z PROC ; Ogre::D3DShaderTechnique::draw
; _this$ = ecx

; 1054 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1055 : 		D3DPRIMITIVETYPE d3dprimtype = Topo2D3DPrim(primtype);

	mov	eax, DWORD PTR _primtype$[ebp]
	push	eax
	call	?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ; Ogre::Topo2D3DPrim
	add	esp, 4
	mov	DWORD PTR _d3dprimtype$[ebp], eax

; 1056 : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR _pdevice$[ebp], edx

; 1057 : 
; 1058 : 		commitChanges();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 1059 : 
; 1060 : 		pdevice->DrawPrimitive(d3dprimtype, (UINT)start_vert, (UINT)nprimitive);

	mov	ecx, DWORD PTR _nprimitive$[ebp]
	push	ecx
	mov	edx, DWORD PTR _start_vert$[ebp]
	push	edx
	mov	eax, DWORD PTR _d3dprimtype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+324]
	call	ecx

; 1061 : 
; 1062 : 		RenderSystem::RenderStats &stats = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr())->m_RenderStats;

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	add	eax, 4
	mov	DWORD PTR _stats$[ebp], eax

; 1063 : 		stats.ndraw_d++;

	mov	edx, DWORD PTR _stats$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1064 : 		stats.nprimitive_d += nprimitive;

	mov	edx, DWORD PTR _stats$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _nprimitive$[ebp]
	mov	ecx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1065 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@II@Z ENDP ; Ogre::D3DShaderTechnique::draw
; Function compile flags: /Odtp
tv64 = -4						; size = 4
_topo$ = 8						; size = 4
?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z PROC ; Ogre::Topo2D3DPrim

; 1032 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1033 : 		switch(topo)

	mov	eax, DWORD PTR _topo$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN1@Topo2D3DPr
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@Topo2D3DPr[edx*4]
$LN7@Topo2D3DPr:

; 1034 : 		{
; 1035 : 		case PRIM_POINTLIST:
; 1036 : 			return D3DPT_POINTLIST;

	mov	eax, 1
	jmp	SHORT $LN10@Topo2D3DPr
$LN6@Topo2D3DPr:

; 1037 : 		case PRIM_LINELIST:
; 1038 : 			return D3DPT_LINELIST;

	mov	eax, 2
	jmp	SHORT $LN10@Topo2D3DPr
$LN5@Topo2D3DPr:

; 1039 : 		case PRIM_LINESTRIP:
; 1040 : 			return D3DPT_LINESTRIP;

	mov	eax, 3
	jmp	SHORT $LN10@Topo2D3DPr
$LN4@Topo2D3DPr:

; 1041 : 		case PRIM_TRIANGLELIST:
; 1042 : 			return D3DPT_TRIANGLELIST;

	mov	eax, 4
	jmp	SHORT $LN10@Topo2D3DPr
$LN3@Topo2D3DPr:

; 1043 : 		case PRIM_TRIANGLESTRIP:
; 1044 : 			return D3DPT_TRIANGLESTRIP;

	mov	eax, 5
	jmp	SHORT $LN10@Topo2D3DPr
$LN2@Topo2D3DPr:

; 1045 : 		case PRIM_TRIANGLEFAN:
; 1046 : 			return D3DPT_TRIANGLEFAN;

	mov	eax, 6
	jmp	SHORT $LN10@Topo2D3DPr
$LN1@Topo2D3DPr:

; 1047 : 		default:
; 1048 : 			assert(0);
; 1049 : 			return D3DPT_POINTLIST;

	mov	eax, 1
$LN10@Topo2D3DPr:

; 1050 : 		}
; 1051 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@Topo2D3DPr:
	DD	$LN7@Topo2D3DPr
	DD	$LN6@Topo2D3DPr
	DD	$LN5@Topo2D3DPr
	DD	$LN4@Topo2D3DPr
	DD	$LN3@Topo2D3DPr
	DD	$LN2@Topo2D3DPr
?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ENDP ; Ogre::Topo2D3DPrim
_TEXT	ENDS
PUBLIC	?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ; Ogre::D3DIndexBufferPool::getSysBuf
EXTRN	__imp_?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pdevice$ = -12						; size = 4
_d3dprimtype$ = -8					; size = 4
_stats$ = -4						; size = 4
_primtype$ = 8						; size = 4
_start_vert$ = 12					; size = 4
_nprimitive$ = 16					; size = 4
_pib$ = 20						; size = 4
_refvert_start$ = 24					; size = 4
_refvert_num$ = 28					; size = 4
?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z PROC ; Ogre::D3DShaderTechnique::draw
; _this$ = ecx

; 1068 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1069 : 		D3DPRIMITIVETYPE d3dprimtype = Topo2D3DPrim(primtype);

	mov	eax, DWORD PTR _primtype$[ebp]
	push	eax
	call	?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ; Ogre::Topo2D3DPrim
	add	esp, 4
	mov	DWORD PTR _d3dprimtype$[ebp], eax

; 1070 : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR _pdevice$[ebp], edx

; 1071 : 
; 1072 : 		commitChanges();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax

; 1073 : 
; 1074 : 		pdevice->SetIndices(static_cast<D3DIndexBufferPool *>(pib->getPool())->getSysBuf());

	mov	ecx, DWORD PTR _pib$[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	ecx, eax
	call	?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ; Ogre::D3DIndexBufferPool::getSysBuf
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+416]
	call	ecx

; 1075 : 		pdevice->DrawIndexedPrimitive(d3dprimtype, 0, (UINT)refvert_start, (UINT)refvert_num, (UINT)(pib->getStartIndex()+start_vert), (UINT)nprimitive);

	mov	edx, DWORD PTR _nprimitive$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pib$[ebp]
	call	DWORD PTR __imp_?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _start_vert$[ebp]
	push	eax
	mov	eax, DWORD PTR _refvert_num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _refvert_start$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _d3dprimtype$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+328]
	call	eax

; 1076 : 
; 1077 : 		RenderSystem::RenderStats &stats = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr())->m_RenderStats;

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	add	eax, 4
	mov	DWORD PTR _stats$[ebp], eax

; 1078 : 		stats.ndraw_d++;

	mov	ecx, DWORD PTR _stats$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [eax+28], edx

; 1079 : 		stats.nprimitive_d += nprimitive;

	mov	ecx, DWORD PTR _stats$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _nprimitive$[ebp]
	mov	eax, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [eax+24], edx

; 1080 : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?draw@D3DShaderTechnique@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z ENDP ; Ogre::D3DShaderTechnique::draw
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
_TEXT	ENDS
;	COMDAT ?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ PROC ; Ogre::D3DIndexBufferPool::getSysBuf, COMDAT
; _this$ = ecx

; 59   : 		IDirect3DIndexBuffer9 *getSysBuf(){ return m_pSysBuf; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ENDP ; Ogre::D3DIndexBufferPool::getSysBuf
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9shadermanager.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
?commitChanges@D3DShaderTechnique@Ogre@@UAEXXZ PROC	; Ogre::D3DShaderTechnique::commitChanges
; _this$ = ecx

; 1083 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 		if(m_bDirty)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+224]
	test	ecx, ecx
	je	SHORT $LN3@commitChan

; 1085 : 		{
; 1086 : 			if (m_pEffect)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN1@commitChan

; 1087 : 				m_pEffect->m_pEffect->CommitChanges();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR [edx]
	push	eax
	mov	edx, DWORD PTR [ecx+260]
	call	edx
$LN1@commitChan:

; 1088 : 
; 1089 : 			m_bDirty = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+224], 0
$LN3@commitChan:

; 1090 : 		}
; 1091 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?commitChanges@D3DShaderTechnique@Ogre@@UAEXXZ ENDP	; Ogre::D3DShaderTechnique::commitChanges
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_maxbuf$ = 12						; size = 4
?getRequiredParams@D3DShaderTechnique@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z PROC ; Ogre::D3DShaderTechnique::getRequiredParams
; _this$ = ecx

; 1094 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1095 : 		assert(m_NumUsedParams < maxbuf);
; 1096 : 
; 1097 : 		memcpy(pbuf, m_UsedParams, m_NumUsedParams*sizeof(ShaderParamUsage));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1098 : 		return m_NumUsedParams;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+220]

; 1099 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRequiredParams@D3DShaderTechnique@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z ENDP ; Ogre::D3DShaderTechnique::getRequiredParams
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QAEAAUShaderEnv@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QAEAAUShaderEnv@Ogre@@I@Z PROC ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UShaderEnv@Ogre@@V?$allocator@UShaderEnv@Ogre@@@std@@@std@@QAEAAUShaderEnv@Ogre@@I@Z ENDP ; std::vector<Ogre::ShaderEnv,std::allocator<Ogre::ShaderEnv> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	?_Buy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Buy
PUBLIC	??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	??0?$allocator@UPassDesc@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T157958 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T157958[ebp], esp
	call	??0?$allocator@UPassDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	?_Tidy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXIUPassDesc@Ogre@@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T157977 = -32						; size = 32
__Newsize$ = 8						; size = 4
?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T157977[ebp], eax
	mov	DWORD PTR $T157977[ebp+4], eax
	mov	DWORD PTR $T157977[ebp+8], eax
	mov	DWORD PTR $T157977[ebp+12], eax
	mov	DWORD PTR $T157977[ebp+16], eax
	mov	DWORD PTR $T157977[ebp+20], eax
	mov	DWORD PTR $T157977[ebp+24], eax
	mov	DWORD PTR $T157977[ebp+28], eax
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	lea	esi, DWORD PTR $T157977[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXIUPassDesc@Ogre@@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize

; 714  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 5

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@3:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAUPassDesc@Ogre@@I@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
EXTRN	__imp_??0?$allocator@D@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T157984 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T157984[ebp], esp
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXID@Z ; std::vector<char,std::allocator<char> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	push	0
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXID@Z ; std::vector<char,std::allocator<char> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z PROC	; std::vector<char,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@4:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR __Pos$[ebp]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ENDP	; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	?_Buy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Buy
PUBLIC	??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158009 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158009[ebp], esp
	call	??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	?_Tidy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@5:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAPAUTechniqueDesc@Ogre@@I@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@ABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::insert
PUBLIC	?end@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::end
PUBLIC	?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill
PUBLIC	?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEXABQAUTechniqueDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T158034 = -24						; size = 8
$T158033 = -16						; size = 8
$T158032 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEXABQAUTechniqueDesc@Ogre@@@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T158033[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158032[ebp], ecx
	mov	DWORD PTR $T158032[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158032[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T158032[ebp]
	push	edx
	lea	eax, DWORD PTR $T158034[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@ABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEXABQAUTechniqueDesc@Ogre@@@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	?_Buy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Buy
PUBLIC	??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158037 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158037[ebp], esp
	call	??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	?_Tidy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAATShaderEnvKey@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAATShaderEnvKey@Ogre@@I@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@6:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAATShaderEnvKey@Ogre@@I@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@V?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::insert
PUBLIC	?end@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::end
PUBLIC	?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill
PUBLIC	?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEXABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T158062 = -24						; size = 8
$T158061 = -16						; size = 8
$T158060 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEXABTShaderEnvKey@Ogre@@@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T158061[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158060[ebp], ecx
	mov	DWORD PTR $T158060[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158060[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T158060[ebp]
	push	edx
	lea	eax, DWORD PTR $T158062[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@V?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::insert
$LN3@push_back@2:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEXABTShaderEnvKey@Ogre@@@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	?_Buy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158065 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158065[ebp], esp
	call	??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	?_Tidy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@7:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAPAVCompiledShader@Ogre@@I@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@ABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::insert
PUBLIC	?end@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::end
PUBLIC	?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill
PUBLIC	?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEXABQAVCompiledShader@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T158090 = -24						; size = 8
$T158089 = -16						; size = 8
$T158088 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEXABQAVCompiledShader@Ogre@@@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T158089[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158088[ebp], ecx
	mov	DWORD PTR $T158088[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158088[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T158088[ebp]
	push	edx
	lea	eax, DWORD PTR $T158090[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@ABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::insert
$LN3@push_back@3:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEXABQAVCompiledShader@Ogre@@@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ$0
__ehfuncinfo$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158094 = -14						; size = 1
$T158093 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ PROC ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T158093[ebp]
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	push	eax
	lea	eax, DWORD PTR $T158094[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 104  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
__ehhandler$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator*
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
PUBLIC	??0?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@QAE@ABTShaderEnvKey@Ogre@@ABQAVCompiledShader@3@@Z ; std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>
PUBLIC	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::lower_bound
; Function compile flags: /Odtp
;	COMDAT ??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T158108 = -60						; size = 8
$T158107 = -52						; size = 8
$T158106 = -44						; size = 4
$T158105 = -40						; size = 24
$T158104 = -16						; size = 8
__Where$ = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z PROC ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	lea	edx, DWORD PTR $T158104[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@operator@8
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@operator@8
$LN1@operator@8:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T158106[ebp], 0
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T158107[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR $T158107[ebp+4], ecx
	lea	edx, DWORD PTR $T158106[ebp]
	push	edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158105[ebp]
	call	??0?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@QAE@ABTShaderEnvKey@Ogre@@ABQAVCompiledShader@3@@Z ; std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>
	push	eax
	mov	ecx, DWORD PTR $T158107[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T158107[ebp]
	push	edx
	lea	eax, DWORD PTR $T158108[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Where$[ebp], ecx
	mov	DWORD PTR __Where$[ebp+4], edx
$LN2@operator@8:

; 174  : 		return ((*_Where).second);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator*
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@@std@@QAEAAPAVCompiledShader@Ogre@@ABTShaderEnvKey@3@@Z ENDP ; std::map<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tidy
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
; Function compile flags: /Odtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
tv137 = -36						; size = 4
_this$ = -32						; size = 4
$T158127 = -28						; size = 8
$T158125 = -20						; size = 8
$T158124 = -12						; size = 4
__Where$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::lower_bound

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	lea	edx, DWORD PTR $T158125[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@find
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN4@find
$LN3@find:
	lea	ecx, DWORD PTR $T158127[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	mov	DWORD PTR tv137[ebp], eax
$LN4@find:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T158124[ebp], edx
	mov	eax, DWORD PTR $T158124[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::find
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	?_Buy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Buy
PUBLIC	??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158131 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158131[ebp], esp
	call	??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	?_Tidy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXIUPassData@D3DShaderTechnique@Ogre@@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T158150 = -12						; size = 12
__Newsize$ = 8						; size = 4
?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T158150[ebp], eax
	mov	DWORD PTR $T158150[ebp+4], eax
	mov	DWORD PTR $T158150[ebp+8], eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	edx, DWORD PTR $T158150[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T158150[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T158150[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXIUPassData@D3DShaderTechnique@Ogre@@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize
_TEXT	ENDS
PUBLIC	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@9
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@9:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAUPassData@D3DShaderTechnique@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	?_Buy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE_NI@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Buy
PUBLIC	??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	??0?$allocator@U_D3DXMACRO@@@std@@QAE@XZ	; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158155 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158155[ebp], esp
	call	??0?$allocator@U_D3DXMACRO@@@std@@QAE@XZ ; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE_NI@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	?_Tidy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@10:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAU_D3DXMACRO@@I@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@V?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@ABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::insert
PUBLIC	?end@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::end
PUBLIC	?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill
PUBLIC	?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T158180 = -24						; size = 8
$T158179 = -16						; size = 8
$T158178 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T158179[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158178[ebp], ecx
	mov	DWORD PTR $T158178[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158178[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T158178[ebp]
	push	edx
	lea	eax, DWORD PTR $T158180[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@V?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@ABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::insert
$LN3@push_back@4:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEXABU_D3DXMACRO@@@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::push_back
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 469  : 			{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 			return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator*

; 471  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 480  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 482  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++

; 483  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 484  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
__ehhandler$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::~_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
__ehhandler$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::~_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
__ehhandler$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::~_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
__ehhandler$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::~_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
__ehhandler$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
__ehhandler$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::~_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::~_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::~_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::~_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
__ehhandler$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::~_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>
PUBLIC	??MOgre@@YA_NABTShaderEnvKey@0@0@Z		; Ogre::operator<
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z PROC ; std::less<Ogre::ShaderEnvKey>::operator(), COMDAT
; _this$ = ecx

; 142  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??MOgre@@YA_NABTShaderEnvKey@0@0@Z	; Ogre::operator<
	add	esp, 8

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ENDP ; std::less<Ogre::ShaderEnvKey>::operator()
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3dmaterialtemplate.h
_TEXT	ENDS
;	COMDAT ??MOgre@@YA_NABTShaderEnvKey@0@0@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv132 = -24						; size = 4
tv131 = -20						; size = 4
tv87 = -16						; size = 4
tv86 = -12						; size = 4
tv74 = -8						; size = 4
tv73 = -4						; size = 4
_key1$ = 8						; size = 4
_key2$ = 12						; size = 4
??MOgre@@YA_NABTShaderEnvKey@0@0@Z PROC			; Ogre::operator<, COMDAT

; 27   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 28   : 		if(key1.keydata[0] < key2.keydata[0]) 

	mov	eax, DWORD PTR _key1$[ebp]
	mov	ecx, DWORD PTR _key2$[ebp]
	mov	DWORD PTR tv73[ebp], eax
	mov	DWORD PTR tv74[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR tv74[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN4@operator@11
	jb	SHORT $LN9@operator@11
	mov	edx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR tv74[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN4@operator@11
$LN9@operator@11:

; 29   : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@operator@11
	jmp	SHORT $LN5@operator@11
$LN4@operator@11:

; 30   : 		else if(key1.keydata[0] > key2.keydata[0]) 

	mov	edx, DWORD PTR _key1$[ebp]
	mov	eax, DWORD PTR _key2$[ebp]
	mov	DWORD PTR tv86[ebp], edx
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jb	SHORT $LN2@operator@11
	ja	SHORT $LN10@operator@11
	mov	ecx, DWORD PTR tv86[ebp]
	mov	edx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jbe	SHORT $LN2@operator@11
$LN10@operator@11:

; 31   : 			return false;

	xor	al, al
	jmp	SHORT $LN5@operator@11

; 32   : 		else 

	jmp	SHORT $LN5@operator@11
$LN2@operator@11:

; 33   : 			return key1.keydata[1] < key2.keydata[1];

	mov	ecx, DWORD PTR _key1$[ebp]
	mov	edx, DWORD PTR _key2$[ebp]
	mov	DWORD PTR tv131[ebp], ecx
	mov	DWORD PTR tv132[ebp], edx
	mov	eax, DWORD PTR tv131[ebp]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	ja	SHORT $LN7@operator@11
	jb	SHORT $LN11@operator@11
	mov	eax, DWORD PTR tv131[ebp]
	mov	ecx, DWORD PTR tv132[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN7@operator@11
$LN11@operator@11:
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN8@operator@11
$LN7@operator@11:
	mov	DWORD PTR tv69[ebp], 0
$LN8@operator@11:
	mov	al, BYTE PTR tv69[ebp]
$LN5@operator@11:

; 34   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??MOgre@@YA_NABTShaderEnvKey@0@0@Z ENDP			; Ogre::operator<
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
_TEXT	ENDS
PUBLIC	?erase@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::erase
PUBLIC	??H?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+
PUBLIC	?begin@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::begin
PUBLIC	?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Insert_n
PUBLIC	?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::end
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXIUPassDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T158307 = -68						; size = 8
$T158306 = -60						; size = 8
$T158305 = -52						; size = 8
$T158304 = -44						; size = 8
$T158303 = -36						; size = 8
$T158302 = -28						; size = 8
$T158301 = -20						; size = 8
$T158300 = -12						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 32
?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXIUPassDesc@Ogre@@@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T158301[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158300[ebp], ecx
	mov	DWORD PTR $T158300[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T158300[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158300[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Insert_n
	jmp	SHORT $LN4@resize
$LN3@resize:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T158303[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T158302[ebp], edx
	mov	DWORD PTR $T158302[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T158306[ebp]
	push	edx
	lea	eax, DWORD PTR $T158305[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158304[ebp], ecx
	mov	DWORD PTR $T158304[ebp+4], edx
	mov	eax, DWORD PTR $T158302[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T158302[ebp]
	push	ecx
	mov	edx, DWORD PTR $T158304[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158304[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158307[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?resize@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEXIUPassDesc@Ogre@@@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::resize
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::allocate
PUBLIC	?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Xlen
PUBLIC	?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::deallocate
PUBLIC	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
PUBLIC	??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158314 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158314[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
__ehhandler$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_val<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UPassDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UPassDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UPassDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
_TEXT	ENDS
PUBLIC	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase
PUBLIC	??H?$_Vector_iterator@DV?$allocator@D@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<char,std::allocator<char> >::operator+
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z ; std::vector<char,std::allocator<char> >::_Insert_n
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXID@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T158344 = -64						; size = 8
$T158343 = -56						; size = 8
$T158342 = -48						; size = 8
$T158341 = -40						; size = 8
$T158340 = -32						; size = 8
$T158339 = -24						; size = 8
$T158338 = -16						; size = 8
$T158337 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 1
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXID@Z PROC ; std::vector<char,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T158338[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158337[ebp], ecx
	mov	DWORD PTR $T158337[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T158337[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158337[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z ; std::vector<char,std::allocator<char> >::_Insert_n
	jmp	SHORT $LN4@resize@2
$LN3@resize@2:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T158340[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T158339[ebp], edx
	mov	DWORD PTR $T158339[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T158343[ebp]
	push	edx
	lea	eax, DWORD PTR $T158342[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@DV?$allocator@D@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<char,std::allocator<char> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158341[ebp], ecx
	mov	DWORD PTR $T158341[ebp+4], edx
	mov	eax, DWORD PTR $T158339[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T158339[ebp]
	push	ecx
	mov	edx, DWORD PTR $T158341[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158341[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158344[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase
$LN4@resize@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXID@Z ENDP ; std::vector<char,std::allocator<char> >::resize
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
EXTRN	__imp_?allocate@?$allocator@D@std@@QAEPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z PROC	; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?allocate@?$allocator@D@std@@QAEPADI@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ENDP	; std::vector<char,std::allocator<char> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
EXTRN	__imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
EXTRN	__imp_??0?$allocator@D@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158351 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158351[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator-
PUBLIC	?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@ABQAUTechniqueDesc@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T158379 = -20						; size = 8
$T158376 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@ABQAUTechniqueDesc@Ogre@@@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T158376[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158379[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@ABQAUTechniqueDesc@Ogre@@@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::allocate
PUBLIC	?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Xlen
PUBLIC	?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158388 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158388[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
__ehhandler$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_val<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+
PUBLIC	?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator-
PUBLIC	?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@V?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@ABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T158418 = -20						; size = 8
$T158415 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@V?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@ABTShaderEnvKey@Ogre@@@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	lea	eax, DWORD PTR $T158415[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158418[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@V?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::allocate
PUBLIC	?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Xlen
PUBLIC	?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4
$LN2@Buy@4:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::deallocate
PUBLIC	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::deallocate
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158427 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158427[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
__ehhandler$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_val<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator-
PUBLIC	?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@ABQAVCompiledShader@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T158455 = -20						; size = 8
$T158452 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@ABQAVCompiledShader@Ogre@@@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	lea	eax, DWORD PTR $T158452[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158455[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@ABQAVCompiledShader@Ogre@@@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::allocate
PUBLIC	?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5
$LN2@Buy@5:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
PUBLIC	??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158464 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158464[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
__ehhandler$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_val<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Myval
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key, COMDAT

; 161  : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Myval
	add	esp, 4
	push	eax
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4

; 163  : 		}

	pop	ebp
	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158487 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158487[ebp], esp
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@TShaderEnvKey@Ogre@@@1@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::size
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T158503 = -68						; size = 12
$T158502 = -56						; size = 8
$T158501 = -48						; size = 8
$T158500 = -40						; size = 8
$T158499 = -32						; size = 8
$T158498 = -24						; size = 8
$T158497 = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	lea	ecx, DWORD PTR __Next$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator

; 672  : 
; 673  : 		if (size() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::size
	test	eax, eax
	jne	SHORT $LN32@insert@4

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
	jmp	$LN31@insert@4
$LN32@insert@4:

; 675  : 		else if (this->_Multi)

	xor	ecx, ecx
	je	$LN30@insert@4

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	lea	edx, DWORD PTR $T158497[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@insert@4

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN28@insert@4

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN28@insert@4:

; 682  : 				}

	jmp	$LN27@insert@4
$LN29@insert@4:

; 683  : 			else if (_Where == end())

	lea	edx, DWORD PTR $T158498[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@insert@4

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@insert@4

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN25@insert@4:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@4
$LN26@insert@4:

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN23@insert@4
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@insert@4

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN22@insert@4

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 696  : 				else

	jmp	SHORT $LN21@insert@4
$LN22@insert@4:

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN21@insert@4:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@4
$LN23@insert@4:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN27@insert@4
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	edx, DWORD PTR $T158499[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@insert@4
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@insert@4
$LN18@insert@4:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@insert@4

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 707  : 				else

	jmp	SHORT $LN27@insert@4
$LN17@insert@4:

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN27@insert@4:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@4
$LN30@insert@4:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	lea	eax, DWORD PTR $T158500[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@4

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@insert@4

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN13@insert@4:

; 718  : 				}

	jmp	$LN31@insert@4
$LN14@insert@4:

; 719  : 			else if (_Where == end())

	lea	eax, DWORD PTR $T158501[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@4

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@4

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN10@insert@4:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@4
$LN11@insert@4:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN8@insert@4
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@insert@4

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN7@insert@4

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4

; 732  : 				else

	jmp	SHORT $LN6@insert@4
$LN7@insert@4:

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@4
$LN6@insert@4:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@4
$LN8@insert@4:

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN31@insert@4
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	lea	eax, DWORD PTR $T158502[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@insert@4
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@insert@4
$LN3@insert@4:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN2@insert@4

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@4

; 743  : 				else

	jmp	SHORT $LN31@insert@4
$LN2@insert@4:

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@4
$LN31@insert@4:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T158503[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@4:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lbound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1005 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABTShaderEnvKey@Ogre@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T158514 = -40						; size = 8
$T158513 = -32						; size = 8
$T158512 = -24						; size = 8
$T158511 = -16						; size = 8
$T158510 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T158511[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158510[ebp], ecx
	mov	DWORD PTR $T158510[ebp+4], edx
	lea	eax, DWORD PTR $T158513[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158512[ebp], ecx
	mov	DWORD PTR $T158512[ebp+4], edx
	mov	eax, DWORD PTR $T158510[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T158510[ebp]
	push	ecx
	mov	edx, DWORD PTR $T158512[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158512[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158514[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::erase
PUBLIC	??H?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+
PUBLIC	?begin@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::begin
PUBLIC	?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Insert_n
PUBLIC	?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::end
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXIUPassData@D3DShaderTechnique@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T158535 = -64						; size = 8
$T158534 = -56						; size = 8
$T158533 = -48						; size = 8
$T158532 = -40						; size = 8
$T158531 = -32						; size = 8
$T158530 = -24						; size = 8
$T158529 = -16						; size = 8
$T158528 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 12
?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXIUPassData@D3DShaderTechnique@Ogre@@@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T158529[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158528[ebp], ecx
	mov	DWORD PTR $T158528[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T158528[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158528[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Insert_n
	jmp	SHORT $LN4@resize@3
$LN3@resize@3:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T158531[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T158530[ebp], edx
	mov	DWORD PTR $T158530[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T158534[ebp]
	push	edx
	lea	eax, DWORD PTR $T158533[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T158532[ebp], ecx
	mov	DWORD PTR $T158532[ebp+4], edx
	mov	eax, DWORD PTR $T158530[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T158530[ebp]
	push	ecx
	mov	edx, DWORD PTR $T158532[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T158532[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158535[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::erase
$LN4@resize@3:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?resize@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEXIUPassData@D3DShaderTechnique@Ogre@@@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocate
PUBLIC	?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Xlen
PUBLIC	?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6
$LN2@Buy@6:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate
PUBLIC	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158544 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158544[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
__ehhandler$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_val<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@4
$LN3@capacity@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@4:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+
PUBLIC	?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator-
PUBLIC	?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@V?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@ABU_D3DXMACRO@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T158574 = -20						; size = 8
$T158571 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@V?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@ABU_D3DXMACRO@@@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@5
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	lea	eax, DWORD PTR $T158571[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@5:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158574[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@V?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@ABU_D3DXMACRO@@@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::allocate
PUBLIC	?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Xlen
PUBLIC	?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE_NI@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7
$LN2@Buy@7:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::deallocate
PUBLIC	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXXZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::deallocate
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXXZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
PUBLIC	??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z	; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T158583 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z PROC ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T158583[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z ; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z ; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
__ehhandler$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ENDP ; std::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_val<_D3DXMACRO,std::allocator<_D3DXMACRO> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::~_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_D3DXMACRO@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U_D3DXMACRO@@@std@@QAE@XZ PROC		; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_D3DXMACRO@@@std@@QAE@XZ ENDP		; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 464  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator*

; 466  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 			++(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++

; 476  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 477  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@12
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@12
$LN1@operator@12:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@12:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@QAE@ABTShaderEnvKey@Ogre@@ABQAVCompiledShader@3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@QAE@ABTShaderEnvKey@Ogre@@ABQAVCompiledShader@3@@Z PROC ; std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+16], eax

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@QAE@ABTShaderEnvKey@Ogre@@ABQAVCompiledShader@3@@Z ENDP ; std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@TShaderEnvKey@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ShaderEnvKey>::allocator<Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderEnvKey>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderEnvKey>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@TShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@IPAT12@@Z ; std::_Allocate<Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderEnvKey>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@TShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@IPAT12@@Z ; std::_Allocate<Ogre::ShaderEnvKey>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderEnvKey>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UPassDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PassDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UPassDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PassDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PassDesc *,Ogre::PassDesc *>
PUBLIC	??9?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$150095 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$150095[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$150095[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$150095[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PassDesc *,Ogre::PassDesc *>
PUBLIC	??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ; std::fill<Ogre::PassDesc *,Ogre::PassDesc>
PUBLIC	??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>
PUBLIC	?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Ufill
PUBLIC	?capacity@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::capacity
PUBLIC	__$ArrayPad$
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -112						; size = 4
_this$ = -108						; size = 4
__Tmp$150145 = -104					; size = 32
__Oldend$150146 = -72					; size = 4
__Tmp$150135 = -68					; size = 32
__$ArrayPad$ = -36					; size = 4
__Ncopied$150122 = -32					; size = 4
__Newvec$150120 = -28					; size = 4
__Whereoff$150121 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::allocate
	mov	DWORD PTR __Newvec$150120[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR __Whereoff$150121[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150122[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150121[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$150120[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$150122[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$150122[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$150120[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150122[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150122[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$150121[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$150120[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150122[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$150121[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Newvec$150120[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$150120[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150122[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$150121[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$150120[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$150121[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$150120[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$150120[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z ; std::allocator<Ogre::PassDesc>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$150120[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$150120[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150120[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 5
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$150135[ebp]
	rep movsd

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$150135[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	sar	eax, 5
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXPAUPassDesc@Ogre@@0@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$150135[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, edx
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ; std::fill<Ogre::PassDesc *,Ogre::PassDesc>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$150145[ebp]
	rep movsd

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$150146[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150146[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR __Oldend$150146[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150146[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR __Oldend$150146[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150145[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ; std::fill<Ogre::PassDesc *,Ogre::PassDesc>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@IABUPassDesc@Ogre@@@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T158664 = -80						; size = 28
$T158663 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T158664[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T158664[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158663[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T158663[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T158664[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T158664[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0UPassDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PassDesc>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T158730 = -24						; size = 4
$T158729 = -20						; size = 4
$T158728 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UPassDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PassDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T158730[ebp], eax
	mov	ecx, DWORD PTR $T158730[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T158729[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T158729[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T158729[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T158728[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T158728[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T158730[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158729[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UPassDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UPassDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Ogre::PassDesc>::allocator<Ogre::PassDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::PassDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::PassDesc>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::PassDesc>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::PassDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::PassDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UPassDesc@Ogre@@@std@@QAEPAUPassDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::PassDesc>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
_TEXT	ENDS
EXTRN	__imp_?max_size@?$allocator@D@std@@QBEIXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?max_size@?$allocator@D@std@@QBEIXZ

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z	; stdext::unchecked_copy<char *,char *>
PUBLIC	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
PUBLIC	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$150206 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z PROC ; std::vector<char,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$150206[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$150206[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$150206[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ENDP ; std::vector<char,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PADPAD@stdext@@YAPADPAD00@Z ; stdext::_Unchecked_move_backward<char *,char *>
PUBLIC	??$fill@PADD@std@@YAXPAD0ABD@Z			; std::fill<char *,char>
PUBLIC	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
PUBLIC	?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z ; std::vector<char,std::allocator<char> >::_Ufill
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$2
__catchsym$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$0
__unwindtable$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$150256 = -41					; size = 1
__Oldend$150257 = -40					; size = 4
__Tmp$150246 = -33					; size = 1
__Ncopied$150233 = -32					; size = 4
__Newvec$150231 = -28					; size = 4
__Whereoff$150232 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z PROC ; std::vector<char,std::allocator<char> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?allocate@?$allocator@D@std@@QAEPADI@Z
	mov	DWORD PTR __Newvec$150231[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR __Whereoff$150232[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150233[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$150231[ebp]
	add	eax, DWORD PTR __Whereoff$150232[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z ; std::vector<char,std::allocator<char> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$150233[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$150233[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$150231[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150233[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150233[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$150232[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Newvec$150231[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150233[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Newvec$150231[ebp]
	add	edx, DWORD PTR __Whereoff$150232[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$150231[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150233[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Newvec$150231[ebp]
	add	ecx, DWORD PTR __Whereoff$150232[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$150231[ebp]
	add	edx, DWORD PTR __Whereoff$150232[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$150231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$150231[ebp]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Newvec$150231[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newvec$150231[ebp]
	mov	DWORD PTR [ecx+12], edx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$150246[ebp], al

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR __Where$[ebp+4]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$150246[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z ; std::vector<char,std::allocator<char> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$150246[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PADD@std@@YAXPAD0ABD@Z		; std::fill<char *,char>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Tmp$150256[ebp], cl

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$150257[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$150257[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150257[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Umove<char *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$150257[ebp]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150257[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PADPAD@stdext@@YAPADPAD00@Z ; stdext::_Unchecked_move_backward<char *,char *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150256[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PADD@std@@YAXPAD0ABD@Z		; std::fill<char *,char>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@DV?$allocator@D@std@@@std@@IAEXV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@IABD@Z ENDP ; std::vector<char,std::allocator<char> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T158791 = -80						; size = 28
$T158790 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ PROC	; std::vector<char,std::allocator<char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T158791[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T158791[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158790[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T158790[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T158791[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T158791[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T158803 = -24						; size = 4
$T158802 = -20						; size = 4
$T158801 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T158803[ebp], eax
	mov	ecx, DWORD PTR $T158803[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T158802[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T158802[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T158802[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T158801[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T158801[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1:
	mov	eax, DWORD PTR $T158803[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158802[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TechniqueDesc *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::TechniqueDesc *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAUTechniqueDesc@Ogre@@PAPAU12@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
PUBLIC	??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
PUBLIC	??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$150330 = -44					; size = 4
__Oldend$150331 = -40					; size = 4
__Tmp$150320 = -36					; size = 4
__Ncopied$150307 = -32					; size = 4
__Newvec$150305 = -28					; size = 4
__Whereoff$150306 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Xlen
	jmp	$LN16@Insert_n@3
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::allocate
	mov	DWORD PTR __Newvec$150305[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$150306[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150307[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150306[ebp]
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150307[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150307[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$150307[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$150307[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$150306[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>
	jmp	SHORT $LN19@Insert_n@3
__catch$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150307[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$150306[ebp]
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$150305[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150307[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$150306[ebp]
	mov	edx, DWORD PTR __Newvec$150305[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150306[ebp]
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z ; std::allocator<Ogre::TechniqueDesc *>::deallocate
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$150305[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$150305[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150305[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$150320[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$150320[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXPAPAUTechniqueDesc@Ogre@@0@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$150320[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$150330[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$150331[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150331[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$150331[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150331[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$150331[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAUTechniqueDesc@Ogre@@PAPAU12@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150330[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@2@IABQAUTechniqueDesc@Ogre@@@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T158846 = -80						; size = 28
$T158845 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T158846[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T158846[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158845[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T158845[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T158846[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T158846[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Xlen
PUBLIC	??$?0PAUTechniqueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TechniqueDesc *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T158858 = -24						; size = 4
$T158857 = -20						; size = 4
$T158856 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAUTechniqueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TechniqueDesc *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T158858[ebp], eax
	mov	ecx, DWORD PTR $T158858[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T158857[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T158857[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T158857[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T158856[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T158856[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T158858[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158857[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::TechniqueDesc *>::allocator<Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TechniqueDesc *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEXPAPAUTechniqueDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TechniqueDesc *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::TechniqueDesc *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::TechniqueDesc *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QAEPAPAUTechniqueDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::TechniqueDesc *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@TShaderEnvKey@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderEnvKey>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@TShaderEnvKey@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderEnvKey>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PATShaderEnvKey@Ogre@@PAT12@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00@Z ; stdext::_Unchecked_move_backward<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
PUBLIC	??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ; std::fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
PUBLIC	??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -80						; size = 4
_this$ = -76						; size = 4
__Tmp$150416 = -72					; size = 16
__Oldend$150417 = -52					; size = 4
__Tmp$150406 = -48					; size = 16
__Ncopied$150393 = -32					; size = 4
__Newvec$150391 = -28					; size = 4
__Whereoff$150392 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Xlen
	jmp	$LN16@Insert_n@4
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@4:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::allocate
	mov	DWORD PTR __Newvec$150391[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR __Whereoff$150392[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150393[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150392[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$150391[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$150393[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$150393[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$150391[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150393[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150393[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$150392[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$150391[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>
	jmp	SHORT $LN19@Insert_n@4
__catch$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150393[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$150392[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$150391[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$150391[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150393[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$150392[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$150391[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$150392[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$150391[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$150391[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@I@Z ; std::allocator<Ogre::ShaderEnvKey>::deallocate
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$150391[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$150391[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150391[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 4
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$150406[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$150406[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$150406[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$150406[ebp+12], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$150406[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	sar	eax, 4
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT34@IABT34@@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXPATShaderEnvKey@Ogre@@0@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$150406[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, edx
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ; std::fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$150416[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$150416[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$150416[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$150416[ebp+12], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$150417[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150417[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR __Oldend$150417[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150417[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Oldend$150417[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PATShaderEnvKey@Ogre@@PAT12@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00@Z ; stdext::_Unchecked_move_backward<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150416[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ; std::fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@2@IABTShaderEnvKey@Ogre@@@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T158907 = -80						; size = 28
$T158906 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T158907[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T158907[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158906[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T158906[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T158907[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T158907[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Xlen
PUBLIC	??$?0TShaderEnvKey@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderEnvKey>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T158919 = -24						; size = 4
$T158918 = -20						; size = 4
$T158917 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0TShaderEnvKey@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@TShaderEnvKey@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderEnvKey>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T158919[ebp], eax
	mov	ecx, DWORD PTR $T158919[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T158918[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T158918[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T158918[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T158917[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T158917[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T158919[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158918[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAE@V?$allocator@TShaderEnvKey@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCompiledShader@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::CompiledShader *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVCompiledShader@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::CompiledShader *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVCompiledShader@Ogre@@PAPAV12@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
PUBLIC	??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
PUBLIC	??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$150490 = -44					; size = 4
__Oldend$150491 = -40					; size = 4
__Tmp$150480 = -36					; size = 4
__Ncopied$150467 = -32					; size = 4
__Newvec$150465 = -28					; size = 4
__Whereoff$150466 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Xlen
	jmp	$LN16@Insert_n@5
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@5:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::allocate
	mov	DWORD PTR __Newvec$150465[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$150466[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150467[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150466[ebp]
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150467[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150467[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$150467[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$150467[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$150466[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>
	jmp	SHORT $LN19@Insert_n@5
__catch$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150467[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$150466[ebp]
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$150465[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150467[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$150466[ebp]
	mov	edx, DWORD PTR __Newvec$150465[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150466[ebp]
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z ; std::allocator<Ogre::CompiledShader *>::deallocate
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$150465[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$150465[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150465[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$150480[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$150480[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXPAPAVCompiledShader@Ogre@@0@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$150480[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$150490[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$150491[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$150491[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$150491[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150491[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$150491[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVCompiledShader@Ogre@@PAPAV12@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150490[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@2@IABQAVCompiledShader@Ogre@@@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T158962 = -80						; size = 28
$T158961 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T158962[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T158962[ebp]
	push	eax
	lea	ecx, DWORD PTR $T158961[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T158961[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T158962[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T158962[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Xlen
PUBLIC	??$?0PAVCompiledShader@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CompiledShader *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T158974 = -24						; size = 4
$T158973 = -20						; size = 4
$T158972 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVCompiledShader@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCompiledShader@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CompiledShader *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T158974[ebp], eax
	mov	ecx, DWORD PTR $T158974[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T158973[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T158973[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T158973[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T158972[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T158972[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T158974[ebp]
	push	eax
	mov	ecx, DWORD PTR $T158973[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAE@V?$allocator@PAVCompiledShader@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVCompiledShader@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::CompiledShader *>::allocator<Ogre::CompiledShader *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z PROC ; std::allocator<Ogre::CompiledShader *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEXPAPAVCompiledShader@Ogre@@I@Z ENDP ; std::allocator<Ogre::CompiledShader *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::CompiledShader *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z PROC ; std::allocator<Ogre::CompiledShader *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::CompiledShader *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVCompiledShader@Ogre@@@std@@QAEPAPAVCompiledShader@Ogre@@I@Z ENDP ; std::allocator<Ogre::CompiledShader *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 41					; 00000029H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::size
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
_TEXT	SEGMENT
tv90 = -76						; size = 4
_this$ = -72						; size = 4
$T159014 = -65						; size = 1
$T159013 = -64						; size = 8
$T159012 = -53						; size = 1
$T159011 = -52						; size = 8
$T159010 = -41						; size = 1
$T159009 = -40						; size = 8
$T159008 = -32						; size = 8
$T159007 = -21						; size = 1
__Where$150577 = -20					; size = 8
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Trynode$[ebp], eax

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1
$LN10@insert@6:

; 634  : 		while (!_Isnil(_Trynode))

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@insert@6

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	mov	BYTE PTR __Addleft$[ebp], al

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN13@insert@6
	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	jmp	SHORT $LN14@insert@6
$LN13@insert@6:
	mov	edx, DWORD PTR __Trynode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], eax
$LN14@insert@6:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], ecx

; 640  : 			}

	jmp	SHORT $LN10@insert@6
$LN9@insert@6:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	edx, edx
	je	SHORT $LN8@insert@6

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T159007[ebp], 1
	lea	eax, DWORD PTR $T159007[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159008[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@6

; 644  : 		else

	jmp	$LN11@insert@6
$LN8@insert@6:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$150577[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator

; 647  : 			if (!_Addleft)

	movzx	ecx, BYTE PTR __Addleft$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@insert@6
	jmp	SHORT $LN5@insert@6
$LN6@insert@6:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	lea	edx, DWORD PTR $T159009[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$150577[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@insert@6

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T159010[ebp], 1
	lea	ecx, DWORD PTR $T159010[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T159011[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@6

; 651  : 			else

	jmp	SHORT $LN5@insert@6
$LN4@insert@6:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$150577[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator--
$LN5@insert@6:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$150577[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@insert@6

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T159012[ebp], 1
	lea	ecx, DWORD PTR $T159012[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Addleft$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T159013[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@6

; 657  : 			else

	jmp	SHORT $LN11@insert@6
$LN2@insert@6:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T159014[ebp], 0
	lea	eax, DWORD PTR $T159014[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$150577[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@6:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T159020 = -32						; size = 8
$T159019 = -24						; size = 8
$T159018 = -16						; size = 8
$T159017 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T159017[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@3
	lea	edx, DWORD PTR $T159018[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@3

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@3
$LN2@erase@3:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@3

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T159019[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T159020[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase
	jmp	SHORT $LN2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::max_size
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T159026 = -88						; size = 28
$T159025 = -60						; size = 40
__Pnode$150625 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::max_size
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+28]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T159026[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T159026[ebp]
	push	edx
	lea	ecx, DWORD PTR $T159025[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T159025[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159026[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 1194 : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$150625[ebp], edx
$LN10@Insert:
	mov	eax, DWORD PTR __Pnode$150625[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	$LN9@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	eax, DWORD PTR __Pnode$150625[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$150625[ebp], ecx

; 1222 : 					}
; 1223 : 				else

	jmp	$LN6@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$150625[ebp], eax

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$150625[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	$LN4@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$150625[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$150625[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$150625[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN10@Insert
$LN9@Insert:

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z$0:
	lea	ecx, DWORD PTR $T159026[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABTShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABTShaderEnvKey@Ogre@@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Wherenode$[ebp], edx
$LN4@Lbound:

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAABTShaderEnvKey@Ogre@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@TShaderEnvKey@Ogre@@@std@@QBE_NABTShaderEnvKey@Ogre@@0@Z ; std::less<Ogre::ShaderEnvKey>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN4@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABTShaderEnvKey@Ogre@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lbound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159040 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159040[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_val<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z PROC ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn, COMDAT

; 64   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 66   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@SAABTShaderEnvKey@Ogre@@ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@@Z ENDP ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Kfn
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DShaderTechnique::PassData>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DShaderTechnique::PassData>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
PUBLIC	??9?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator!=
PUBLIC	?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$150682 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$150682[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$150682[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$150682[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::erase
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
PUBLIC	??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ; std::fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
PUBLIC	??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>
PUBLIC	?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Ufill
PUBLIC	?capacity@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::capacity
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -68						; size = 4
_this$ = -64						; size = 4
__Tmp$150732 = -60					; size = 12
__Oldend$150733 = -48					; size = 4
__Tmp$150722 = -44					; size = 12
__Ncopied$150709 = -32					; size = 4
__Newvec$150707 = -28					; size = 4
__Whereoff$150708 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@6
	jmp	$LN16@Insert_n@6
$LN14@Insert_n@6:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Xlen
	jmp	$LN16@Insert_n@6
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@6:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocate
	mov	DWORD PTR __Newvec$150707[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Whereoff$150708[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150709[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$150708[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$150707[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$150709[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$150709[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR __Newvec$150707[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$150709[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$150709[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$150708[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$150707[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>
	jmp	SHORT $LN19@Insert_n@6
__catch$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150709[ebp], 1
	jle	SHORT $LN7@Insert_n@6

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$150708[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$150707[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$150707[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150709[ebp], 0
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Whereoff$150708[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Newvec$150707[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR __Whereoff$150708[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$150707[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$150707[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate
$LN5@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Newvec$150707[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Newvec$150707[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150707[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@6
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$150722[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$150722[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$150722[ebp+8], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$150722[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Ufill
	jmp	SHORT $LN21@Insert_n@6
__catch$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$150722[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ; std::fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@6
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$150732[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$150732[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$150732[ebp+8], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$150733[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$150733[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR __Oldend$150733[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150733[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR __Oldend$150733[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150732[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ; std::fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@IABUPassData@D3DShaderTechnique@Ogre@@@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T159092 = -80						; size = 28
$T159091 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T159092[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T159092[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159091[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T159091[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159092[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T159092[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Xlen
PUBLIC	??$?0UPassData@D3DShaderTechnique@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DShaderTechnique::PassData>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T159104 = -24						; size = 4
$T159103 = -20						; size = 4
$T159102 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UPassData@D3DShaderTechnique@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DShaderTechnique::PassData>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T159104[ebp], eax
	mov	ecx, DWORD PTR $T159104[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T159103[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T159103[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159103[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T159102[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T159102[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T159104[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159103[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAE@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocator<Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::D3DShaderTechnique::PassData>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEPAUPassData@D3DShaderTechnique@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@XZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U_D3DXMACRO@@@std@@QBEIXZ	; std::allocator<_D3DXMACRO>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@U_D3DXMACRO@@@std@@QBEIXZ ; std::allocator<_D3DXMACRO>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@@Z ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@@Z ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAU_D3DXMACRO@@PAU1@@stdext@@YAPAU_D3DXMACRO@@PAU1@00@Z ; stdext::_Unchecked_move_backward<_D3DXMACRO *,_D3DXMACRO *>
PUBLIC	??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ; std::fill<_D3DXMACRO *,_D3DXMACRO>
PUBLIC	??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$2
__catchsym$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$0
__unwindtable$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$150818 = -52					; size = 8
__Oldend$150819 = -44					; size = 4
__Tmp$150808 = -40					; size = 8
__Ncopied$150795 = -32					; size = 4
__Newvec$150793 = -28					; size = 4
__Whereoff$150794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@7
	jmp	$LN16@Insert_n@7
$LN14@Insert_n@7:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Xlen
	jmp	$LN16@Insert_n@7
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@7:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::allocate
	mov	DWORD PTR __Newvec$150793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$150794[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$150795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150794[ebp]
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$150795[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$150795[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$150795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$150795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$150794[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>
	jmp	SHORT $LN19@Insert_n@7
__catch$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150795[ebp], 1
	jle	SHORT $LN7@Insert_n@7

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$150794[ebp]
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$150793[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy
$LN7@Insert_n@7:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$150795[ebp], 0
	jle	SHORT $LN6@Insert_n@7

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$150794[ebp]
	mov	edx, DWORD PTR __Newvec$150793[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$150794[ebp]
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy
$LN6@Insert_n@7:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$1
	ret	0
$LN19@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEIXZ ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z ; std::allocator<_D3DXMACRO>::deallocate
$LN5@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$150793[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$150793[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$150793[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@7
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$150808[ebp], ecx
	mov	DWORD PTR __Tmp$150808[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$150808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU3@IABU3@@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Ufill
	jmp	SHORT $LN21@Insert_n@7
__catch$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXPAU_D3DXMACRO@@0@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$3
	ret	0
$LN21@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$150808[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ; std::fill<_D3DXMACRO *,_D3DXMACRO>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@7
$LN3@Insert_n@7:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$150818[ebp], eax
	mov	DWORD PTR __Tmp$150818[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$150819[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$150819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$150819[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$150819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$150819[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAU_D3DXMACRO@@PAU1@@stdext@@YAPAU_D3DXMACRO@@PAU1@00@Z ; stdext::_Unchecked_move_backward<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$150818[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ; std::fill<_D3DXMACRO *,_D3DXMACRO>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@7:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@2@IABU_D3DXMACRO@@@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T159153 = -80						; size = 28
$T159152 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T159153[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T159153[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159152[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T159152[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159153[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T159153[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@KAXXZ ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Xlen
PUBLIC	??$?0U_D3DXMACRO@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DXMACRO@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DXMACRO>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T159165 = -24						; size = 4
$T159164 = -20						; size = 4
$T159163 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U_D3DXMACRO@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DXMACRO@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DXMACRO>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T159165[ebp], eax
	mov	ecx, DWORD PTR $T159165[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T159164[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T159164[ebp], 0
	je	SHORT $LN3@Container_@7
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159164[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@7
$LN3@Container_@7:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@7:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T159163[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T159163[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z$1:
	mov	eax, DWORD PTR $T159165[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159164[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAE@V?$allocator@U_D3DXMACRO@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >::_Container_base_aux_alloc_real<std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z PROC	; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U_D3DXMACRO@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<_D3DXMACRO>::allocator<_D3DXMACRO>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z PROC ; std::allocator<_D3DXMACRO>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@I@Z ENDP ; std::allocator<_D3DXMACRO>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@IPAU1@@Z ; std::_Allocate<_D3DXMACRO>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z PROC ; std::allocator<_D3DXMACRO>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@IPAU1@@Z ; std::_Allocate<_D3DXMACRO>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_D3DXMACRO@@@std@@QAEPAU_D3DXMACRO@@I@Z ENDP ; std::allocator<_D3DXMACRO>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 249  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@13:

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@13:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Myval@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Myval
	add	esp, 4

; 265  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			_Dec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 289  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@14
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@15
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@15
$LN1@operator@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@16
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@17
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@17
$LN1@operator@17:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@17:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<char,std::allocator<char> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@DV?$allocator@D@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@DV?$allocator@D@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<char,std::allocator<char> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@DV?$allocator@D@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>::_Bidit<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *>,int,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const *,std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@TShaderEnvKey@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@TShaderEnvKey@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ShaderEnvKey>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@TShaderEnvKey@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ShaderEnvKey>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@5
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@5
$LN3@capacity@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@5:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU34@IABU34@@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Ufill
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UPassDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UPassDesc@Ogre@@@std@@QBEIXZ PROC	; std::allocator<Ogre::PassDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 134217727	; 07ffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UPassDesc@Ogre@@@std@@QBEIXZ ENDP	; std::allocator<Ogre::PassDesc>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@6
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@capacity@6
$LN3@capacity@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv69[ebp], eax
$LN4@capacity@6:
	mov	eax, DWORD PTR tv69[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PADIDV?$allocator@D@std@@@stdext@@YAXPADIABDAAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_fill_n<char *,unsigned int,char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z PROC ; std::vector<char,std::allocator<char> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PADIDV?$allocator@D@std@@@stdext@@YAXPADIABDAAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_fill_n<char *,unsigned int,char,std::allocator<char> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@DV?$allocator@D@std@@@std@@IAEPADPADIABD@Z ENDP ; std::vector<char,std::allocator<char> >::_Ufill
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::TechniqueDesc *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUTechniqueDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::TechniqueDesc *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVCompiledShader@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVCompiledShader@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::CompiledShader *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVCompiledShader@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::CompiledShader *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 40					; 00000028H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T159283 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T159283[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QBEIXZ ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 605  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?max_size@?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QBEIXZ ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::max_size

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::destroy
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Min
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T159289 = -96						; size = 28
$T159288 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@5

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T159289[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T159289[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T159288[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T159288[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159289[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@5:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@5

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@5
$LN39@erase@5:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@5

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@5
$LN37@erase@5:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@5:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@5

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@5

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@5:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@5

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@5
$LN33@erase@5:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@5

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@5
$LN31@erase@5:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@5:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@5

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@5
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@5
$LN43@erase@5:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@5:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@5

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@5
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@5
$LN45@erase@5:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@5:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@5
$LN35@erase@5:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@5

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@5
$LN26@erase@5:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@5

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@5:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@5:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@5

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@5
$LN23@erase@5:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@5

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@5
$LN21@erase@5:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@5:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@5:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@5

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@5
$LN17@erase@5:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@5
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@5

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@5

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@5

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@5:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@5

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@5
$LN13@erase@5:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@5
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@5

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@5
$LN11@erase@5:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@5

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@5:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@5
$LN12@erase@5:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@5
$LN15@erase@5:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@5

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@5:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@5

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@5
$LN6@erase@5:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@5
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@5

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@5
$LN4@erase@5:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@5

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@5:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@5
$LN8@erase@5:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@5
$LN16@erase@5:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@5:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@5

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@5:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@5:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T159289[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::erase
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1out_of_range@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1out_of_range@std@@UAE@XZ$0
__ehfuncinfo$??1out_of_range@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1out_of_range@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1out_of_range@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1out_of_range@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1out_of_range@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T159342 = -36						; size = 4
$T159341 = -32						; size = 4
$T159340 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T159340[ebp], 0
	lea	eax, DWORD PTR $T159340[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T159341[ebp], 0
	lea	eax, DWORD PTR $T159341[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T159342[ebp], 0
	lea	eax, DWORD PTR $T159342[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy
$LN2@Buynode:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::destroy
$LN1@Buynode:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T159359 = -28						; size = 4
$T159358 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	48					; 00000030H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T159359[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T159359[ebp], 0
	je	SHORT $LN4@Buynode@2
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159359[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T159358[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159359[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159378 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159378[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_ptr<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@7
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@7
$LN3@capacity@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@7:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Ufill
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 357913941	; 15555555H

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U_D3DXMACRO@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U_D3DXMACRO@@@std@@QBEIXZ PROC	; std::allocator<_D3DXMACRO>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U_D3DXMACRO@@@std@@QBEIXZ ENDP	; std::allocator<_D3DXMACRO>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator--

; 489  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 490  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$151287 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@Dec
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN10@Dec:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 336  :    				if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@Dec:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}

	jmp	$LN11@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Max
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 352  : 			else

	jmp	SHORT $LN11@Dec
$LN4@Dec:

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$151287[ebp], ecx
	mov	edx, DWORD PTR __Pnode$151287[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Dec
	mov	ecx, DWORD PTR __Pnode$151287[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$151287[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN11@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$151287[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN11@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$151303 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$151303[ebp], edx
	mov	eax, DWORD PTR __Pnode$151303[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$151303[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$151303[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$151303[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAUTechniqueDesc@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ; std::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAUTechniqueDesc@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAE@PAPAUTechniqueDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@TShaderEnvKey@Ogre@@HPBT12@ABT12@@std@@QAE@XZ ; std::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@TShaderEnvKey@Ogre@@HPBT12@ABT12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAE@PATShaderEnvKey@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVCompiledShader@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVCompiledShader@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAE@PAPAVCompiledShader@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@U_D3DXMACRO@@HPBU1@ABU1@@std@@QAE@XZ ; std::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@U_D3DXMACRO@@HPBU1@ABU1@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@4
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@4
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAE@PAU_D3DXMACRO@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+8], al

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUTechniqueDesc@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAUTechniqueDesc@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAUTechniqueDesc@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUTechniqueDesc@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAUTechniqueDesc@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>::_Ranit<Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@TShaderEnvKey@Ogre@@HPBT34@ABT34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@TShaderEnvKey@Ogre@@HPBT12@ABT12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@TShaderEnvKey@Ogre@@HPBT12@ABT12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@TShaderEnvKey@Ogre@@HPBT34@ABT34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@TShaderEnvKey@Ogre@@HPBT12@ABT12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>::_Ranit<Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCompiledShader@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVCompiledShader@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVCompiledShader@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCompiledShader@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVCompiledShader@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>::_Ranit<Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DXMACRO@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@U_D3DXMACRO@@HPBU1@ABU1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@U_D3DXMACRO@@HPBU1@ABU1@@std@@QAE@XZ PROC	; std::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DXMACRO@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@U_D3DXMACRO@@HPBU1@ABU1@@std@@QAE@XZ ENDP	; std::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>::_Ranit<_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUTechniqueDesc@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUTechniqueDesc@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUTechniqueDesc@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::TechniqueDesc *,int,Ogre::TechniqueDesc * const *,Ogre::TechniqueDesc * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@TShaderEnvKey@Ogre@@HPBT34@ABT34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@TShaderEnvKey@Ogre@@HPBT34@ABT34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@TShaderEnvKey@Ogre@@HPBT34@ABT34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderEnvKey,int,Ogre::ShaderEnvKey const *,Ogre::ShaderEnvKey const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCompiledShader@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCompiledShader@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVCompiledShader@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CompiledShader *,int,Ogre::CompiledShader * const *,Ogre::CompiledShader * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DXMACRO@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DXMACRO@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DXMACRO@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DXMACRO,int,_D3DXMACRO const *,_D3DXMACRO const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$151435 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$151435[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$151435[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$151435[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$151435[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$151435[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$151435[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
PUBLIC	??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159470 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159470[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 178956970	; 0aaaaaaaH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@7
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@7
$LN3@max_size@7:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@18
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@18:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@18
$LN1@operator@18:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@19
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@19:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@19
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@19
$LN1@operator@19:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@19:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@20
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@20:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@20
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@20
$LN1@operator@20:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@20:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@21
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@21:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@21
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@21
$LN1@operator@21:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@21:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<_D3DXMACRO,std::allocator<_D3DXMACRO> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UPassDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UPassDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@5
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@5
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAE@PAUPassDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@22
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@22:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@22
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@22
$LN1@operator@22:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@22:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@23
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@23
$LN1@operator@23:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@23:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Ranit@DHPBDABD@std@@QAE@XZ		; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@DHPBDABD@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@6
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@6
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@24
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@24:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@24
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@24
$LN1@operator@24:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@24:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@25
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@25
$LN1@operator@25:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@25:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UPassData@D3DShaderTechnique@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UPassData@D3DShaderTechnique@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@7
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@7
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAE@PAUPassData@D3DShaderTechnique@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@26
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@26:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@26
	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@26
$LN1@operator@26:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@26:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@27
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@27
$LN1@operator@27:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@27:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+40], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+41], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UPassDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UPassDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UPassDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>::_Ranit<Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@DHPBDABD@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@DHPBDABD@std@@QAE@XZ PROC			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@DHPBDABD@std@@QAE@XZ ENDP			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassData@D3DShaderTechnique@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UPassData@D3DShaderTechnique@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UPassData@D3DShaderTechnique@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassData@D3DShaderTechnique@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UPassData@D3DShaderTechnique@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>::_Ranit<Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PassDesc,int,Ogre::PassDesc const *,Ogre::PassDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassData@D3DShaderTechnique@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassData@D3DShaderTechnique@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPassData@D3DShaderTechnique@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DShaderTechnique::PassData,int,Ogre::D3DShaderTechnique::PassData const *,Ogre::D3DShaderTechnique::PassData const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159530 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159530[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
__ehhandler$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@QAE@U?$less@TShaderEnvKey@Ogre@@@1@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0>
PUBLIC	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T159542 = -24						; size = 4
$T159541 = -20						; size = 4
$T159540 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T159542[ebp], eax
	mov	ecx, DWORD PTR $T159542[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T159541[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T159541[ebp], 0
	je	SHORT $LN3@Container_@8
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159541[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@8
$LN3@Container_@8:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@8:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T159540[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T159540[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T159542[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159541[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> > >
EXTRN	__imp___vsnprintf_s:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__MaxCount$ = 12					; size = 4
__Format$ = 16						; size = 4
??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ PROC		; _snprintf_s<256>, COMDAT

; 318  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snprintf_s, _vsnprintf_s, char, _Dest, _In_ size_t, _MaxCount, _In_z_ _Printf_format_string_ const char *,_Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __MaxCount$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp___vsnprintf_s
	add	esp, 20					; 00000014H
	mov	esp, ebp
	pop	ebp
	ret	0
??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ENDP		; _snprintf_s<256>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
PUBLIC	??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159558 = -2						; size = 1
$T159557 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159557[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 8
	mov	BYTE PTR $T159558[ebp], al
	movzx	eax, BYTE PTR $T159557[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159558[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
PUBLIC	??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159562 = -2						; size = 1
$T159561 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159561[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 8
	mov	BYTE PTR $T159562[ebp], al
	movzx	eax, BYTE PTR $T159561[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159562[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
PUBLIC	??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159566 = -2						; size = 1
$T159565 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159565[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 8
	mov	BYTE PTR $T159566[ebp], al
	movzx	eax, BYTE PTR $T159565[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159566[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@std@@@Z
_TEXT	SEGMENT
$T159570 = -2						; size = 1
$T159569 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159569[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 8
	mov	BYTE PTR $T159570[ebp], al
	movzx	eax, BYTE PTR $T159569[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159570[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@TShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@IPAT12@@Z
_TEXT	SEGMENT
$T159573 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@TShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@IPAT12@@Z PROC ; std::_Allocate<Ogre::ShaderEnvKey>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159573[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159573[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@TShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@IPAT12@@Z ENDP ; std::_Allocate<Ogre::ShaderEnvKey>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *>
PUBLIC	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
PUBLIC	??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::PassDesc *,Ogre::PassDesc *>
PUBLIC	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T159598 = -3						; size = 1
$T159597 = -2						; size = 1
$T159596 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159596[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 8
	mov	BYTE PTR $T159597[ebp], al
	movzx	eax, BYTE PTR $T159596[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159597[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159598[ebp]
	push	ecx
	call	??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::PassDesc *,Ogre::PassDesc *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T159601 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 8
	mov	BYTE PTR $T159601[ebp], al
	movzx	edx, BYTE PTR $T159601[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUPassDesc@Ogre@@@?$vector@UPassDesc@Ogre@@V?$allocator@UPassDesc@Ogre@@@std@@@std@@IAEPAUPassDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::PassDesc,std::allocator<Ogre::PassDesc> >::_Umove<Ogre::PassDesc *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::PassDesc *,Ogre::PassDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z PROC ; std::fill<Ogre::PassDesc *,Ogre::PassDesc>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::PassDesc *,Ogre::PassDesc>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ENDP ; std::fill<Ogre::PassDesc *,Ogre::PassDesc>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUPassDesc@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z ; std::_Move_cat<Ogre::PassDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T159610 = -3						; size = 1
$T159609 = -2						; size = 1
$T159608 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159608[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z ; std::_Move_cat<Ogre::PassDesc *>
	add	esp, 4
	mov	BYTE PTR $T159609[ebp], al
	movzx	edx, BYTE PTR $T159608[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159609[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159610[ebp]
	push	eax
	call	??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUPassDesc@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUPassDesc@Ogre@@PAU12@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::PassDesc *,Ogre::PassDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UPassDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UPassDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PassDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UPassDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PassDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T159615 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::PassDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159615[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159615[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::PassDesc>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPAD@Z		; std::_Checked_base<char *>
PUBLIC	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
PUBLIC	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z
_TEXT	SEGMENT
$T159620 = -3						; size = 1
$T159619 = -2						; size = 1
$T159618 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z PROC	; stdext::unchecked_copy<char *,char *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159618[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T159619[ebp], al
	movzx	eax, BYTE PTR $T159618[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159619[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159620[ebp]
	push	ecx
	call	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ENDP	; stdext::unchecked_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T159623 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T159623[ebp], al
	movzx	edx, BYTE PTR $T159623[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::_Unchecked_uninitialized_move<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Umove<char *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::_Unchecked_uninitialized_move<char *,char *,std::allocator<char> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Umove<char *>
_TEXT	ENDS
PUBLIC	??$_Fill@PADD@std@@YAXPAD0ABD@Z			; std::_Fill<char *,char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PADD@std@@YAXPAD0ABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PADD@std@@YAXPAD0ABD@Z PROC			; std::fill<char *,char>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Fill@PADD@std@@YAXPAD0ABD@Z		; std::_Fill<char *,char>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PADD@std@@YAXPAD0ABD@Z ENDP			; std::fill<char *,char>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PADPADUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<char *,char *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z ; std::_Move_cat<char *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PADPAD@stdext@@YAPADPAD00@Z
_TEXT	SEGMENT
$T159632 = -3						; size = 1
$T159631 = -2						; size = 1
$T159630 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PADPAD@stdext@@YAPADPAD00@Z PROC ; stdext::_Unchecked_move_backward<char *,char *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159630[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z ; std::_Move_cat<char *>
	add	esp, 4
	mov	BYTE PTR $T159631[ebp], al
	movzx	edx, BYTE PTR $T159630[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159631[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159632[ebp]
	push	eax
	call	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PADPADUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<char *,char *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PADPAD@stdext@@YAPADPAD00@Z ENDP ; stdext::_Unchecked_move_backward<char *,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T159637 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 8
	mov	BYTE PTR $T159637[ebp], al
	movzx	edx, BYTE PTR $T159637[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z PROC ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUTechniqueDesc@Ogre@@@?$vector@PAUTechniqueDesc@Ogre@@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@IAEPAPAUTechniqueDesc@Ogre@@PAPAU23@00@Z ENDP ; std::vector<Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >::_Umove<Ogre::TechniqueDesc * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
PUBLIC	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z PROC ; std::fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ENDP ; std::fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
PUBLIC	??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ; std::_Move_cat<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAUTechniqueDesc@Ogre@@PAPAU12@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00@Z
_TEXT	SEGMENT
$T159646 = -3						; size = 1
$T159645 = -2						; size = 1
$T159644 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAUTechniqueDesc@Ogre@@PAPAU12@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159644[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ; std::_Move_cat<Ogre::TechniqueDesc * *>
	add	esp, 4
	mov	BYTE PTR $T159645[ebp], al
	movzx	edx, BYTE PTR $T159644[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159645[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159646[ebp]
	push	eax
	call	??$_Iter_random@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAUTechniqueDesc@Ogre@@PAPAU12@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAUTechniqueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUTechniqueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TechniqueDesc *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUTechniqueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUTechniqueDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@IPAPAU12@@Z
_TEXT	SEGMENT
$T159651 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@IPAPAU12@@Z PROC ; std::_Allocate<Ogre::TechniqueDesc *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159651[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159651[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@IPAPAU12@@Z ENDP ; std::_Allocate<Ogre::TechniqueDesc *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@@Z
_TEXT	SEGMENT
$T159654 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 8
	mov	BYTE PTR $T159654[ebp], al
	movzx	edx, BYTE PTR $T159654[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z PROC ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PATShaderEnvKey@Ogre@@@?$vector@TShaderEnvKey@Ogre@@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@IAEPATShaderEnvKey@Ogre@@PAT23@00@Z ENDP ; std::vector<Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >::_Umove<Ogre::ShaderEnvKey *>
_TEXT	ENDS
PUBLIC	??$_Fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ; std::_Fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
PUBLIC	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z PROC ; std::fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	call	??$_Fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ; std::_Fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ENDP ; std::fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AUrandom_access_iterator_tag@0@ABQATShaderEnvKey@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
PUBLIC	??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z ; std::_Move_cat<Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PATShaderEnvKey@Ogre@@PAT12@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00@Z
_TEXT	SEGMENT
$T159663 = -3						; size = 1
$T159662 = -2						; size = 1
$T159661 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PATShaderEnvKey@Ogre@@PAT12@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159661[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z ; std::_Move_cat<Ogre::ShaderEnvKey *>
	add	esp, 4
	mov	BYTE PTR $T159662[ebp], al
	movzx	edx, BYTE PTR $T159661[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159662[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159663[ebp]
	push	eax
	call	??$_Iter_random@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AUrandom_access_iterator_tag@0@ABQATShaderEnvKey@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PATShaderEnvKey@Ogre@@PAT12@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0TShaderEnvKey@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@TShaderEnvKey@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0TShaderEnvKey@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@TShaderEnvKey@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderEnvKey>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0TShaderEnvKey@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@TShaderEnvKey@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderEnvKey>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@@Z
_TEXT	SEGMENT
$T159668 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 8
	mov	BYTE PTR $T159668[ebp], al
	movzx	edx, BYTE PTR $T159668[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVCompiledShader@Ogre@@@?$vector@PAVCompiledShader@Ogre@@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@IAEPAPAVCompiledShader@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >::_Umove<Ogre::CompiledShader * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
PUBLIC	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@0@Z ; std::_Iter_random<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
PUBLIC	??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ; std::_Move_cat<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVCompiledShader@Ogre@@PAPAV12@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T159677 = -3						; size = 1
$T159676 = -2						; size = 1
$T159675 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVCompiledShader@Ogre@@PAPAV12@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::CompiledShader * *,Ogre::CompiledShader * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159675[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ; std::_Move_cat<Ogre::CompiledShader * *>
	add	esp, 4
	mov	BYTE PTR $T159676[ebp], al
	movzx	edx, BYTE PTR $T159675[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159676[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159677[ebp]
	push	eax
	call	??$_Iter_random@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@0@Z ; std::_Iter_random<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVCompiledShader@Ogre@@PAPAV12@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVCompiledShader@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCompiledShader@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVCompiledShader@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCompiledShader@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CompiledShader *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVCompiledShader@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVCompiledShader@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CompiledShader *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T159682 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::CompiledShader *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159682[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159682[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::CompiledShader *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
PUBLIC	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
PUBLIC	??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
PUBLIC	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T159689 = -3						; size = 1
$T159688 = -2						; size = 1
$T159687 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159687[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8
	mov	BYTE PTR $T159688[ebp], al
	movzx	eax, BYTE PTR $T159687[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159688[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159689[ebp]
	push	ecx
	call	??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@@Z
_TEXT	SEGMENT
$T159692 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8
	mov	BYTE PTR $T159692[ebp], al
	movzx	edx, BYTE PTR $T159692[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUPassData@D3DShaderTechnique@Ogre@@@?$vector@UPassData@D3DShaderTechnique@Ogre@@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@IAEPAUPassData@D3DShaderTechnique@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >::_Umove<Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::_Move_cat<Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T159701 = -3						; size = 1
$T159700 = -2						; size = 1
$T159699 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159699[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::_Move_cat<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	mov	BYTE PTR $T159700[ebp], al
	movzx	edx, BYTE PTR $T159699[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159700[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159701[ebp]
	push	eax
	call	??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UPassData@D3DShaderTechnique@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UPassData@D3DShaderTechnique@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DShaderTechnique::PassData>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UPassData@D3DShaderTechnique@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T159706 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::D3DShaderTechnique::PassData>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159706[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159706[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::D3DShaderTechnique::PassData>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@@Z
_TEXT	SEGMENT
$T159709 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_D3DXMACRO> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 8
	mov	BYTE PTR $T159709[ebp], al
	movzx	edx, BYTE PTR $T159709[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z PROC ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAU_D3DXMACRO@@@?$vector@U_D3DXMACRO@@V?$allocator@U_D3DXMACRO@@@std@@@std@@IAEPAU_D3DXMACRO@@PAU2@00@Z ENDP ; std::vector<_D3DXMACRO,std::allocator<_D3DXMACRO> >::_Umove<_D3DXMACRO *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ; std::_Fill<_D3DXMACRO *,_D3DXMACRO>
PUBLIC	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z PROC ; std::fill<_D3DXMACRO *,_D3DXMACRO>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ; std::_Fill<_D3DXMACRO *,_D3DXMACRO>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ENDP ; std::fill<_D3DXMACRO *,_D3DXMACRO>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAU_D3DXMACRO@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAU_D3DXMACRO@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DXMACRO@@0@Z ; std::_Iter_random<_D3DXMACRO *,_D3DXMACRO *>
PUBLIC	??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z ; std::_Move_cat<_D3DXMACRO *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAU_D3DXMACRO@@PAU1@@stdext@@YAPAU_D3DXMACRO@@PAU1@00@Z
_TEXT	SEGMENT
$T159718 = -3						; size = 1
$T159717 = -2						; size = 1
$T159716 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAU_D3DXMACRO@@PAU1@@stdext@@YAPAU_D3DXMACRO@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<_D3DXMACRO *,_D3DXMACRO *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159716[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z ; std::_Move_cat<_D3DXMACRO *>
	add	esp, 4
	mov	BYTE PTR $T159717[ebp], al
	movzx	edx, BYTE PTR $T159716[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159717[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T159718[ebp]
	push	eax
	call	??$_Iter_random@PAU_D3DXMACRO@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DXMACRO@@0@Z ; std::_Iter_random<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAU_D3DXMACRO@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAU_D3DXMACRO@@PAU1@@stdext@@YAPAU_D3DXMACRO@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<_D3DXMACRO *,_D3DXMACRO *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U_D3DXMACRO@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DXMACRO@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U_D3DXMACRO@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DXMACRO@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DXMACRO>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U_D3DXMACRO@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DXMACRO@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DXMACRO>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@IPAU1@@Z
_TEXT	SEGMENT
$T159723 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@IPAU1@@Z PROC ; std::_Allocate<_D3DXMACRO>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159723[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159723[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@IPAU1@@Z ENDP ; std::_Allocate<_D3DXMACRO>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T159726 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159726[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159726[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159730 = -2						; size = 1
$T159729 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159729[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 8
	mov	BYTE PTR $T159730[ebp], al
	movzx	eax, BYTE PTR $T159729[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159730[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PADIDV?$allocator@D@std@@@std@@YAXPADIABDAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<char *,unsigned int,char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PADIDV?$allocator@D@std@@@stdext@@YAXPADIABDAAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T159734 = -2						; size = 1
$T159733 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PADIDV?$allocator@D@std@@@stdext@@YAXPADIABDAAV?$allocator@D@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<char *,unsigned int,char,std::allocator<char> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159733[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T159734[ebp], al
	movzx	eax, BYTE PTR $T159733[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159734[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PADIDV?$allocator@D@std@@@std@@YAXPADIABDAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<char *,unsigned int,char,std::allocator<char> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PADIDV?$allocator@D@std@@@stdext@@YAXPADIABDAAV?$allocator@D@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<char *,unsigned int,char,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$153820 = -1					; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$153820[ebp], dl

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR __Tmp$153820[ebp]
	mov	BYTE PTR [eax], cl
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159742 = -2						; size = 1
$T159741 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159741[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8
	mov	BYTE PTR $T159742[ebp], al
	movzx	eax, BYTE PTR $T159741[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159742[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T159747 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T159747[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T159747[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 48					; 00000030H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T159752 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T159752[ebp], eax
	cmp	DWORD PTR $T159752[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T159752[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T159752[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@TShaderEnvKey@Ogre@@PAVCompiledShader@2@U?$less@TShaderEnvKey@Ogre@@@std@@V?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Ogre::ShaderEnvKey,Ogre::CompiledShader *,std::less<Ogre::ShaderEnvKey>,std::allocator<std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBTShaderEnvKey@Ogre@@PAVCompiledShader@2@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<Ogre::ShaderEnvKey const ,Ogre::CompiledShader *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z ; std::allocator<Ogre::ShaderEnvKey>::destroy
PUBLIC	?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z ; std::allocator<Ogre::ShaderEnvKey>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z ; std::allocator<Ogre::ShaderEnvKey>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z ; std::allocator<Ogre::ShaderEnvKey>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PATShaderEnvKey@Ogre@@IT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@IABT12@AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::ShaderEnvKey *,unsigned int,Ogre::ShaderEnvKey,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z PROC ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ENDP ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z ; std::allocator<_D3DXMACRO>::destroy
PUBLIC	?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z ; std::allocator<_D3DXMACRO>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z ; std::allocator<_D3DXMACRO>::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z ; std::allocator<_D3DXMACRO>::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAU_D3DXMACRO@@IU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@IABU1@AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<_D3DXMACRO *,unsigned int,_D3DXMACRO,std::allocator<_D3DXMACRO> >
PUBLIC	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PassDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::PassDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::PassDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUPassDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::PassDesc *,Ogre::PassDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159818 = -7						; size = 1
$T159817 = -6						; size = 1
$T159816 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T159816[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T159817[ebp], dl
	movzx	eax, BYTE PTR $T159816[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159817[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T159818[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z ; std::allocator<Ogre::PassDesc>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z ; std::allocator<Ogre::PassDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@0AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PassDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159824 = -2						; size = 1
$T159823 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159823[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z ; std::_Move_cat<Ogre::PassDesc *>
	add	esp, 4
	mov	BYTE PTR $T159824[ebp], al
	movzx	edx, BYTE PTR $T159823[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159824[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z PROC ; std::_Fill<Ogre::PassDesc *,Ogre::PassDesc>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Fill@PAUPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@0ABU12@@Z ENDP ; std::_Fill<Ogre::PassDesc *,Ogre::PassDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z PROC ; std::_Move_cat<Ogre::PassDesc *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUPassDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassDesc@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::PassDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUPassDesc@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159832 = -2						; size = 1
$T159831 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUPassDesc@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159831[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 8
	mov	BYTE PTR $T159832[ebp], al
	movzx	eax, BYTE PTR $T159831[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159832[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUPassDesc@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPAD@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAD@std@@YAPADAAPAD@Z PROC		; std::_Checked_base<char *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPAD@Z ENDP		; std::_Checked_base<char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z PROC ; std::_Iter_random<char *,char *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ENDP ; std::_Iter_random<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z PROC ; std::_Ptr_cat<char *,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ENDP ; std::_Ptr_cat<char *,char *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PADPADV?$allocator@D@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00AAV?$allocator@D@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<char *,char *,std::allocator<char>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T159846 = -2						; size = 1
$T159845 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<char *,char *,std::allocator<char> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159845[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z ; std::_Move_cat<char *>
	add	esp, 4
	mov	BYTE PTR $T159846[ebp], al
	movzx	edx, BYTE PTR $T159845[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159846[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PADPADV?$allocator@D@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00AAV?$allocator@D@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<char *,char *,std::allocator<char>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PADD@std@@YAXPAD0ABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PADD@std@@YAXPAD0ABD@Z PROC			; std::_Fill<char *,char>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PADD@std@@YAXPAD0ABD@Z ENDP			; std::_Fill<char *,char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z PROC ; std::_Move_cat<char *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAD@std@@YA?AU_Undefined_move_tag@0@ABQAD@Z ENDP ; std::_Move_cat<char *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<char *,char *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PADPADUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159854 = -2						; size = 1
$T159853 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PADPADUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<char *,char *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159853[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T159854[ebp], al
	movzx	eax, BYTE PTR $T159853[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159854[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<char *,char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PADPADUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<char *,char *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAXPAPAUTechniqueDesc@Ogre@@0AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159860 = -2						; size = 1
$T159859 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159859[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ; std::_Move_cat<Ogre::TechniqueDesc * *>
	add	esp, 4
	mov	BYTE PTR $T159860[ebp], al
	movzx	edx, BYTE PTR $T159859[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159860[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z PROC ; std::_Checked_base<Ogre::TechniqueDesc * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ENDP ; std::_Checked_base<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z PROC ; std::_Fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@3
$LN2@Fill@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@3

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@3
$LN4@Fill@3:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAUTechniqueDesc@Ogre@@PAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@0ABQAU12@@Z ENDP ; std::_Fill<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z PROC ; std::_Move_cat<Ogre::TechniqueDesc * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::TechniqueDesc * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159872 = -2						; size = 1
$T159871 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159871[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 8
	mov	BYTE PTR $T159872[ebp], al
	movzx	eax, BYTE PTR $T159871[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159872[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z ; std::allocator<Ogre::ShaderEnvKey>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAXPATShaderEnvKey@Ogre@@0AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159878 = -2						; size = 1
$T159877 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159877[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z ; std::_Move_cat<Ogre::ShaderEnvKey *>
	add	esp, 4
	mov	BYTE PTR $T159878[ebp], al
	movzx	edx, BYTE PTR $T159877[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159878[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z PROC ; std::_Checked_base<Ogre::ShaderEnvKey *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ENDP ; std::_Checked_base<Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z PROC ; std::_Fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@4
$LN2@Fill@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@4

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN2@Fill@4
$LN4@Fill@4:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PATShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@0ABT12@@Z ENDP ; std::_Fill<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AUrandom_access_iterator_tag@0@ABQATShaderEnvKey@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AUrandom_access_iterator_tag@0@ABQATShaderEnvKey@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AUrandom_access_iterator_tag@0@ABQATShaderEnvKey@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z PROC ; std::_Move_cat<Ogre::ShaderEnvKey *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PATShaderEnvKey@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQATShaderEnvKey@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::ShaderEnvKey *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159890 = -2						; size = 1
$T159889 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159889[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 8
	mov	BYTE PTR $T159890[ebp], al
	movzx	eax, BYTE PTR $T159889[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159890[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAXPAPAVCompiledShader@Ogre@@0AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159896 = -2						; size = 1
$T159895 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159895[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ; std::_Move_cat<Ogre::CompiledShader * *>
	add	esp, 4
	mov	BYTE PTR $T159896[ebp], al
	movzx	edx, BYTE PTR $T159895[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159896[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::CompiledShader * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@5
$LN2@Fill@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@5

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@5
$LN4@Fill@5:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVCompiledShader@Ogre@@PAV12@@std@@YAXPAPAVCompiledShader@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::CompiledShader * *,Ogre::CompiledShader *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::CompiledShader * *,Ogre::CompiledShader * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z PROC ; std::_Move_cat<Ogre::CompiledShader * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::CompiledShader * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159908 = -2						; size = 1
$T159907 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159907[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 8
	mov	BYTE PTR $T159908[ebp], al
	movzx	eax, BYTE PTR $T159907[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159908[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159919 = -7						; size = 1
$T159918 = -6						; size = 1
$T159917 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T159917[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T159918[ebp], al
	movzx	ecx, BYTE PTR $T159917[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T159918[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159919[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@3

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy
	jmp	SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DShaderTechnique::PassData> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T159925 = -2						; size = 1
$T159924 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159924[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::_Move_cat<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	mov	BYTE PTR $T159925[ebp], al
	movzx	edx, BYTE PTR $T159924[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159925[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@6
$LN2@Fill@6:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@6:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@6

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN2@Fill@6
$LN4@Fill@6:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPassData@D3DShaderTechnique@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159933 = -2						; size = 1
$T159932 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159932[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8
	mov	BYTE PTR $T159933[ebp], al
	movzx	eax, BYTE PTR $T159932[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159933[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<_D3DXMACRO> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@4
$LN2@Destroy_ra@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@4

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z ; std::allocator<_D3DXMACRO>::destroy
	jmp	SHORT $LN2@Destroy_ra@4
$LN4@Destroy_ra@4:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAXPAU_D3DXMACRO@@0AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z
_TEXT	SEGMENT
$T159939 = -2						; size = 1
$T159938 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T159938[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z ; std::_Move_cat<_D3DXMACRO *>
	add	esp, 4
	mov	BYTE PTR $T159939[ebp], al
	movzx	edx, BYTE PTR $T159938[ebp]
	push	edx
	movzx	eax, BYTE PTR $T159939[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<_D3DXMACRO *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z PROC ; std::_Checked_base<_D3DXMACRO *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ENDP ; std::_Checked_base<_D3DXMACRO *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z PROC ; std::_Fill<_D3DXMACRO *,_D3DXMACRO>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@7
$LN2@Fill@7:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@7:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@7

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill@7
$LN4@Fill@7:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAU_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@0ABU1@@Z ENDP ; std::_Fill<_D3DXMACRO *,_D3DXMACRO>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAU_D3DXMACRO@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DXMACRO@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAU_D3DXMACRO@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DXMACRO@@0@Z PROC ; std::_Iter_random<_D3DXMACRO *,_D3DXMACRO *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAU_D3DXMACRO@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DXMACRO@@0@Z ENDP ; std::_Iter_random<_D3DXMACRO *,_D3DXMACRO *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z PROC ; std::_Move_cat<_D3DXMACRO *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAU_D3DXMACRO@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DXMACRO@@@Z ENDP ; std::_Move_cat<_D3DXMACRO *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAU_D3DXMACRO@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T159951 = -2						; size = 1
$T159950 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAU_D3DXMACRO@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T159950[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 8
	mov	BYTE PTR $T159951[ebp], al
	movzx	eax, BYTE PTR $T159950[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T159951[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAU_D3DXMACRO@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::PassDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::PassDesc>::construct
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z ; std::allocator<Ogre::PassDesc>::destroy
	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUPassDesc@Ogre@@IU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAXPAUPassDesc@Ogre@@IABU12@AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::PassDesc *,unsigned int,Ogre::PassDesc,std::allocator<Ogre::PassDesc> >
PUBLIC	??$unchecked_fill_n@PADID@stdext@@YAXPADIABD@Z	; stdext::unchecked_fill_n<char *,unsigned int,char>
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_fill_n@PADIDV?$allocator@D@std@@@std@@YAXPADIABDAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PADIDV?$allocator@D@std@@@std@@YAXPADIABDAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<char *,unsigned int,char,std::allocator<char> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PADID@stdext@@YAXPADIABD@Z ; stdext::unchecked_fill_n<char *,unsigned int,char>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PADIDV?$allocator@D@std@@@std@@YAXPADIABDAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<char *,unsigned int,char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::construct
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::construct
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@4:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy
	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUPassData@D3DShaderTechnique@Ogre@@IU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@IABU123@AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DShaderTechnique::PassData *,unsigned int,Ogre::D3DShaderTechnique::PassData,std::allocator<Ogre::D3DShaderTechnique::PassData> >
PUBLIC	??$_Construct@TShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@ABT12@@Z ; std::_Construct<Ogre::ShaderEnvKey,Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z PROC ; std::allocator<Ogre::ShaderEnvKey>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@TShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@ABT12@@Z ; std::_Construct<Ogre::ShaderEnvKey,Ogre::ShaderEnvKey>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z ENDP ; std::allocator<Ogre::ShaderEnvKey>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@TShaderEnvKey@Ogre@@@std@@YAXPATShaderEnvKey@Ogre@@@Z ; std::_Destroy<Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z PROC ; std::allocator<Ogre::ShaderEnvKey>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@TShaderEnvKey@Ogre@@@std@@YAXPATShaderEnvKey@Ogre@@@Z ; std::_Destroy<Ogre::ShaderEnvKey>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z ENDP ; std::allocator<Ogre::ShaderEnvKey>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::PassDesc,Ogre::PassDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::PassDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::PassDesc,Ogre::PassDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::PassDesc>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UPassDesc@Ogre@@@std@@YAXPAUPassDesc@Ogre@@@Z ; std::_Destroy<Ogre::PassDesc>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z PROC ; std::allocator<Ogre::PassDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UPassDesc@Ogre@@@std@@YAXPAUPassDesc@Ogre@@@Z ; std::_Destroy<Ogre::PassDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::PassDesc>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@ABU123@@Z ; std::_Construct<Ogre::D3DShaderTechnique::PassData,Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@ABU123@@Z ; std::_Construct<Ogre::D3DShaderTechnique::PassData,Ogre::D3DShaderTechnique::PassData>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UPassData@D3DShaderTechnique@Ogre@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::_Destroy<Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z PROC ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UPassData@D3DShaderTechnique@Ogre@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::_Destroy<Ogre::D3DShaderTechnique::PassData>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z ENDP ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@U_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@ABU1@@Z ; std::_Construct<_D3DXMACRO,_D3DXMACRO>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z PROC ; std::allocator<_D3DXMACRO>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@U_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@ABU1@@Z ; std::_Construct<_D3DXMACRO,_D3DXMACRO>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z ENDP ; std::allocator<_D3DXMACRO>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@U_D3DXMACRO@@@std@@YAXPAU_D3DXMACRO@@@Z ; std::_Destroy<_D3DXMACRO>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z PROC ; std::allocator<_D3DXMACRO>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_D3DXMACRO@@@std@@YAXPAU_D3DXMACRO@@@Z ; std::_Destroy<_D3DXMACRO>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z ENDP ; std::allocator<_D3DXMACRO>::destroy
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
PUBLIC	??$_Iter_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ; std::_Iter_cat<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@@Z
_TEXT	SEGMENT
$T160003 = -2						; size = 1
$T160002 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160002[ebp], al
	movzx	ecx, BYTE PTR $T160002[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160003[ebp]
	push	eax
	call	??$_Iter_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ; std::_Iter_cat<Ogre::TechniqueDesc * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@stdext@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
PUBLIC	??$_Iter_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ; std::_Iter_cat<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T160007 = -2						; size = 1
$T160006 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160006[ebp], al
	movzx	ecx, BYTE PTR $T160006[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160007[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ; std::_Iter_cat<Ogre::CompiledShader * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@stdext@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::PassDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::PassDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160018 = -7						; size = 1
$T160017 = -6						; size = 1
$T160016 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T160016[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T160017[ebp], al
	movzx	ecx, BYTE PTR $T160016[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T160017[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160018[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@@std@@YAPAUPassDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<char *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PADPADV?$allocator@D@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00AAV?$allocator@D@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PADPADV?$allocator@D@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00AAV?$allocator@D@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<char *,char *,std::allocator<char>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PADPADV?$allocator@D@std@@U_Undefined_move_tag@2@@std@@YAPADPAD00AAV?$allocator@D@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<char *,char *,std::allocator<char>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<char *,char *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Result$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<char *,char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::TechniqueDesc * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::TechniqueDesc * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAUTechniqueDesc@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ShaderEnvKey *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ShaderEnvKey *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Uforward_iterator_tag@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160039 = -7						; size = 1
$T160038 = -6						; size = 1
$T160037 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T160037[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T160038[ebp], al
	movzx	ecx, BYTE PTR $T160037[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T160038[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160039[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Uforward_iterator_tag@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::CompiledShader * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::CompiledShader * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVCompiledShader@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN2@Copy_opt@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@3:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN2@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160056 = -7						; size = 1
$T160055 = -6						; size = 1
$T160054 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	imul	eax, 12					; 0000000cH
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160054[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T160055[ebp], cl
	movzx	edx, BYTE PTR $T160054[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160055[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160056[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<_D3DXMACRO *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<_D3DXMACRO *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160065 = -7						; size = 1
$T160064 = -6						; size = 1
$T160063 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T160063[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T160064[ebp], al
	movzx	ecx, BYTE PTR $T160063[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T160064[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160065[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@@std@@YAPAU_D3DXMACRO@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PADID@std@@YAXPADIABDUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<char *,unsigned int,char>
PUBLIC	??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ; std::_Iter_cat<char *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PADID@stdext@@YAXPADIABD@Z
_TEXT	SEGMENT
$T160069 = -2						; size = 1
$T160068 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PADID@stdext@@YAXPADIABD@Z PROC	; stdext::unchecked_fill_n<char *,unsigned int,char>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160068[ebp], al
	movzx	ecx, BYTE PTR $T160068[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160069[ebp]
	push	eax
	call	??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ; std::_Iter_cat<char *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PADID@std@@YAXPADIABDUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<char *,unsigned int,char>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PADID@stdext@@YAXPADIABD@Z ENDP	; stdext::unchecked_fill_n<char *,unsigned int,char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@TShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@ABT12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T160072 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@TShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@ABT12@@Z PROC ; std::_Construct<Ogre::ShaderEnvKey,Ogre::ShaderEnvKey>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160072[ebp], eax
	cmp	DWORD PTR $T160072[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T160072[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T160072[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@TShaderEnvKey@Ogre@@T12@@std@@YAXPATShaderEnvKey@Ogre@@ABT12@@Z ENDP ; std::_Construct<Ogre::ShaderEnvKey,Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@TShaderEnvKey@Ogre@@@std@@YAXPATShaderEnvKey@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@TShaderEnvKey@Ogre@@@std@@YAXPATShaderEnvKey@Ogre@@@Z PROC ; std::_Destroy<Ogre::ShaderEnvKey>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@TShaderEnvKey@Ogre@@@std@@YAXPATShaderEnvKey@Ogre@@@Z ENDP ; std::_Destroy<Ogre::ShaderEnvKey>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T160079 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::PassDesc,Ogre::PassDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160079[ebp], eax
	cmp	DWORD PTR $T160079[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T160079[ebp]
	rep movsd
	mov	edx, DWORD PTR $T160079[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN1@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@3:

; 53   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UPassDesc@Ogre@@U12@@std@@YAXPAUPassDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::PassDesc,Ogre::PassDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UPassDesc@Ogre@@@std@@YAXPAUPassDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UPassDesc@Ogre@@@std@@YAXPAUPassDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::PassDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UPassDesc@Ogre@@@std@@YAXPAUPassDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::PassDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T160086 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::D3DShaderTechnique::PassData,Ogre::D3DShaderTechnique::PassData>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160086[ebp], eax
	cmp	DWORD PTR $T160086[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T160086[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T160086[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@4:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UPassData@D3DShaderTechnique@Ogre@@U123@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::D3DShaderTechnique::PassData,Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UPassData@D3DShaderTechnique@Ogre@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UPassData@D3DShaderTechnique@Ogre@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@@Z PROC ; std::_Destroy<Ogre::D3DShaderTechnique::PassData>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UPassData@D3DShaderTechnique@Ogre@@@std@@YAXPAUPassData@D3DShaderTechnique@Ogre@@@Z ENDP ; std::_Destroy<Ogre::D3DShaderTechnique::PassData>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@U_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@ABU1@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T160093 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@ABU1@@Z PROC ; std::_Construct<_D3DXMACRO,_D3DXMACRO>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160093[ebp], eax
	cmp	DWORD PTR $T160093[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T160093[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T160093[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@5:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@U_D3DXMACRO@@U1@@std@@YAXPAU_D3DXMACRO@@ABU1@@Z ENDP ; std::_Construct<_D3DXMACRO,_D3DXMACRO>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_D3DXMACRO@@@std@@YAXPAU_D3DXMACRO@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_D3DXMACRO@@@std@@YAXPAU_D3DXMACRO@@@Z PROC ; std::_Destroy<_D3DXMACRO>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_D3DXMACRO@@@std@@YAXPAU_D3DXMACRO@@@Z ENDP ; std::_Destroy<_D3DXMACRO>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::TechniqueDesc * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAUTechniqueDesc@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUTechniqueDesc@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::TechniqueDesc * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160102 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160102[ebp], al
	movzx	ecx, BYTE PTR $T160102[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::CompiledShader * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVCompiledShader@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCompiledShader@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::CompiledShader * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160107 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160107[ebp], al
	movzx	ecx, BYTE PTR $T160107[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160111 = -2						; size = 1
$T160110 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160110[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PassDesc *,Ogre::PassDesc *>
	add	esp, 8
	mov	BYTE PTR $T160111[ebp], al
	movzx	eax, BYTE PTR $T160110[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160111[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassDesc@Ogre@@@std@@YAPAUPassDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PassDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@stdext@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
$LN2@Copy_backw@4:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@4

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	esi, DWORD PTR __Last$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	jmp	SHORT $LN2@Copy_backw@4
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPassDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::PassDesc *,Ogre::PassDesc *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T160117 = -2						; size = 1
$T160116 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160116[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T160117[ebp], al
	movzx	eax, BYTE PTR $T160116[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160117[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160121 = -2						; size = 1
$T160120 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160120[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUTechniqueDesc@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUTechniqueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *>
	add	esp, 8
	mov	BYTE PTR $T160121[ebp], al
	movzx	eax, BYTE PTR $T160120[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160121[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUTechniqueDesc@Ogre@@@std@@YAPAPAUTechniqueDesc@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::TechniqueDesc * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@stdext@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160125 = -2						; size = 1
$T160124 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160124[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PATShaderEnvKey@Ogre@@PAT12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPATShaderEnvKey@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *>
	add	esp, 8
	mov	BYTE PTR $T160125[ebp], al
	movzx	eax, BYTE PTR $T160124[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160125[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PATShaderEnvKey@Ogre@@@std@@YAPATShaderEnvKey@Ogre@@AAPAT12@@Z ; std::_Checked_base<Ogre::ShaderEnvKey *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@stdext@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Uforward_iterator_tag@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Uforward_iterator_tag@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@5:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@5

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_backw@5
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PATShaderEnvKey@Ogre@@PAT12@Uforward_iterator_tag@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160131 = -2						; size = 1
$T160130 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160130[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVCompiledShader@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCompiledShader@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CompiledShader * *,Ogre::CompiledShader * *>
	add	esp, 8
	mov	BYTE PTR $T160131[ebp], al
	movzx	eax, BYTE PTR $T160130[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160131[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVCompiledShader@Ogre@@@std@@YAPAPAVCompiledShader@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::CompiledShader * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@stdext@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160135 = -2						; size = 1
$T160134 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160134[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPassData@D3DShaderTechnique@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *>
	add	esp, 8
	mov	BYTE PTR $T160135[ebp], al
	movzx	eax, BYTE PTR $T160134[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160135[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPassData@D3DShaderTechnique@Ogre@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::D3DShaderTechnique::PassData *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@stdext@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@6:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@6

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN2@Copy_backw@6
$LN1@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z
_TEXT	SEGMENT
$T160141 = -2						; size = 1
$T160140 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160140[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DXMACRO@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DXMACRO@@0@Z ; std::_Ptr_cat<_D3DXMACRO *,_D3DXMACRO *>
	add	esp, 8
	mov	BYTE PTR $T160141[ebp], al
	movzx	eax, BYTE PTR $T160140[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160141[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAU_D3DXMACRO@@@std@@YAPAU_D3DXMACRO@@AAPAU1@@Z ; std::_Checked_base<_D3DXMACRO *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@stdext@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@7:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@7

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw@7
$LN1@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAU_D3DXMACRO@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<_D3DXMACRO *,_D3DXMACRO *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z PROC ; std::_Iter_cat<char *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD@Z ENDP ; std::_Iter_cat<char *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PADID@std@@YAXPADIABDU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<char *,unsigned int,char>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PADID@std@@YAXPADIABDUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160148 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PADID@std@@YAXPADIABDUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<char *,unsigned int,char>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __First$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Last$[ebp], eax

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T160148[ebp], cl
	movzx	edx, BYTE PTR $T160148[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PADID@std@@YAXPADIABDU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<char *,unsigned int,char>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PADID@std@@YAXPADIABDUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<char *,unsigned int,char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAUTechniqueDesc@Ogre@@IPAU12@@std@@YAXPAPAUTechniqueDesc@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::TechniqueDesc * *,unsigned int,Ogre::TechniqueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@2
$LN2@Fill_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@2

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@2
$LN4@Fill_n@2:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVCompiledShader@Ogre@@IPAV12@@std@@YAXPAPAVCompiledShader@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::CompiledShader * *,unsigned int,Ogre::CompiledShader *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::PassDesc>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassDesc@Ogre@@@std@@QAEXPAUPassDesc@Ogre@@@Z ; std::allocator<Ogre::PassDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUPassDesc@Ogre@@PAU12@V?$allocator@UPassDesc@Ogre@@@std@@@std@@YAPAUPassDesc@Ogre@@PAU12@00AAV?$allocator@UPassDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::PassDesc *,Ogre::PassDesc *,std::allocator<Ogre::PassDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAUTechniqueDesc@Ogre@@PAPAU12@V?$allocator@PAUTechniqueDesc@Ogre@@@std@@@std@@YAPAPAUTechniqueDesc@Ogre@@PAPAU12@00AAV?$allocator@PAUTechniqueDesc@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::TechniqueDesc * *,Ogre::TechniqueDesc * *,std::allocator<Ogre::TechniqueDesc *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@ABT34@@Z ; std::allocator<Ogre::ShaderEnvKey>::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@TShaderEnvKey@Ogre@@@std@@QAEXPATShaderEnvKey@Ogre@@@Z ; std::allocator<Ogre::ShaderEnvKey>::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PATShaderEnvKey@Ogre@@PAT12@V?$allocator@TShaderEnvKey@Ogre@@@std@@@std@@YAPATShaderEnvKey@Ogre@@PAT12@00AAV?$allocator@TShaderEnvKey@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderEnvKey *,Ogre::ShaderEnvKey *,std::allocator<Ogre::ShaderEnvKey> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@5

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@5:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVCompiledShader@Ogre@@PAPAV12@V?$allocator@PAVCompiledShader@Ogre@@@std@@@std@@YAPAPAVCompiledShader@Ogre@@PAPAV12@00AAV?$allocator@PAVCompiledShader@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::CompiledShader * *,Ogre::CompiledShader * *,std::allocator<Ogre::CompiledShader *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@6
$LN5@Uninit_cop@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@6:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@ABU345@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::construct
	jmp	SHORT $LN5@Uninit_cop@6
$LN4@Uninit_cop@6:
	jmp	SHORT $LN10@Uninit_cop@6
__catch$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@6
$LN2@Uninit_cop@6:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@6:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@6

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@QAEXPAUPassData@D3DShaderTechnique@Ogre@@@Z ; std::allocator<Ogre::D3DShaderTechnique::PassData>::destroy
	jmp	SHORT $LN2@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@6:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUPassData@D3DShaderTechnique@Ogre@@PAU123@V?$allocator@UPassData@D3DShaderTechnique@Ogre@@@std@@@std@@YAPAUPassData@D3DShaderTechnique@Ogre@@PAU123@00AAV?$allocator@UPassData@D3DShaderTechnique@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DShaderTechnique::PassData *,Ogre::D3DShaderTechnique::PassData *,std::allocator<Ogre::D3DShaderTechnique::PassData> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@7
$LN5@Uninit_cop@7:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@7:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@ABU3@@Z ; std::allocator<_D3DXMACRO>::construct
	jmp	SHORT $LN5@Uninit_cop@7
$LN4@Uninit_cop@7:
	jmp	SHORT $LN10@Uninit_cop@7
__catch$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@7
$LN2@Uninit_cop@7:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@7:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@7

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DXMACRO@@@std@@QAEXPAU_D3DXMACRO@@@Z ; std::allocator<_D3DXMACRO>::destroy
	jmp	SHORT $LN2@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@7:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU_D3DXMACRO@@PAU1@V?$allocator@U_D3DXMACRO@@@std@@@std@@YAPAU_D3DXMACRO@@PAU1@00AAV?$allocator@U_D3DXMACRO@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_D3DXMACRO *,_D3DXMACRO *,std::allocator<_D3DXMACRO> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PADID@std@@YAXPADIABDU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PADID@std@@YAXPADIABDU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<char *,unsigned int,char>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@3
$LN2@Fill_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@3

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN2@Fill_n@3
$LN4@Fill_n@3:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PADID@std@@YAXPADIABDU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<char *,unsigned int,char>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END
